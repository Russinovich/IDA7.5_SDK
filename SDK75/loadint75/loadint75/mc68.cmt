  mc_abcd:      "Add Decimal with Extend"
  mc_add:       "Add"
  mc_adda:      "Add Address"
  mc_addi:      "Add Immediate"
  mc_addq:      "Add Quick"
  mc_addx:      "Add Extended"
  mc_and:       "AND Logical"
  mc_andi:      "AND Immediate"
  mc_asl:       "Arithmetic Shift Left"
  mc_asr:       "Arithmetic Shift Right"
  mc_b:  "Branch if " { auxpref ?
               003:    "High"
               004:    "Low or Same"
               005:    "Carry CLear"
               006:    "Carry Set"
               007:    "Not Equal"
               010:    "Equal"
               011:    "Overflow Clear"
               012:    "Overflow Set"
               013:    "Plus"
               014:    "Minus"
               015:    "Greater or Equal"
               016:    "Less Than"
               017:    "Greater Than"
               020:    "Less or Equal"
         }
  mc_bchg:      "Test a Bit and Change"
  mc_bclr:      "Test a Bit and Clear"
  mc_bfchg:     "Test Bit Field and Change"
  mc_bfclr:     "Test Bit Field and Clear"
  mc_bfexts:    "Extract Bit Field Signed"
  mc_bfextu:    "Extract Bit Field Unsigned"
  mc_bfffo:     "Find First One in Bit Field"
  mc_bfins:     "Insert Bit Field"
  mc_bftst:     "Test Bit Field"
  mc_bfset:     "Test Bit Field and Set"
  mc_bgnd:      "Enter Background Mode"
  mc_bkpt:      "Breakpoint"
  mc_bra:       "Branch Always"
  mc_bset:      "Test a Bit and Set"
  mc_bsr:       "Branch to Subroutine"
  mc_btst:      "Test a Bit"
  mc_callm:     "Call Module"
  mc_cas || mc_cas2: "Compare and Swap with Operand"
  mc_chk || mc_chk2: "Check Register Against Bounds"
  mc_cinv:      "Invalidate Cache Lines"
  mc_clr:       "Clear an Operand"
  mc_cmp:       "Compare"
  mc_cmp2:      "Compare Register Against Bounds"
  mc_cmpa:      "Compare Address"
  mc_cmpi:      "Compare Immediate"
  mc_cmpm:      "Compare Memory"
  mc_cpush:     "Push and Invalidate Cache Lines"
  mc_db:    { auxpref ?
               001:    "If True Decrement and Branch"
               002:    "If False Decrement and Branch"
               003:    "If High Decrement and Branch"
               004:    "If Low or Same Decrement and Branch"
               005:    "If Carry CLear Decrement and Branch"
               006:    "If Carry Set Decrement and Branch"
               007:    "If Not Equal Decrement and Branch"
               010:    "If Equal Decrement and Branch"
               011:    "If Overflow Clear Decrement and Branch"
               012:    "If Overflow Set Decrement and Branch"
               013:    "If Plus Decrement and Branch"
               014:    "If Minus Decrement and Branch"
               015:    "If Greater or Equal Decrement and Branch"
               016:    "If Less Than Decrement and Branch"
               017:    "If Greater Than Decrement and Branch"
               020:    "If Less or Equal Decrement and Branch"
            }
  mc_divs || mc_divsl:  "Signed Divide"
  mc_divu || mc_divul:  "Unsigned Divide"
  mc_eor:       "Exclusive-OR Logical"
  mc_eori:      "Exclusive OR Immediate"
  mc_exg:       "Exchange Register"
  mc_ext || mc_extb:  "Sign Extend"
  mc_fabs:      "FP Absolute Value"
  mc_facos:     "Arc Cosinus"
  mc_fadd:      "FP Add"
  mc_fasin:     "Arc Sine"
  mc_fatan:     "Arc Tangent"
  mc_fatanh:    "Hiperbolic Arc Tangent"
  mc_fb:    "Branch if FP " { auxpref ?
               041:    "False"
               042:    "Equal"
               043:    "Order Greater Than"
               044:    "Order Greater Than or Equal"
               045:    "Order Less Than"
               046:    "Order Less Than or Equal"
               047:    "Order Greater or Less Than"
               050:    "Ordered"
               051:    "Unordered"
               052:    "Unordered or Equal"
               053:    "Unordered or Greater Than"
               054:    "Unordered or Greater or Equal"
               055:    "Unordered or Less Than"
               056:    "Unordered or Less or Equal"
               057:    "Not Equal"
               060:    "True"
               061:    "Signaling False"
               062:    "Signalin Equal"
               063:    "Greater Than"
               064:    "Greater Than Or Equal"
               065:    "Less Than"
               066:    "Less Than or Equal"
               067:    "Greater or Less Than"
               070:    "Greater, Less or Equal"
               071:    "Not Greater, Less or Equal"
               072:    "Not Greater or Less Than"
               073:    "Not Less Than or Equal"
               074:    "Not Less Than"
               075:    "Not Greater Than or Equal"
               076:    "Not Greater Than"
               077:    "Signaling Not Equal"
              0100:    "Signaling True"
            }
  mc_fcmp:      "FP compare"
  mc_fcos:      "Cosine"
  mc_fcosh:     "Hyperbolic Cosine"
  mc_fdabs:     "FD Absolute Value (with Double Rounded)"
  mc_fdadd:     "FP Add (with Double Rounded)"
  mc_fdb:  "Decrement and Branch if FP " { auxpref ?
               041:    "False"
               042:    "Equal"
               043:    "Order Greater Than"
               044:    "Order Greater Than or Equal"
               045:    "Order Less Than"
               046:    "Order Less Than or Equal"
               047:    "Order Greater or Less Than"
               050:    "Ordered"
               051:    "Unordered"
               052:    "Unordered or Equal"
               053:    "Unordered or Greater Than"
               054:    "Unordered or Greater or Equal"
               055:    "Unordered or Less Than"
               056:    "Unordered or Less or Equal"
               057:    "Not Equal"
               060:    "True"
               061:    "Signaling False"
               062:    "Signalin Equal"
               063:    "Greater Than"
               064:    "Greater Than Or Equal"
               065:    "Less Than"
               066:    "Less Than or Equal"
               067:    "Greater or Less Than"
               070:    "Greater, Less or Equal"
               071:    "Not Greater, Less or Equal"
               072:    "Not Greater or Less Than"
               073:    "Not Less Than or Equal"
               074:    "Not Less Than"
               075:    "Not Greater Than or Equal"
               076:    "Not Greater Than"
               077:    "Signaling Not Equal"
              0100:    "Signaling True"
            }
  mc_fddiv:     "FP Divide (with Double Rounded)"
  mc_fdiv:      "FP Divide"
  mc_fdmove:    "FP Move (with Double Rounded)"
  mc_fdmul:     "FP Multiply (with Double Rounded)"
  mc_fdneg:     "FP Negate (with Double Rounded)"
  mc_fdsqrt:    "FP Square Root (with Double Rounded)" 
  mc_fdsub:     "FP Subtract (with Double Rounded)"
  mc_fetox:     "e**x"
  mc_fetoxm1:   "(e**x)-1"
  mc_fgetexp:   "Get Exponent"
  mc_fgetman:   "Get Mantissa"
  mc_fint:      "Integer Part"
  mc_fintrz:    "Integer Part, Round-to-Zero"
  mc_flog2:     "Log2"
  mc_flog10:    "log10"
  mc_flogn:     "ln"
  mc_flognp1:   "ln(x+1)"
  mc_fmod:      "Modulo Remainder"
  mc_fmove:     "FP Move"
  mc_fmovecr: "Move Constant ROM => " { op1 ?
                                          0x00: "Pi"
                                          0x0B: "log10(2)"
                                          0x0C:  "e"
                                          0x0D:  "log2(e)"
                                          0x0E:  "log10(e)"
                                          0x0F:  "0.0"
                                          0x30:  "1n(2)"
                                          0x31:  "1n(10)"
                                          0x32:  "10**0"
                                          0x33:  "10**1"
                                          0x34:  "10**2"
                                          0x35:  "10**4"
                                          0x36:  "10**8"
                                          0x37:  "10**16"
                                          0x38:  "10**32"
                                          0x39:  "10**64"
                                          0x3A:  "10**128"
                                          0x3B:  "10**256"
                                          0x3C:  "10**512"
                                          0x3D:  "10**1024"
                                          0x3E:  "10**2048"
                                          0x3F:  "10**4096"
                                          other: "UNDEFINED (0)"
                                      }
  mc_fmovem:    "Move Multiple FP Register"
  mc_fmul:      "FP Multiply"
  mc_fneg:      "FP Negate"
  mc_fnop:      "FP No Operation"
  mc_frem:      "IEEE Remainder"
  mc_frestore:  "Resore Internal FP State"
  mc_fs: "Set According to FP Condition (TRUE if " { auxpref ?
               041:    "False)"
               042:    "Equal)"
               043:    "Order Greater Than)"
               044:    "Order Greater Than or Equal)"
               045:    "Order Less Than)"
               046:    "Order Less Than or Equal)"
               047:    "Order Greater or Less Than)"
               050:    "Ordered)"
               051:    "Unordered)"
               052:    "Unordered or Equal)"
               053:    "Unordered or Greater Than)"
               054:    "Unordered or Greater or Equal)"
               055:    "Unordered or Less Than)"
               056:    "Unordered or Less or Equal)"
               057:    "Not Equal)"
               060:    "True)"
               061:    "Signaling False)"
               062:    "Signalin Equal)"
               063:    "Greater Than)"
               064:    "Greater Than Or Equal)"
               065:    "Less Than)"
               066:    "Less Than or Equal)"
               067:    "Greater or Less Than)"
               070:    "Greater, Less or Equal)"
               071:    "Not Greater, Less or Equal)"
               072:    "Not Greater or Less Than)"
               073:    "Not Less Than or Equal)"
               074:    "Not Less Than)"
               075:    "Not Greater Than or Equal)"
               076:    "Not Greater Than)"
               077:    "Signaling Not Equal)"
              0100:    "Signaling True)"
            }
  mc_fsabs:     "FP Absolute Value (with Single Rounded)"
  mc_fsadd:     "FP Add (with Single Rounded)"
  mc_fsave:     "Save Internal FP State"
  mc_fscale:    "Scale Exponent"
  mc_fsdiv:     "FP Divide (with Single Rounded)"
  mc_fsgldiv:   "Single Precision Divide"
  mc_fsglmul:   "Single Precision Multipy"
  mc_fsin:      "Sine"
  mc_fsincos:   "Simultaneous Sine and Cosine"
  mc_fsinh:     "Hyperbolic Sine"
  mc_fsmove:    "FP Move (with Single Rounded)"
  mc_fsmul:     "FP Multiply (with Single Rounded)"
  mc_fsneg:     "FP Negate (with Single Rounded)"
  mc_fsqrt:     "FP Square Root" 
  mc_fssqrt:    "FP Square Root (with Single Rounded)" 
  mc_fssub:     "FP Subtract (with Single Rounded)"
  mc_fsub:      "FP Subtract"
  mc_ftan:      "Tangent"
  mc_ftanh:     "Hiperbolyc Tangent"
  mc_ftentox:   "10**x"
  mc_ftrap:   "Trap if FP " { auxpref ?
               041:    "False)"
               042:    "Equal)"
               043:    "Order Greater Than)"
               044:    "Order Greater Than or Equal)"
               045:    "Order Less Than)"
               046:    "Order Less Than or Equal)"
               047:    "Order Greater or Less Than)"
               050:    "Ordered)"
               051:    "Unordered)"
               052:    "Unordered or Equal)"
               053:    "Unordered or Greater Than)"
               054:    "Unordered or Greater or Equal)"
               055:    "Unordered or Less Than)"
               056:    "Unordered or Less or Equal)"
               057:    "Not Equal)"
               060:    "True)"
               061:    "Signaling False)"
               062:    "Signalin Equal)"
               063:    "Greater Than)"
               064:    "Greater Than Or Equal)"
               065:    "Less Than)"
               066:    "Less Than or Equal)"
               067:    "Greater or Less Than)"
               070:    "Greater, Less or Equal)"
               071:    "Not Greater, Less or Equal)"
               072:    "Not Greater or Less Than)"
               073:    "Not Less Than or Equal)"
               074:    "Not Less Than)"
               075:    "Not Greater Than or Equal)"
               076:    "Not Greater Than)"
               077:    "Signaling Not Equal)"
              0100:    "Signaling True)"
            }
  mc_ftst:      "Test FP Operand"
  mc_ftwotox:   "2**x"
  mc_halt:      "Halt the processor"
  mc_illegal:   "Take Illegal Instruction Trap"
  mc_jmp:       "Jump"
  mc_jsr:       "Jump to Subroutine"
  mc_lea:       "Load Effective Address"
  mc_link:      "Link and Allocate"
  mc_lpstop:    "Low-Power Stop"
  mc_lsl:       "Logical Shift Left"
  mc_lsr:       "Logical Shift Right"
  mc_mac:       "Multiple and accumulate"
  mc_macl:      "Multiple and accumulate with register load"
  mc_move:      "Move Data from Source to Destination"
  mc_move16:    "Move 16-Byte Block"
  mc_movea:     "Move Address"
  mc_movec:     "Move Control Register"
  mc_movem:     "Move Multiple Registers"
  mc_movep:     "Move Peripheral Data"
  mc_moveq:     "Move Quick"
  mc_moves:     "Move Address Space"
  mc_msac:      "Multiple and subtract"
  mc_msacl:     "Multiple and subtract with register load"
  mc_muls:      "Signed Multiply"
  mc_mulu:      "Unsigned Multiply"
  mc_nbcd:      "Negate Decimal with Extend"
  mc_neg:       "Negate"
  mc_negx:      "Negate with Extend"
  mc_nop:       "No Operation"
  mc_not:       "Logical Complement"
  mc_or:        "Inclusive-OR Logical"
  mc_ori:       "Inclusive-OR"
  mc_pack:      "Pack"
  mc_pea:       "Push Effective Address"
  mc_pb:        "(PMMU Condition) Branch if " { auxpref ?
               021:    "B set"
               022:    "B clear"
               023:    "L set"
               024:    "L clear"
               025:    "S set "
               026:    "S clear"
               027:    "A set"
               030:    "A clear"
               031:    "W set"
               032:    "W clear"
               033:    "I set"
               034:    "I clear"
               035:    "G set"
               036:    "G clear"
               037:    "C set"
               040:    "C clear"
              }
  mc_pdb: "If PMMU <" { auxpref ?
               021:    "B set> then Decrement and Branch"
               022:    "B clear> then Decrement and Branch"
               023:    "L set> then Decrement and Branch"
               024:    "L clear> then Decrement and Branch"
               025:    "S set> then Decrement and Branch "
               026:    "S clear> then Decrement and Branch"
               027:    "A set> then Decrement and Branch"
               030:    "A clear> then Decrement and Branch"
               031:    "W set> then Decrement and Branch"
               032:    "W clear> then Decrement and Branch"
               033:    "I set> then Decrement and Branch"
               034:    "I clear> then Decrement and Branch"
               035:    "G set> then Decrement and Branch"
               036:    "G clear> then Decrement and Branch"
               037:    "C set> then Decrement and Branch"
               040:    "C clear> then Decrement and Branch"
              }
  mc_pflush:    "Flush (Invalidate) Entry(es) in the ATC"
  mc_pflushr:   "Invalidate ATC and RPT Entries"
  mc_ploadr:    "Load an Entry into ATC (Read)"
  mc_ploadw:    "Load an Entry into ATC (Write)"
  mc_pmove:     "Move to/from MMU Registers"
  mc_prestore:  "PMMU Restore Function"
  mc_psave:     "PMMU Save Function"
  mc_ps: "Set on PMMU " { auxpref ?
               021:    "B set"
               022:    "B clear"
               023:    "L set"
               024:    "L clear"
               025:    "S set "
               026:    "S clear"
               027:    "A set"
               030:    "A clear"
               031:    "W set"
               032:    "W clear"
               033:    "I set"
               034:    "I clear"
               035:    "G set"
               036:    "G clear"
               037:    "C set"
               040:    "C clear"
              }
  mc_ptestr:    "Test a Logical Address (Read)"
  mc_ptestw:    "Test a Logical Address (Write)"
  mc_ptrap:  "Trap if PMMU  " { auxpref ?
               021:    "B set"
               022:    "B clear"
               023:    "L set"
               024:    "L clear"
               025:    "S set "
               026:    "S clear"
               027:    "A set"
               030:    "A clear"
               031:    "W set"
               032:    "W clear"
               033:    "I set"
               034:    "I clear"
               035:    "G set"
               036:    "G clear"
               037:    "C set"
               040:    "C clear"
              }
  mc_pulse:     "Generate unique PST value"
  mc_pvalid:    "Validate a Pointer"
  mc_reset:     "Reset External Devices"
  mc_rol:       "Rotate Left (Without Extend)"
  mc_ror:       "Rotate Right (Without Extend)"
  mc_roxl:      "Rotate Left with Extend"
  mc_roxr:      "Rotate Right with Extend"
  mc_rtd:       "Return and Deallocate"
  mc_rte:       "Return from Exception"
  mc_rtm:       "Return from Module"
  mc_rtr:       "Return and Restore Condition Codes"
  mc_rts:       "Return from Subroutine"
  mc_sbcd:      "Subtract Decimal with Extend"
  mc_s: "Set According to TRUE if " { auxpref ?
               001:    "True (else to FALSE)"
               002:    "False (else to FALSE)"
               003:    "High (else to FALSE)"
               004:    "Low or Same (else to FALSE)"
               005:    "Carry CLear (else to FALSE)"
               006:    "Carry Set (else to FALSE)"
               007:    "Not Equal (else to FALSE)"
               010:    "Equal (else to FALSE)"
               011:    "Overflow Clear (else to FALSE)"
               012:    "Overflow Set (else to FALSE)"
               013:    "Plus (else to FALSE)"
               014:    "Minus (else to FALSE)"
               015:    "Greater or Equal (else to FALSE)"
               016:    "Less Than (else to FALSE)"
               017:    "Greater Than (else to FALSE)"
               020:    "Less or Equal (else to FALSE)"
         }
  mc_stop:      "Load status Register and Stop"
  mc_sub:       "Subtract"
  mc_suba:      "Subtract Address"
  mc_subi:      "Subtract Immediate"
  mc_subq:      "Subtract Quick"
  mc_subx:      "Subtract with Extend"
  mc_swap:      "Swap Register Halves"
  mc_tas:       "Test and Set an Operand"
  mc_tbl:  "Table Lookup and Interpolation " { auxpref ?
              0110 || 0111:       "(Unsigned)"
              0112 || 0113:       "(Signed)"
           }
  mc_trap:  "Trap " { auxpref ?
               000:  { op1 ?
	       		15:
#include "pilot.cmt"
	       		other: "(#vector Exception)"
		     }
               other:  "(Vector #7) if " { auxpref ?
                                                001:    "True"
                                                002:    "False"
                                                003:    "High"
                                                004:    "Low or Same"
                                                005:    "Carry CLear"
                                                006:    "Carry Set"
                                                007:    "Not Equal"
                                                010:    "Equal"
                                                011:    "Overflow Clear"
                                                012:    "Overflow Set"
                                                013:    "Plus"
                                                014:    "Minus"
                                                015:    "Greater or Equal"
                                                016:    "Less Than"
                                                017:    "Greater Than"
                                                020:    "Less or Equal"
                                        }
        }
  mc_trapv:     "Trap on Owerflow"
  mc_tst:       "Test an Operand"
  mc_unlk:      "Unlink"
  mc_unpk:      "Unpack BCD"
  mc_wddata:    "Load WDDATA port (pins)"
  mc_wdebug:    "Load debug register"
  mc_bitrev:    "Bit Reverse"
  mc_byterev:   "Byte Reverse"
  mc_ff1:       "Find First One"
  mc_intouch:   "Instruction Fetch Touch"
  mc_mov3q:     "Move 3-Bit Data Quick"
  mc_mvs:       "Move with Sign Extend"
  mc_mvz:       "Move with Zero-Fill"
  mc_sats:      "Signed Saturate"
  mc_movclr:    "Move from Accumulator and Clear"
  mc_maaac:     "Multiply and Add to 1st Accumulator: Add to 2nd Accumulator"
  mc_masac:     "Multiply and Add to 1st Accumulator: Subtract from 2nd Accumulator"
  mc_msaac:     "Multiply and Subtract to 1st Accumulator: Add to 2nd Accumulator"
  mc_mssac:     "Multiply and Subtract to 1st Accumulator: Subtract to 2nd Accumulator"
  mc_remsl:     "Signed Divide Remainder"
  mc_remul:     "Unsigned Divide Remainder"
