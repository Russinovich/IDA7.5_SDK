
I5_aci:  	"Add immediate to A with carry"
I5_adc:  	"Add reg to A with carry"
I5_add:  	"Add <reg> to A"
I5_adi:  	"Add immediate to A"
I5_ana:  	"And reg to A"
I5_ani:  	"And immediate to A"
I5_call:  	"Call subroutine at <addr>"
I5_cnz:  	"Call subroutine if non zero"
I5_cz:  	"Call subroutine if zero"
I5_cnc:  	"Call subroutine if carry clear"
I5_cc:  	"Call subroutine if carry set"
I5_cpo:  	"Call subroutine if odd  parity"
I5_cpe:  	"Call subroutine if even parity"
I5_cp:  	"Call subroutine if positive"
I5_cm:  	"Call subroutine if negative"
I5_cmc:  	"Complement carry"
I5_cmp:  	"Compare register with A"
I5_cpi:  	"Compare immediate data with A"
I5_cma:  	"Complement A"
I5_daa:  	"Decimal adjust A"
I5_dad:  	"Add register pair to HL"
I5_dcr:  	"Decrement register"
I5_dcx:  	"Decrement register pair"
I5_di:  	"Disable interrupts"
I5_ei:  	"Enable interrupts"
I5_halt:  	"Halt"
I5_in:  	"Input from port to A"
I5_inr:  	"Increment register"
I5_inx:  	"Increment register pair"
I5_jmp:  	"Jump"
I5_jnz:  	"Jump if not zero"
I5_jz:  	"Jump if zero"
I5_jnc:  	"Jump if carry clear"
I5_jc:  	"Jump if carry set"
I5_jpo:  	"Jump if parity odd"
I5_jpe:  	"Jump if parity even"
I5_jp:  	"Jump if plus"
I5_jm:  	"Jump if minus"
I5_lda:  	"Load A direct from memory"
I5_ldax:  	"Load A indirect from memory using register pair"
I5_lhld:  	"Load HL direct from memory"
I5_lxi:  	"Load register pair with immediate data"
I5_mov:  	"Move o1 <- o2"
I5_mvi:  	"Move o1 <- immediate data"
I5_nop:  	"No Operation"
I5_ora:  	"Or register with A"
I5_ori:  	"Or immediate data to A"
I5_out:  	"Output to port"
I5_pchl:  	"Jump to instruction at (HL)"
I5_pop:  	"Pop register pair from stack"
I5_push:  	"Push register pair onto stack"
I5_ret:  	"Return from subroutine"
I5_rnz:  	"Return if non zero"
I5_rz:  	"Return if zero"
I5_rnc:  	"Return if carry clear"
I5_rc:  	"Return if carry set"
I5_rpo:  	"Return if parity odd"
I5_rpe:  	"Return if parity even"
I5_rp:  	"Return if plus"
I5_rm:  	"Return if minus"
I5_ral:  	"Rotate A left with carry"
I5_rlc:  	"Rotate A left with branch carry"
I5_rar:  	"Rotate A right with carry"
I5_rrc:  	"Rotate A right with branch carry"
I5_rst:  	"Restart at vector <int>"
I5_sbb:  	"Subtract from A with borrow"
I5_sbi:  	"Subtract immediate from A with borrow"
I5_stc:  	"Set carry"
I5_sphl:  	"Exchange SP with HL"
I5_sta:  	"Store A direct memory"
I5_stax:  	"Store A indirect using register pair"
I5_shld:  	"Store HL"
I5_sui:  	"Subtract immediate from A"
I5_sub:  	"Subtract from A"
I5_xra:  	"XOR with A"
I5_xri:  	"XOR A with immediate data"
I5_xchg:  	"Exchange DE with HL"
I5_xthl:  	"Exchange HL with top of stack"
I5_rim:  	"Read interrupt mask"
I5_sim:  	"Store Interrupt mask"

//
//	Z80 instructions
//

Z80_and:	"And with accumulator"
Z80_bit:	"Test <bit> in operand"
Z80_call:	"call (cond & uncond)"
Z80_ccf:	"Complement carry flag"
Z80_cp:  	"Compare with accumulator"
Z80_cpd:  	"Compare accumulator with memory and\ndecrement address and byte counters"
Z80_cpdr:  	"Compare accumulator with memory and\ndecrement address and byte counter,\ncontinue until match is found or\nbyte counter is zero"
Z80_cpi:  	"Compare accumulator with memory and\nincrement address and byte counters"
Z80_cpir:  	"Compare accumulator with memory and\nincrement address and byte counter,\ncontinue until match is found or\nbyte counter is zero"
Z80_cpl:  	"Complement the accumulator"
Z80_dec:  	"Decrement operand"
Z80_djnz:  	"Decrement reg B and jump relative if zero"
Z80_ex:  	"Exchange operands"
Z80_exx:  	"Exchange register pairs BC,DE,HL and alt reg pairs"
Z80_halt:  	"Program execution stops"
Z80_im:  	"Interrupt mode"
Z80_inc:  	"Increment operand"
Z80_ind:  	"Input to memory and decrement pointer"
Z80_indr:  	"Input to memory and decrement pointer until\nbyte counter is zero"
Z80_ini:  	"Input to memory and increment pointer"
Z80_inir:  	"Input to memory and increment pointer until\nbyte counter is zero"
Z80_jp:  	"Jump (conditional & unconditional)"
Z80_jr:  	"Jump relative (conditional & unconditional)"
Z80_ld:  	"Move o1 <- o2"
Z80_ldd:  	"Transfer data (DE)->(HL) and decrement\ndestination and source addresses"
Z80_lddr:  	"Transfer data (DE)->(HL) until byte\ncounter is zero, decrement destintation\nand source addresses"
Z80_ldi:  	"Transfer data (DE)->(HL) and increment\ndestination and source addresses"
Z80_ldir:  	"Transfer data (DE)->(HL) until byte\ncounter is zero, increment destination\nand source addresses"
Z80_neg:  	"Negate contents of accumulator"
Z80_or:  	"Or with accumulator"
Z80_otdr:  	"Output from memory, decrement address\ncontinue until reg B is zero"
Z80_otir:  	"Output from memory, increment address\ncontinue until reg B is zero"
Z80_outd:  	"Output from memory, decrement address"
Z80_outi:  	"Output from memory, increment address"
Z80_res:  	"Reset bit"
Z80_ret:  	"Return (cond & uncond)"
Z80_reti:  	"Return from interrupt"
Z80_retn:  	"Return from non-maskable interrupt"
Z80_rl:  	"Rotate left through carry"
Z80_rla:  	"Rotate left through carry accumulator"
Z80_rlc:  	"Rotate left branch carry"
Z80_rlca:  	"Rotate left accumulator"
Z80_rld:  	"Rotate one BCD digit left between the\naccumulator and memory"
Z80_rr:  	"Rotate right through carry"
Z80_rra:  	"Rotate right through carry accumulator"
Z80_rrc:  	"Rotate right branch carry"
Z80_rrca:  	"Rotate right branch  carry accumulator"
Z80_rrd:  	"Rotate one BCD digit right between the\naccumulator and memory"
Z80_scf:  	"Set carry flag"
Z80_sbc:  	"Subtract from A with borrow"
Z80_set:  	"Set bit"
Z80_sla:  	"Shift left arithmetic"
Z80_sra:  	"Shift right arithmetic"
Z80_srl:  	"Shift right logical"
Z80_xor:  	"Exclusive or with accumulator"
Z80_inp: 	"Input from port (c) into operand"
Z80_outp:	"Output operand to port (c)"
Z80_srr: 	"Shift left filling with 1"

//
//	HD64180 extensions
//

HD_in0:  	"load register with input from port (n)"
HD_mlt:  	"multiplication of each half\nof the specified register pair\nwith the 16-bit result going to\nthe specified register pair"
HD_otim:  	"load output port (c) with\nlocation (hl),\nincrement hl and b\ndecrement c"
HD_otimr:  	"load output port (c) with\nlocation (hl),\nincrement hl and c\ndecrement b\nrepeat until b = 0"
HD_otdm:  	"load output port (c) with\nlocation (hl),\ndecrement hl and b\ndecrement c"
HD_otdmr:  	"load output port (c) with\nlocation (hl),\ndecrement hl and c\ndecrement b\nrepeat until b = 0"
HD_out0:  	"load output port (n) from register"
HD_slp:  	"enter sleep mode"
HD_tst:  	"non-destructive'and' with accumulator and specified operand"
HD_tstio:  	"non-destructive 'and' of n and the contents of port (c)"

//
//	A80 special instructions
//

A80_lbcd:  	"Move operand to BC"
A80_lded:  	"Move operand to DE"
A80_lspd:  	"Move operand to SP"
A80_lixd:  	"Move operand to IX"
A80_liyd:  	"Move operand to IY"
A80_sbcd:  	"Move BC to memory"
A80_sded:  	"Move DE to memory"
A80_sspd:  	"Move SP to memory"
A80_sixd:  	"Move IX to memory"
A80_siyd:  	"Move IY to memory"
A80_xtix:  	"Exchange SP and IX"
A80_xtiy:  	"Exchange SP and IY"
A80_spix:  	"Move IX to SP"
A80_spiy:  	"Move IY to SP"
A80_pcix:  	"Jump indirect by IX"
A80_pciy:  	"Jump indirect by IY"
A80_mvra:  	"Move A to R"
A80_mvia:  	"Move A to I"
A80_mvar:  	"Move R to A"
A80_mvai:  	"Move I to A"
A80_addix:  	"Add operand to IX"
A80_addiy:  	"Add operand to IY"
A80_addc:  	"Add operand to HL with carry"
A80_addcix:  	"Add operand to IX with carry"
A80_addciy:  	"Add operand to IY with carry"
A80_subc:  	"Subtract from HL with borrow"
A80_subcix:  	"Subtract from IX with borrow"
A80_subciy:  	"Subtract from IY with borrow"
A80_jrc:  	"Jump relative if carry"
A80_jrnc:  	"Jump relative if not carry"
A80_jrz:  	"Jump relative if zero"
A80_jrnz:  	"Jump relative if not zero"
A80_cmpi:  	"Compare accumulator with memory and\nincrement address and byte counters"
A80_cmpd:  	"Compare accumulator with memory and\ndecrement address and byte counters"
A80_im0:  	"Interrupt mode 0"
A80_im1:  	"Interrupt mode 1"
A80_im2:  	"Interrupt mode 2"
A80_otd:  	"Output from memory, decrement address"
A80_oti:  	"Output from memory, increment address"

// Intel 8085 undocumented instructions
// (info from http://oak.oakland.edu/pub/cpm/maclib/i8085.lib)

I5_dsub:        "(HL) <- (HL)-(BC), affects all flags"
I5_arhl:        "SHIFT HL RIGHT ONE BIT\n (H7 IS DUPLICATED\n L0 IS SHIFTED INTO CY)"
I5_rdel:        "ROTATE DE LEFT ONE BIT THRU CY\n (E0 RECEIVES CY, CY RECEIVES D7)"
I5_ldhi:        "(DE) <- (HL)+arg"
I5_ldsi:        "(DE) <- (SP)+arg"
I5_shlx:        "((DE)) <- (HL)"
I5_lhlx:        "(HL) <- ((DE))"
I5_rstv:        "RESTART 40H ON V (OVERFLOW)"
I5_jx5:         "JUMP IF X5 SET"
I5_jnx5:        "JUMP IF NOT X5 SET"

// Z380 instructions

Z80_cplw:       "Complement HL register"
Z80_swap:       "Swap upper register word with lower register word"
Z80_inw:        "Input word"
Z80_outw:       "Output word"
Z80_ldw:        "Load word"
Z80_addw:       "Add word"
Z80_subw:       "Subtract word"
Z80_adcw:       "Add with carry word"
Z80_sbcw:       "Subtract with borrow word"
Z80_andw:       "AND logical word"
Z80_xorw:       "XOR logical word"
Z80_orw:        "OR logical word"
Z80_cpw:        "Compare word"
Z80_ddir:       "Decoder directive"
Z80_calr:       "Call relative"
Z80_ldctl:      "Load control register"
Z80_mtest:      "Mode test"
Z80_exxx:       "Exchange Index Register with Alternate Bank"
Z80_exxy:       "Exchange Index Register with Alternate Bank"
Z80_exall:      "Exchange all registers with Alternate Bank"
Z80_setc:       "Set control bit"
Z80_resc:       "Reset control bit"
Z80_rlcw:       "Rotate Left Circular Word"
Z80_rrcw:       "Rotate Right Circular Word"
Z80_rlw:        "Rotate Left Word"
Z80_rrw:        "Rotate Right Word"
Z80_slaw:       "Shift Left Arithmetic Word"
Z80_sraw:       "Shift Right Arithmetic Word"
Z80_srlw:       "Shift Right Logical Word"
Z80_multw:      "Multiply Word"
Z80_multuw:     "Multiply Word Unsigned"
Z80_divuw:      "Divide unsigned"
Z80_outaw:      "Output word direct to port address"
Z80_inaw:       "Input word direct from port address"
Z80_outa:       "Output byte direct to port address"
Z80_ina:        "Input byte direct from port address"
Z80_negw:       "Negate word"
Z80_exts:       "Extend byte sign"
Z80_extsw:      "Extend word sign"
Z80_btest:      "Bank test"
Z80_ldiw:       "Load and increment (word)"
Z80_ldirw:      "Load and increment, repeat (word)"
Z80_lddw:       "Load and decrement (word)"
Z80_lddrw:      "Load and decrement, repeat (word)"
Z80_iniw:       "Input and increment (word)"
Z80_inirw:      "Input and increment, repeat (word)"
Z80_indw:       "Input and decrement (word)"
Z80_indrw:      "Input and decrement, repeat (word)"
Z80_outiw:      "Output and increment (word)"
Z80_otirw:      "Output and increment, repeat (word)"
Z80_outdw:      "Output and decrement (word)"
Z80_otdrw:      "Output and decrement, repeat (word)"
