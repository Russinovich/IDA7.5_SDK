MC12_aba:      "Add B to A"
MC12_abx:      "Add B to X"
MC12_aby:      "Add B to Y"
MC12_adca:     "Add with carry to A"
MC12_adcb:     "Add with carry to B"
MC12_adda:     "Add memory to A"
MC12_addb:     "Add memory to B"
MC12_addd:     "Add to D"
MC12_anda:     "AND A with memory"
MC12_andb:     "AND B with memory"
MC12_andcc:    "Logical AND CCR with memory"
MC12_asl:      "Arithmetic shift left memory"
MC12_asla:     "Arithmetic shift left A"
MC12_aslb:     "Arithmetic shift left B"
MC12_asld:     "Arithmetic shift left D"
MC12_asr:      "Arithmetic shift right memory"
MC12_asra:     "Arithmetic shift right A"
MC12_asrb:     "Arithmetic shift right B"
MC12_bcc:      "Branch if carry clear"
MC12_bclr:     "Clear bits in memory"
MC12_bcs:      "Branch if carry set"
MC12_beq:      "Branch if equal"
MC12_bge:      "Branch if greater than or equal"
MC12_bgnd:     "Enter background debug mode"
MC12_bgt:      "Branch if greater than"
MC12_bhi:      "Branch if higher"
MC12_bhs:      "Branch if higher or same"
MC12_bita:     "Bit test A"
MC12_bitb:     "Bit test B"
MC12_ble:      "Branch if less than or equal"
MC12_blo:      "Branch if lower"
MC12_bls:      "Branch if lower or same"
MC12_blt:      "Branch if less than"
MC12_bmi:      "Branch if minus"
MC12_bne:      "Branch if not equal"
MC12_bpl:      "Branch if plus"
MC12_bra:      "Branch always"
MC12_brclr:    "Branch if selected bits clear"
MC12_brn:      "Branch never"
MC12_brset:    "Branch if selected bits set"
MC12_bset:     "Set bits in memory"
MC12_bsr:      "Branch to subroutine"
MC12_bvc:      "Branch if overflow clear"
MC12_bvs:      "Branch if overflow set"
MC12_call:     "Call subroutine in expanded memory"
MC12_cba:      "Compare A to B"
MC12_clc:      "Clear C bit"
MC12_cli:      "Clear I bit"
MC12_clr:      "Clear memory"
MC12_clra:     "Clear A"
MC12_clrb:     "Clear B"
MC12_clv:      "Clear V bit"
MC12_cmpa:     "Compare A to memory"
MC12_cmpb:     "Compare B to memory"
MC12_com:      "One's complement memory"
MC12_coma:     "One's complement A"
MC12_comb:     "One's complement B"
MC12_cpd:      "Compare D to memory (16-bit)"
MC12_cps:      "Compare SP to memory (16-bit)"
MC12_cpx:      "Compare X to memory (16-bit)"
MC12_cpy:      "Compare Y to memory (16-bit)"
MC12_daa:      "Decimal adjust A"
MC12_dbeq:     "Decrement counter and branch if = 0"
MC12_dbne:     "Decrement counter and branch if != 0"
MC12_dec:      "Decrement memory"
MC12_deca:     "Decrement A"
MC12_decb:     "Decrement B"
MC12_des:      "Decrement SP"
MC12_dex:      "Decrement X"
MC12_dey:      "Decrement Y"
MC12_ediv:     "32 by 16 divide (unsigned) Quotient->Y Remainder->D"
MC12_edivs:    "32 by 16 divide (signed)  Quotient->Y Remainder->D"
MC12_emacs:    "Multiply and accumulate (signed)"
MC12_emaxd:    "MAX of two unsigned 16-bit values result to accumulator"
MC12_emaxm:    "MAX of two unsigned 16-bit values result to memory"
MC12_emind:    "MIN of two unsigned 16-bit values result to accumulator"
MC12_eminm:    "MIN of two unsigned 16-bit values result to memory"
MC12_emul:     "16 by 16 multiply (unsigned)"
MC12_emuls:    "16 by 16 multiply (signed)"
MC12_eora:     "Exclusive OR A with memory"
MC12_eorb:     "Exclusive OR B with memory"
MC12_etbl:     "16-bit table lookup and interpolate"
MC12_exg:      "Exchange register to register"
MC12_fdiv:     "16 by 16 fractional divide Remainder->D"
MC12_ibeq:     "Increment counter and branch if = 0"
MC12_ibne:     "Increment counter and branch if != 0"
MC12_idiv:     "16 by 16 integer divide (unsigned) Remainder->D"
MC12_idivs:    "16 by 16 integer divide (signed) Remainder->D"
MC12_inc:      "Increment memory"
MC12_inca:     "Increment A"
MC12_incb:     "Increment B"
MC12_ins:      "Increment SP"
MC12_inx:      "Increment X"
MC12_iny:      "Increment Y"
MC12_jmp:      "Jump Address"
MC12_jsr:      "Jump to subroutine"
MC12_lbcc:     "Long branch if carry clear"
MC12_lbcs:     "Long branch if carry set"
MC12_lbeq:     "Long branch if equal"
MC12_lbge:     "Long branch if greater than or equal"
MC12_lbgt:     "Long branch if greater than"
MC12_lbhi:     "Long branch if higher"
MC12_lbhs:     "Long branch if higher or same"
MC12_lble:     "Long branch if less than or equal"
MC12_lblo:     "Long branch if lower"
MC12_lbls:     "Long branch if lower or same"
MC12_lblt:     "Long branch if less than"
MC12_lbmi:     "Long branch if minus"
MC12_lbne:     "Long branch if not equal"
MC12_lbpl:     "Long branch if plus"
MC12_lbra:     "Long branch always"
MC12_lbrn:     "Long branch never"
MC12_lbvc:     "Long branch if overflow clear"
MC12_lbvs:     "Long branch if overflow set"
MC12_ldaa:     "Load A"
MC12_ldab:     "Load B"
MC12_ldd:      "Load D"
MC12_lds:      "Load SP"
MC12_ldx:      "Load X"
MC12_ldy:      "Load Y"
MC12_leas:     "Load effective address into SP"
MC12_leax:     "Load effective address into X"
MC12_leay:     "Load effective address into Y"
MC12_lsl:      "Logic shift left memory"
MC12_lsla:     "Logic shift left A"
MC12_lslb:     "Logic shift left B"
MC12_lsld:     "Logic shift left D"
MC12_lsr:      "Logic shift right memory"
MC12_lsra:     "Logic shift right A"
MC12_lsrb:     "Logic shift right B"
MC12_lsrd:     "Logic shift right D"
MC12_maxa:     "MAX of two unsigned 8-bit values result to accumulator"
MC12_maxm:     "MAX of two unsigned 8-bit values result to memory"
MC12_mem:      "Membership function"
MC12_mina:     "MIN of two unsigned 8-bit values result to accumulator"
MC12_minm:     "MIN of two unsigned 8-bit values result to memory"
MC12_movb:     "Move byte (8-bit)"
MC12_movw:     "Move word (16-bit)"
MC12_mul:      "8 by 8 multiply (unsigned)"
MC12_neg:      "Two's complement memory"
MC12_nega:     "Two's complement A"
MC12_negb:     "Two's complement B"
MC12_nop:      "Null operation"
MC12_oraa:     "OR A with memory"
MC12_orab:     "OR B with memory"
MC12_orcc:     "Logical OR CCR with memory"
MC12_psha:     "Push A"
MC12_pshb:     "Push B"
MC12_pshc:     "Push CCR"
MC12_pshd:     "Push D"
MC12_pshx:     "Push X"
MC12_pshy:     "Push Y"
MC12_pula:     "Pull A"
MC12_pulb:     "Pull B"
MC12_pulc:     "Pull CCR"
MC12_puld:     "Pull D"
MC12_pulx:     "Pull X"
MC12_puly:     "Pull Y"
MC12_rev:      "MIN-MAX rule evaluation"
MC12_revw:     "MIN-MAX rule evaluation"
MC12_rol:      "Rotate left memory through carry"
MC12_rola:     "Rotate left A through carry"
MC12_rolb:     "Rotate left B through carry"
MC12_ror:      "Rotate right memory through carry"
MC12_rora:     "Rotate right A through carry"
MC12_rorb:     "Rotate right B through carry"
MC12_rtc:      "Return from call"
MC12_rti:      "Return from interrupt"
MC12_rts:      "Return from subroutine"
MC12_sba:      "Subtract B from A"
MC12_sbca:     "Subtract with borrow from A"
MC12_sbcb:     "Subtract with borrow from B"
MC12_sec:      "Set C bit"
MC12_sei:      "Set I bit"
MC12_sev:      "Set V bit"
MC12_sex:      "Sign extend 8-Bit operand"
MC12_staa:     "Store A"
MC12_stab:     "Store B"
MC12_std:      "Store D"
MC12_stop:     "Stop"
MC12_sts:      "Store SP"
MC12_stx:      "Store X"
MC12_sty:      "Store Y"
MC12_suba:     "Subtract memory from A"
MC12_subb:     "Subtract memory from B"
MC12_subd:     "Subtract memory from D"
MC12_swi:      "Software interrupt"
MC12_tab:      "Transfer A to B"
MC12_tap:      "Transfer A to CCR"
MC12_tba:      "Transfer B to A"
MC12_tbeq:     "Test counter and branch if = 0"
MC12_tbl:      "8-bit table lookup and interpolate"
MC12_tbne:     "Test counter and branch if != 0"
MC12_tfr:      "Transfer register to register"
MC12_tpa:      "Transfer CCR to A"
MC12_trap:     "Unimplemented opcode interrupt"
MC12_tst:      "Test memory for zero or minus"
MC12_tsta:     "Test A for zero or minus"
MC12_tstb:     "Test B for zero or minus"
MC12_tsx:      "Transfer SP to X"
MC12_tsy:      "Transfer SP to Y"
MC12_txs:      "Transfer X to SP"
MC12_tys:      "Transfer Y to SP"
MC12_wai:      "Wait for interrupt"
MC12_wav:      "Calculates numerator and denominator for weighted average calculation"
MC12_wavr:     "Resumes execution of interrupted WAV instruction"
MC12_xgdx:     "Exchange D with X"
MC12_xgdy:     "Exchange D with Y"

// Pseudoinstructions
MC12_skip1:    "Skip the following byte in the code"
MC12_skip2:    "Skip the following two bytes in the code"
