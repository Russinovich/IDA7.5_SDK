M16C_abs:         "Absolute value"
M16C_adc:         "Add with carry"
M16C_adcf:        "Add carry flag"
M16C_add:         "Add without carry"
M16C_adjnz:       "Add & conditional jump"
M16C_and:         "Logically AND"
M16C_band:        "Logically AND bits"
M16C_bclr:        "Clear bit"
M16C_bmcnd:       "Conditional bit transfer"
M16C_bmgeu:       "Conditional bit transfer: Equal to or greater than; C == 1"
M16C_bmgtu:       "Conditional bit transfer: Greater than"
M16C_bmeq:        "Conditional bit transfer: Equal to; Z == 1"
M16C_bmn:         "Conditional bit transfer: Negative"
M16C_bmle:        "Conditional bit transfer: Equal to or smaller than (signed)"
M16C_bmo:         "Conditional bit transfer: Overflow; O == 1"
M16C_bmge:        "Conditional bit transfer: Equal to or greater than (signed)"
M16C_bmltu:       "Conditional bit transfer: Smaller than; C == 0"
M16C_bmleu:       "Conditional bit transfer: Equal to or smaller than"
M16C_bmne:        "Conditional bit transfer: Not equal; Z == 0"
M16C_bmpz:        "Conditional bit transfer: Positive or zero"
M16C_bmgt:        "Conditional bit transfer: Greater than (signed)"
M16C_bmno:        "Conditional bit transfer: No overflow; O == 0"
M16C_bmlt:        "Conditional bit transfer: Smaller than (signed)"
M16C_bnand:       "Logically AND inverted bits"
M16C_bnor:        "Logically OR inverted bits"
M16C_bnot:        "Invert bit"
M16C_bntst:       "Test inverted bit"
M16C_bnxor:       "Exclusive OR inverted bits"
M16C_bor:         "Logically OR bits"
M16C_brk:         "Debug interrupt"
M16C_bset:        "Set bit"
M16C_btst:        "Test bit"
M16C_btstc:       "Test bit & clear"
M16C_btsts:       "Test bit & set"
M16C_bxor:        "Exclusive OR bits"
M16C_cmp:         "Compare"
M16C_dadc:        "Decimal add with carry"
M16C_dadd:        "Decimal add without carry"
M16C_dec:         "Decrement"
M16C_div:         "Signed divide"
M16C_divu:        "Unsigned divide"
M16C_divx:        "Signed divide (extension)"
M16C_dsbb:        "Decimal subtract with borrow"
M16C_dsub:        "Decimal subtract without borrow"
M16C_enter:       "Build stack frame"
M16C_exitd:       "Deallocate stack frame"
M16C_exts:        "Extend sign"
M16C_fclr:        "Clear flag register bit"
M16C_fset:        "Set flag register bit"
M16C_inc:         "Increment"
M16C_int:         "Interrupt by INT instruction"
M16C_into:        "Interrupt on overflow"
M16C_jcnd:        "Jump on condition"
M16C_jgeu:        "Conditional jump: Equal to or greater than; C == 1"
M16C_jgtu:        "Conditional jump: Greater than"
M16C_jeq:         "Conditional jump: Equal to; Z == 1"
M16C_jn:          "Conditional jump: Negative"
M16C_jle:         "Conditional jump: Equal to or smaller than (signed)"
M16C_jo:          "Conditional jump: Overflow; O == 1"
M16C_jge:         "Conditional jump: Equal to or greater than (signed)"
M16C_jltu:        "Conditional jump: Smaller than; C == 0"
M16C_jleu:        "Conditional jump: Equal to or smaller than"
M16C_jne:         "Conditional jump: Not equal; Z == 0"
M16C_jpz:         "Conditional jump: Positive or zero"
M16C_jgt:         "Conditional jump: Greater than (signed)"
M16C_jno:         "Conditional jump: No overflow; O == 0"
M16C_jlt:         "Conditional jump: Smaller than (signed)"
M16C_jmp:         "Unconditional jump"
M16C_jmpi:        "Jump indirect"
M16C_jmps:        "Jump to special page"
M16C_jsr:         "Subroutine call"
M16C_jsri:        "Indirect subroutine call"
M16C_jsrs:        "Special page subroutine call"
M16C_ldc:         "Transfer to control register"
M16C_ldctx:       "Restore context"
M16C_lde:         "Transfer from extended data area"
M16C_ldintb:      "Load to INTB register"
M16C_ldipl:       "Set interrupt enable level"
M16C_mov:         "Transfer"
M16C_mova:        "Transfer effective address"
M16C_movhh:       "Xfer 4-bit data: src(8-bits)'s 4 hi bits -> dest(8-bits)'s 4 hi bits."
M16C_movhl:       "Xfer 4-bit data: src(8-bits)'s 4 hi bits -> dest(8-bits)'s 4 lo bits."
M16C_movlh:       "Xfer 4-bit data: src(8-bits)'s 4 lo bits -> dest(8-bits)'s 4 hi bits."
M16C_movll:       "Xfer 4-bit data: src(8-bits)'s 4 lo bits -> dest(8-bits)'s 4 lo bits."
M16C_mul:         "Signed multiply"
M16C_mulu:        "Unsigned multiply"
M16C_neg:         "Two's complement"
M16C_nop:         "No operation"
M16C_not:         "Invert all bits"
M16C_or:          "Logically OR"
M16C_pop:         "Restore register/memory"
M16C_popc:        "Restore control register"
M16C_popm:        "Restore multiple registers"
M16C_push:        "Save register/memory/immediate data"
M16C_pusha:       "Save effective address"
M16C_pushc:       "Save control register"
M16C_pushm:       "Save multiple registers"
M16C_reit:        "Return from interrupt"
M16C_rmpa:        "Calculate sum-of-products"
M16C_rolc:        "Rotate left with carry"
M16C_rorc:        "Rotate right with carry"
M16C_rot:         "Rotate"
M16C_rts:         "Return from subroutine"
M16C_sbb:         "Subtract with borrow"
M16C_sbjnz:       "Subtract & conditional jump"
M16C_sha:         "Shift arithmetic"
M16C_shl:         "Shift logical"
M16C_smovb:       "Transfer string backward"
M16C_smovf:       "Transfer string forward"
M16C_sstr:        "Store string"
M16C_stc:         "Transfer from control register"
M16C_stctx:       "Save context"
M16C_ste:         "Store to extended data area"
M16C_stnz:        "Conditional transfer: store on not zero"
M16C_stz:         "Conditional transfer: store on zero"
M16C_stzx:        "Conditional transfer: store on zero extension"
M16C_sub:         "Subtract without borrow"
M16C_tst:         "Test"
M16C_und:         "Interrupt for undefined instruction"
M16C_wait:        "Wait"
M16C_xchg:        "Exchange"
M16C_xor:         "Exclusive OR"
M16C_addx:        "Add extend sign without carry"
M16C_bitindex:    "Bit index (affects next instruction)"
M16C_brk2:        "Debug interrupt 2"
M16C_clip:        "Clip to interval"
M16C_cmpx:        "Compare extend sign"
M16C_extz:        "Zero extend"
M16C_freit:       "Fast return from interrupt"
M16C_indexb:      "Index both src and dest of next instruction, in bytes"
M16C_indexbd:     "Index destination of next instruction, in bytes"
M16C_indexbs:     "Index source of next instruction, in bytes"
M16C_indexl:      "Index both src and dest of next instruction, in dwords (x4)"
M16C_indexld:     "Index destination of next instruction, in dwords (x4)"
M16C_indexls:     "Index source of next instruction, in dwords (x4)"
M16C_indexw:      "Index both src and dest of next instruction, in words (x2)"
M16C_indexwd:     "Index destination of next instruction, in words (x2)"
M16C_indexws:     "Index source of next instruction, in words (x2)"
M16C_max:         "Store maximum value"
M16C_min:         "Store minimum value"
M16C_movx:        "Transfer extend sign"
M16C_mulex:       "Multiply extend sign"
M16C_sccnd:       "Store 0/1 on condition"
M16C_scgeu:       "Store 0/1 on condition: Equal to or greater than; C == 1"
M16C_scgtu:       "Store 0/1 on condition: Greater than"
M16C_sceq:        "Store 0/1 on condition: Equal to; Z == 1"
M16C_scn:         "Store 0/1 on condition: Negative"
M16C_scle:        "Store 0/1 on condition: Equal to or smaller than (signed)"
M16C_sco:         "Store 0/1 on condition: Overflow; O == 1"
M16C_scge:        "Store 0/1 on condition: Equal to or greater than (signed)"
M16C_scltu:       "Store 0/1 on condition: Smaller than; C == 0"
M16C_scleu:       "Store 0/1 on condition: Equal to or smaller than"
M16C_scne:        "Store 0/1 on condition: Not equal; Z == 0"
M16C_scpz:        "Store 0/1 on condition: Positive or zero"
M16C_scgt:        "Store 0/1 on condition: Greater than (signed)"
M16C_scno:        "Store 0/1 on condition: No overflow; O == 0"
M16C_sclt:        "Store 0/1 on condition: Smaller than (signed)"
M16C_scmpu:       "String compare unequal (until zero)"
M16C_sin:         "String input"
M16C_smovu:       "String move unequal (until zero)"
M16C_sout:        "String output"
M16C_subx:        "Subtract extend without borrow"
M16C_shanc:       "Shift arithmetic no carry"
M16C_shlnc:       "Shift logical no carry"
