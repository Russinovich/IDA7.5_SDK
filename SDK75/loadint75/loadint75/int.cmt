
//                      Interrupt Summary and Command comments

op1 ?

0x00: "- internal hardware - DIVIDE ERROR\nAutomatically called at end of DIV or IDIV operation that results in error\nor overflow.   Normally set by DOS to display an error message and abort\nthe program."
0x01: "- internal hardware - SINGLE-STEP\ngenerated at end of each machine instruction if TF bit in FLAGS is set"
0x02: "- external hardware - NMI (NON-MASKABLE INTERRUPT)\nGenerated by NMI signal in hardware."
0x03: "- software interrupt to invoke the debugger"
0x04: "- internal hardware - OVERFLOW\nGenerated by INTO instruction if OF flag is set.\nNot intended to be called by programmer."
0x05: " - PRINT-SCREEN KEY\nautomatically called by keyboard scanner when print-screen key is pressed"
0x06: " - internal hardware - UNDEFINED OPCODE (80286+)"
0x07: " - internal hardware - NO MATH UNIT AVAILABLE (80286+)\nautomatically called if a coprocessor instruction is encountered when no\ncoprocessor is installed"
0x08: " - IRQ0 - TIMER INTERRUPT\nGenerated 18.2 times per second, this interrupt is used to keep the\ntime-of-day clock updated."
0x09: " - IRQ1 - KEYBOARD INTERRUPT\nGenerated when data is received from the keyboard."
0x0A: " - IRQ2 - EGA VERTICAL RETRACE"
0x0B: " - IRQ3 - COM2 INTERRUPT"
0x0C: " - IRQ4 - COM1 INTERRUPT"
0x0D: " - IRQ5 - FIXED DISK (PC), LPT2 (AT/PS)"
0x0E: " - IRQ6 - DISKETTE INTERRUPT"
0x0F: " - IRQ7 - PRINTER INTERRUPT"

0x10: "- VIDEO - " { ah ?
      0x00: "SET VIDEO MODE\nAL = mode"
      0x01: "SET CURSOR CHARACTERISTICS\nCH bits 0-4 = start line for cursor in character cell\nbits 5-6 = blink attribute\nCL bits 0-4 = end line for cursor in character cell"
      0x02: "SET CURSOR POSITION\nDH,DL = row, column (0,0 = upper left)\nBH = page number "
      0x03: "READ CURSOR POSITION\nBH = page number\nReturn: DH,DL = row,column, CH = cursor start line, CL = cursor end line"
      0x04: "READ LIGHT PEN POSITION (all but PS)\nReturn: AH = 00h light pen switch not activated\nAH = 01h light pen values in registers\nDH,DL = row,columnCH = raster line (0-199) (EGA) old graphics modes\nCX = (EGA) raster line \nBX = pixel column"
      0x05: "SELECT DISPLAY PAGE\nAL = display page, 0-7  for modes 0 & 1, 0-3  for modes 2 & 3"
      0x06: "SCROLL PAGE UP\nAL = number of lines to scroll window (0 = blank whole window)\nBH = attributes to be used on blanked lines\nCH,CL = row,column of upper left corner of window to scroll\nDH,DL = row,column of lower right corner of window"
      0x07: "SCROLL PAGE DOWN\nAL = number of lines to scroll window (0 = blank whole window)\nBH = attributes to be used on blanked lines\nCH,CL = row,column of upper left corner of window to scroll\nDH,DL = row,column of lower right corner of window"
      0x08: "READ ATTRIBUTES/CHARACTER AT CURSOR POSITION\nBH = display page\nReturn: AL = character\nAH = attribute of character (alpha modes)"
      0x09: "WRITE ATTRIBUTES/CHARACTERS AT CURSOR POSITION\nAL = character, BH = display page\nBL = attributes of character (alpha modes) or color (graphics modes)\nCX = number of times to write character"
      0x0A: "WRITE CHARACTERS ONLY AT CURSOR POSITION\nAL = character, BH = display page - alpha mode\nBL = color of character (graphics mode, PCjr only)\nCX = number of times to write character"
      0x0B: "SET COLOR PALETTE\nBH = 00h, BL = border color\nBH = 01h, BL = palette (0-3)"
      0x0C: "WRITE DOT ON SCREEN\nAL = color of dot, BH = display page\nCX = column, DX = row"
      0x0D: "READ DOT ON SCREEN\nBH = display page, CX = column, DX = row"
      0x0E: "WRITE CHARACTER AND ADVANCE CURSOR (TTY WRITE)\nAL = character, BH = display page (alpha modes)\nBL = foreground color (graphics modes)"
      0x0F: "GET CURRENT VIDEO MODE\nReturn: AH = number of columns on screen\nAL = current video mode\nBH = current active display page"

      0x10: { al ?
            0x00: "SET PALETTE REGISTER (Jr, PS, TANDY 1000, EGA, VGA)\nBL = palette register to set\nBH = color value to store"
            0x01: "SET BORDER COLOR REGISTER (Jr, PS, TANDY 1000, EGA, VGA)\nBH = color value to store"
            0x02: "SET ALL PALETTE REGISTERS (Jr, PS, TANDY 1000, EGA, VGA)\nES:DX -> 17-byte palette register list"
            0x03: "TOGGLE INTENSITY/BLINKING BIT (Jr, PS, TANDY 1000, EGA, VGA)\nBL = 00h enable background intensity\n= 01h enable blink"
            0x07: "GET INDIVIDUAL PALETTE REGISTER (VGA)\nBL = palette register number\nReturn: BH = palette register value"
            0x08: "READ OVERSCAN (BORDER COLOR) REGISTER (VGA)\nReturn: BH = value"
            0x09: "READ ALL PALETTE REGISTERS AND OVERSCAN REGISTER (VGA)\nES:DX -> 17-byte buffer"
            0x10: "SET INDIVIDUAL DAC REGISTER (EGA, VGA/MCGA)\nBX = register number, CH = new value for green (0-63)\nCL = new value for blue (0-63), DH = new value for red (0-63)"
            0x12: "SET BLOCK OF DAC REGISTERS (EGA, VGA/MCGA)\nBX = starting color register, CX = number of registers to set\nES:DX -> table of 3*CX bytes where each 3 byte group represents one\nbyte each of red, green and blue (0-63)"
            0x13: "SELECT VIDEO DAC COLOR PAGE (VGA)\n\nBL = 00h Select paging mode\nBL = 01h Select Page"
            0x15: "READ INDIVIDUAL DAC REGISTER (EGA, VGA/MCGA)\nBL = palette register number\nReturn: DH = red value, CH = green value, CL = blue value"
            0x17: "READ BLOCK OF DAC REGISTERS (EGA, VGA/MCGA)\nBX = starting palette register, CX = number of palette registers to read\nES:DX -> buffer (3 * CX bytes in size)\nReturn: CX number of red, green and blue triples in buffer"
            0x18: "undocumented - SET PEL MASK (EGA, VGA/MCGA)\nBL = new PEL value"
            0x19: "undocumented - READ PEL MASK (EGA, VGA/MCGA)\nReturn:        BL = value read"
            0x1A: "GET VIDEO DAC COLOR-PAGE STATE (VGA)\nReturn: BL = paging mode, BH = current page"
            0x1B: "PERFORM GRAY-SCALE SUMMING (EGA, VGA/MCGA)\nBX = starting palette register\nCX = number of registers to convert"
      }
      0x11: "TEXT-MODE CHARACTER GENERATOR FUNCTIONS (PS, EGA, VGA)\nAL = 00h, 10h: load user-specified patterns\nAL = 01h, 11h: load ROM monochrome patterns (8 by 14)\nAL = 02h, 12h: load ROM 8 by 8 double-dot patterns\nAL = 03h: set block specifier"
      0x12: "ALTERNATE FUNCTION SELECT " { bl ?
            0x10: "(PS, EGA, VGA, MCGA) - GET EGA INFO\nReturn: BH = 00h color mode in effect CH = feature bits, CL = switch settings"
            0x20: "(PS,EGA,VGA,MCGA) - ALTERNATE PRTSC\nselect alternate print screen routine"
            0x30: "(VGA) - SELECT VERTICAL RESOLUTION\nAL = vertical resolution: " { al ?
                      0x00: "200 scan lines"
                      0x01: "350 scan lines"
                      0x02: "400 scan lines"
            }
            0x31: "(VGA, MCGA) - PALETTE LOADING: " { al ?
                  0x00: "enable default palette loading"
                  0x01: "disable default palette loading"
            }
            0x32: "(VGA, MCGA) - VIDEO ADDRESSING: " { al ?
                  0x00: "enable video addressing"
                  0x01: "disable video addressing"
            }
            0x33: "(VGA, MCGA) - GRAY-SCALE SUMMING: " { al ?
                  0x00: "enable gray scale summing"
                  0x01: "disable gray scale summing"
            }
            0x34: "(VGA) - CURSOR EMULATION: " { al ?
                  0x00: "enable alphanumeric cursor emulation"
                  0x01: "disable alphanumeric cursor emulation"
            }
            0x35: "(PS) - DISPLAY-SWITCH INTERFACE\nES:DX -> buffer (128 byte save area if AL = 0, 2 or 3): " { al ?
                  0x00: "initial adapter video off"
                  0x01: "initial planar video on"
                  0x02: "switch active video off"
                  0x03: "switch inactive video on"
                  0x80: "*UNDOCUMENTED* set system board video active flag"
            }
            0x36: "(PS, VGA) - VIDEO REFRESH CONTROL: " { al ?
                  0x00: "enable refresh"
                  0x01: "disable refresh"
            }
      }
      0x13: "WRITE STRING (AT,XT286,PS,EGA,VGA)\nAL = mode, BL = attribute if AL bit 1 clear, BH = display page number\nDH,DL = row,column of starting cursor position, CX = length of string\nES:BP -> start of string"
      0x14: { al ?
            0x00: "LOAD USER-SPECIFIED LCD CHARACTER FONT (CONV,CP386)\nES:DI -> character font, BH = number of bytes per character\nBL = 00h load main font (block 0), CX = number of characters to store\nDX = character offset into RAM font area"
            0x01: "LOAD SYSTEM ROM DEFAULT LCD CHARACTER FONT (CONV,CP386)\nBL = " { bl ?
                    0x00: "load main font (block 0)"
                    0x01: "load alternate font (block 1)"
                  }
            0x02: "SET MAPPING OF LCD HIGH INTENSITY ATTRIBUTES (CONV,CP386)\nBL = " { bl ?
                    0x00: "ignore high intensity attribute"
                    0x01: "map high intensity to underscore"
                    0x02: "map high intensity to reverse video"
                    0x03: "map high intensity to selected alternate font"
                    0xB0: "half intensity (Compaq)"
                    0xB1: "toggle active intensity bit interpretation (CP386)"
                  }
      }
      0x15: "GETPHYSICAL DISPLAY PARAMETERS (CONVERTIBLE)\nReturn: AX = alternate display adapter type\n0000h none, 5140h LCD, 5153h CGA, 5151h mono\nES:DI -> parameter table"
      0x1A: "DISPLAY COMBINATION (PS,VGA/MCGA): " { al ?
            0x00: "read display combination code"
            0x01: "set display combination code"
      }

      0x1B: "FUNCTIONALITY/STATE INFORMATION (PS,VGA/MCGA)\nBX = implementation type\n= 0000h return funtionality/state information\nES:DI -> 64 byte buffer for state information\nReturn: AL = 1Bh if function supported, ES:DI buffer filled with"
      0x1C: "SAVE/RESTORE VIDEO STATE (PS50+,VGA) \n" { al ?
             0x00: "return state buffer size, return: BX = number of 64 byte blocks needed"
             0x01: "save video state, ES:BX -> buffer"
             0x02: "restore video state, ES:BX -> buffer containing previously saved state"
      }
      0x30: "LOCATE 3270PC CONFIGURATION TABLE\nReturn: CX:DX -> 3270PC configuration table\n        CX:DX = 0000h:0000h if 3270PC Control Program not active"
      0x40: "SET GRAPHICS MODE (Hercules GRAFIX)"
      0x41: "SET TEXT MODE (Hercules GRAFIX)"
      0x42: "CLEAR CURRENT PAGE (Hercules GRAFIX)"
      0x43: "SELECT DRAWING PAGE (Hercules GRAFIX)"
      0x44: "SELECT DRAWING FUNCTION (Hercules GRAFIX): \n" { al ?
            0x00: "clear pixels"
            0x01: "set pixels"
            0x02: "invert pixels"
      }
      0x45: "SELECT PAGE TO DISPLAY (Hercules GRAFIX)\nAL = page number (0,1)"
      0x46: "DRAW ONE PIXEL (Hercules GRAFIX)\nDI = x (0-720), BP = y (0-347)"
      0x47: "FIND PIXEL VALUE (Hercules GRAFIX)\nDI = x (0-720), BP = y (0-347)\nDI = x (0-720), BP = y (0-347)\nReturn: AL = 00h pixel clear, AL = 01h pixel set"
      0x48: "MOVE TO POINT (Hercules GRAFIX)\nDI = x (0-720), BP = y (0-347)\nDI = x (0-720), BP = y (0-347)"
      0x49: "DRAW TO POINT (Hercules GRAFIX)\nDI = x (0-720), BP = y (0-347)\nDI = x (0-720), BP = y (0-347)"
      0x4A: "BLOCK FILL (Hercules GRAFIX)\nDI/BP = x/y coordinate of lower left corner\nDI = x coordinate of lower left corner, BP = y coordinate of lower left corner\nBX = height in pixels, CX = width in pixels"
      0x4B: "DISPLAY CHARACTER (Hercules GRAFIX)\nAL = character to display, DI = x (0-720), BP = y (0-347)\nAL = character to display, DI = x (0-720), BP = y (0-347)"
      0x4C: "DRAW ARC (Hercules GRAFIX)\nDI = x of center, BP = y of center, BX = radius\nAL = quadrant (1 = upper right, 2 = upper left, etc)\nDI = x coordinate of center, BP = y coordinate of center, BX = radius"
      0x4D: "DRAW CIRCLE (Hercules GRAFIX)\nDI = x of center, BP = y of center, BX = radius"
      0x4E: "VIDEO - FILL AREA (Hercules GRAFIX)\n\nDI = x coordinate of an interior point\nBP = y coordinate of an interior point"
      0x4F: "VESA SuperVGA BIOS -  "{ al ?
            0x00: "GET SuperVGA INFORMATION\nES:DI -> 256-byte buffer for SuperVGA information\nES:DI -> 256-byte buffer for SuperVGA information\nReturn: AL = 4Fh function supported\nAH = 00h successful, 01h failed"
            0x01: "GET SuperVGA MODE INFORMATION\nCX = SuperVGA video mode, ES:DI -> 256-byte buffer mode information\nCX = SuperVGA video mode\nES:DI -> 256-byte buffer mode information"
            0x02: "SET SuperVGA VIDEO MODE\nBX = mode, bit 15 set means don't clear video memory\nBX = bit 15 set means don't clear video memory\nReturn: AL = 4Fh function supported\nAH = 00h successful, 01h failed"
            0x03: "GET CURRENT VIDEO MODE\nReturn: AL = 4Fh function supported\nAH = 00h successful, 01h failed\nBX = video mode"
            0x04: "SAVE/RESTORE SuperVGA VIDEO STATE\nDL = " { dl ?
                  0x00: "get state buffer size"
                  0x01: "save video states, ES:BX -> buffer"
                  0x02: "restore video states, ES:BX -> buffer"
            }
            0x05: "VESA SuperVGA BIOS - CPU VIDEO MEMORY CONTROL\nBL = 00h window A, 01h window B\nReturn: AL = 4Fh function supported\nAH = 00h successful, 01h failed\nBH = subfunction" { bh ?
                        0x00: "select video memory window"
                        0x01: "get video memory window"
            }
            0x06: "VESA SuperVGA BIOS 1.1 - GET/SET LOGICAL SCAN LINE LENGTH\nBL = " { bl ?
                      0x00: "00h - set scan line length, CX = desired width in pixels"
                      0x01: "01h - get scan line length"
            }
            0x07: "VESA SuperVGA BIOS 1.1 - GET/SET DISPLAY START\nBL = " { bl ?
                  0x00: "00h - set display start"
                  0x01: "01h - get display start"
            }
      }
      0x50: "SCROLOCK.COM - INSTALLATION CHECK\nReturn: BX = 1954h if installed\nAL = 00 if inactive, nonzero if active"
      0x51: "SCROLOCK.COM - ENABLE/DISABLE\nAL = 00h disable, nonzero enable"
      0x55: { al ? 0x55: "VIDEO - ATI EGA/VGA Wonder Super Switch - INSTALLATION CHECK"
      }
      0x6A: { al ?
            0x00: "Direct Graphics Interface Standard (DGIS) - INQUIRE AVAILABLE DEVICES\nCX = 0000h, DX = buffer length (may be 0), ES:DI -> buffer"
            0x01: "DGIS - REDIRECT CHARACTER OUTPUT\nCX = 0000h, ES:DI = address of device to send INT 10 output to"
            0x02: "DGIS - INQUIRE INT 10 OUTPUT DEVICE\nES:DI = 0000h:0000h"
      }
      0x6F: { al ?
            0x00: "INSTALLATION CHECK (Video7 VGA,VEGA VGA)\nReturn: BX = 5637h ('V7') indicates Video7 VGA/VEGA VGA extensions are present"
            0x01: "GETINFO (Video7 VGA,VEGA VGA)\nReturn: AL = monitor type code (VEGA VGA only)\nAH = status register information"
            0x04: "GET MODE AND SCREEN RESOLUTION (Video7 VGA, VEGA VGA)\nReturn: AL = current video mode\nBX = horizontal columns (text) or pixels (graphics)\nCX = vertical columns (text) or pixels (graphics)"
            0x05: "SET VIDEO MODE (Video7 VGA, VEGA EXTENDED EGA/VGA)\nBL = mode (graphics mode if graphics resolution listed)"
            0x06: "SELECT AUTOSWITCH MODE (V7VGA,VEGA VGA)\nBL = " { bl ?
                  0x00: "select EGA/VGA-only modes"
                  0x01: "select Autoswitched VGA/EGA/CGA/MGA modes"
                  0x02: "select 'bootup' CGA/MGA modes\nBH = 00h/01h = enable/disable"
            }
      }
      0x70: "VIDEO - GET VIDEO RAM ADDRESS (TANDY 1000)\nEverex Extended Video BIOS - " { bx ?
            0x00: "RETURN EMULATION STATUS\nReturn: CL = monitor type, CH = feature bits\nDX = video board info, DI = BCD BIOS version number"
            0x04: "GET PAGING FUNCTION POINTER FOR CURR MODE\nReturn: ES:DI -> FAR paging function (call with DL = page to set)"
            0x05: "GET SUPPORTED MODE INFO\nCL = maximum number of modes, CH = mode type\nDL = monitor type, ES:DI -> buffer for mode info\nReturn: CL = total number of modes, CH = size"
      }
      0x71: "GET INCRAM ADDRESSES (TANDY 1000)\nReturn: AX  = segment address of the following\n[BX] = segment address of INCRAM, [CX] = offset address of INCRAM"
      0x72: "SCROLL SCREEN RIGHT (TANDY 1000)\nAL = number of columns blanked at left of window, 00h = blank entire window\nBH = attributes\nCH,CL = row, column of upper left corner of window, DH,DL = row, column of lower right corner"
      0x73: "SCROLL SCREEN LEFT (TANDY 1000)\nAL = number of columns blanked at right of window, 00h = blank entire window\nBH = attributes\nCH,CL = row, column of upper left corner of window, DH,DL = row, column of lower right corner"
      0x80: "(DESQview 2.0x only) - internal - SET ??? HANDLER\nDX = 4456h ('DV'), ES:DI -> FAR subroutine to be called on ???"
      0x81: "(DESQview 2.0x only) - internal - GET ???\nDX = 4456h ('DV'),"
      0x82: "(DESQview 2.0x only) - internal - GET CURRENT WINDOW INFO\nDX = 4456h ('DV')"
      0xBF: "Compaq " { al ?
            0x00: "Portable Extensions - SELECT EXTERNAL MONITOR"
            0x01: "Portable Extensions - SELECT INTERNAL MONITOR"
            0x02: "Portable Extensions - SET MASTER MODE OF CURRENT CTRLR\nBH = master mode " { bh ?
                  0x04: "CGA"
                  0x05: "EGA"
                  0x07: "MDA"
            }
            0x03: "Portable/Systempro Extensions - GET ENVIRONMENT\nReturn: BH = active monitor, BL = master mode, CH = 00h (reserved)\nCL = switchable VDU mode supported, DH = internal monitor type, DL = external monitor type"
            0x04: "Portable Extensions - SET MODE SWITCH DELAY\nBH = 00h enable delay, 01h disable delay"
            0x05: "Systempro Extensions - ENABLE/DISABLE DISPLAY\nBH = 00h video off, 01h video on"
            0x06: "SLT/286 - READ GRAY SCALE TABLE\nCL = address to be read from gray scale table"
            0x07: "SLT/286 - WRITE GREY SCALE TABLE\nCH = value to write to gray scale table, CL = address to be written to gray scale table"
            0x08: "SLT/286 - WRITE COLOR MIX REGISTERS\nCH = bits 7-4 - Green weight, bits 3-0 - Blue weight\nCL = bits 7-4 - unused, bits 3-0 - Red weight"
      }
      0xCC: "UltraVision - " { al ?
            0x00: "INSTALLATION CHECK\nReturn: CX = ABCDh, AL = 00h if extensions enabled"
            0x01: "ENABLE EXTENSIONS"
            0x02: "DISABLE EXTENSIONS"
      }
      0xCD: { al ? 04: "UltraVision - GET VIDEO MODE\nReturn: AL = mode number"
      }
      0xCD: "UltraVision - SET VIDEO MODE\nAL = mode number (<> 04h)"
      0xEF: "VIDEO - MSHERC.COM - INSTALLATION CHECK???\nReturn: DL = video adapter type"
      0xF0: "Microsoft Mouse driver EGA support - READ ONE REGISTER\nBL = register number, BH = 00h, DX = group index"
      0xF1: "Microsoft Mouse driver EGA support - WRITE ONE REGISTER\nDX = group index"
      0xF2: "Microsoft Mouse driver EGA support - READ REGISTER RANGE\nCH = starting register number, CL = Number of registers (>1), DX = group index"
      0xF3: "Microsoft Mouse driver EGA support - WRITE REGISTER RANGE\nCH = starting register, CL = number of registers (>1), DX = group index"
      0xF4: "Microsoft Mouse driver EGA support - READ REGISTER SET\nCX = number of registers to read (>1), ES:BX -> table of records"
      0xF5: "Microsoft Mouse driver EGA support - WRITE REGISTER SET\nCX = number of registers to write (>1), ES:BX -> table of records"
      0xF6: "Microsoft Mouse driver EGA support - REVERT TO DEFAULT REGISTERS"
      0xF7: "Microsoft Mouse driver EGA support - DEFINE DEFAULT REGISTER TABLE\nDX = port number"
      0xFA: "Microsoft Mouse driver EGA support - INTERROGATE DRIVER\nReturn: BX = 0000h if mouse driver not present\nES:BX -> EGA Register Interface version number"
      0xFE: " (TopView) - GET VIDEO BUFFER\nES:DI = segment:offset of assumed video buffer\nReturn: ES:DI = segment:offset of actual video buffer"
      0xFF: " (TopView) - UPDATE REAL SCREEN FROM VIDEO BUFFER\nCX = number of sequential characters that have been modified\nDI = offset of first character that has been modified\nES = segment of video buffer"
}
0x11: "EQUIPMENT DETERMINATION\nReturn: AX = equipment flag bits"
0x12: "MEMORY SIZE - \nReturn: AX = number of contiguous 1K blocks of memory"
0x13: "DISK - "  { ah ?
      0x00: "RESET DISK SYSTEM\nDL = drive (if bit 7 is set both hard disks and floppy disks reset)"
      0x01: "STATUS OF DISK SYSTEM\nReturn: CF clear: AH=0, AL = status of last disk operation\nCF set: AH = error code"
      0x02: "READ SECTORS INTO MEMORY\nAL = number of sectors to read, CH = track, CL = sector\nDH = head, DL = drive, ES:BX -> buffer to fill\nReturn: CF set on error, AH = status, AL = number of sectors read"
      0x03: "WRITE SECTORS FROM MEMORY\nAL = number of sectors to write, CH = track, CL = sector\nDH = head, DL = drive, ES:BX -> buffer\nReturn: CF set on error, AH = status, AL = number of sectors written"
      0x04: "VERIFY SECTORS\nAL = number of sectors to verify, CH = track, CL = sector\nDH = head, DL = drive\nReturn: CF set on error, AH = status\nAL = number of sectors verified"
      0x05: "FLOPPY- FORMAT TRACK\nAL = interleave value (XT only), ES:BX = 512-byte format buffer\nCH = cylinder number, CL = sector number, DH = head, DL = drive\nReturn: AH = status code"
      0x06: "FIXED DISK - FORMAT TRACK AND SET BAD SECTOR FLAGS (XT,PORT)\nAL = interleave value, CH = cylinder number, CL = sector number\nDH = head, DL = drive\nReturn: AH = status code"
      0x07: "FIXED DISK - FORMAT DRIVE STARTING AT GIVEN TRACK (XT,PORT)\nAL = interleave value (XT only), ES:BX = 512-byte format buffer\nCH = cylinder number, CL = sector number, DH = head, DL = drive\nReturn: AH = status code"
      0x08: "DISK - GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)\nDL = drive number\nReturn: CF set on error, AH = status code, BL = drive type\nDL = number of consecutive drives\nDH = maximum value for head number, ES:DI -> drive parameter"
      0x09: "FIXED DISK - INITIALIZE TWO FIXED DISK BASE TABLES (XT,AT,XT286,PS)\nReturn: CF set on error, AH = status code"
      0x0A: "FIXED DISK - READ LONG (XT,AT,XT286,PS)\nDL = drive ID, DH = head, CH = cylinder, CL = sector, ES:BX -> buffer to fill\nReturn: CF set on error, AH = status code, AL = number of sectors read"
      0x0B: "FIXED DISK - WRITE LONG (XT,AT,XT286,PS)\nDL = drive ID, DH = head, CH = cylinder\nCL = sector ES:BX -> buffer containing data\nReturn: CF set on error, AH = status code, AL = number of sectors written"
      0x0C: "FIXED DISK - SEEK TO CYLINDER (XT,AT,XT286,PS)\nDL = drive ID, DH = head, CH = cylinder\nReturn: CF set on error, AH = status code"
      0x0D: "FIXED DISK - ALTERNATE DISK RESET (XT,AT,XT286,PS)\nDL = drive ID\nReturn: CF set on error, AH = status code"
      0x0E: "FIXED DISK - READ SECTOR BUFFER (XT,PS)\nES:BX -> buffer\nReturn: CF set on error, AH = status code"
      0x0F: "FIXED DISK - WRITE SECTOR BUFFER (XT,PS)\nES:BX -> buffer\nReturn: CF set on error, AH = status code"
      0x10: "FIXED DISK - TEST FOR DRIVE READY (XT,AT,XT286,PS)\nDL = drive ID\nReturn: CF set on error, AH = status code"
      0x11: "FIXED DISK - RECALIBRATE DRIVE (XT,AT,XT286,PS)\nDL = drive ID\nReturn: CF set on error, AH = status code"
      0x12: "FIXED DISK - CONTROLLER RAM DIAGNOSTIC (XT,PS)\nDL = drive ID\nReturn: CF set on error, AH = status code"
      0x13: "FIXED DISK - DRIVE DIAGNOSTIC (XT,PS)\nReturn: CF set on error, AH = status code"
      0x14: "FIXED DISK - CONTROLLER DIAGNOSTICS (XT,AT,XT286,PS)\nReturn: CF set on error, AH = status code"
      0x15: "DISK - GET TYPE (AT,XT2,XT286,CONV,PS)\nDL = drive ID\nReturn: CF set on error, AH = disk type (3 = hard drive)\nCX:DX = number of sectors on the media"
      0x16: "FLOPPY DISK - CHANGE OF DISK STATUS (AT,XT2,XT286,CONV,PS)\nDL = drive to check\nReturn: AH = disk change status"
      0x17: "DISK - SET TYPE (AT,XT2,XT286,CONV,PS\nAL = disk type AL = " { al ?
            0x00: "00h - no disk"
            0x01: "01h - regular disk in regular drive"
            0x02: "02h - regular disk in high-capacity drive"
            0x03: "03h - high-capacity disk in high-capacity drive"
            0x04: "04h - 720K disk in 720K drive, DL = drive ID"
      }
      0x18: "SET MEDIA TYPE FOR FORMAT (AT model 3x9,XT2,XT286,PS)\nDL = drive number, CH = lower 8 bits of number of tracks, CL = sectors per track"
      0x19: "FIXED DISK - PARK HEADS (XT286,PS)\nDL = drive\nReturn: CF set on error, AH = status"
      0x1A: "ESDI FIXED DISK - FORMAT UNIT (PS)\nAL = defect table count, CL = format modifiers, DL = drive, ES:BX -> defect table"
      0x1B: "ESDI FIXED DISK - GET MANUFACTURING HEADER\nAL = number of record, DL = drive, ES:BX -> buffer for manufacturing header (defect list)"
      0x1C: "ESDI FIXED DISK - " { al ?
            0x0A: "GET DEVICE CONFIGURATION\nDL = drive, ES:BX -> buffer for device configuration (drive physical parameter)"
            0x0B: "GET ADAPTER CONFIGURATION\nES:BX -> buffer for adapter configuration"
            0x0C: "GET POS INFORMATION\nES:BX -> POS information"
            0x0E: "TRANSLATE RBA TO ABA\nCH = cylinder number, CL = sector number, DH = head number, DL = drive number, ES:BX -> ABA number"
      }
      0x1D: "IBMCACHE.SYS - CACHE STATUS\nAL =" { al ?
            0x01: "get status record"
            0x02: "set cache status"
      }
      0x20: "QCACHE - DISMOUNT"
      0x21: "QCACHE - FLUSH CACHE"
      0x22: "QCACHE - ENABLE/DISABLE CACHE\nAL = 00h disable cache, 01h enable cache"
      0x24: "QCACHE - SET SECTORS\nBX = number of sectors"
      0x25: "ATA Identify Device Information\nDL = drive number\nES:BX -> buffer for IDENTIFY DEVICE information\nReturn: CF set on error, AH = error code"
      0x27: "QCACHE - INSTALLATION CHECK"
      0x2A: "QCACHE - SET BUFFER SIZE\nAL = buffer size"
      0x2C: "QCACHE - SET BUFFERED WRITES\nAL = 00h disable, 01h enable"
      0x2D: "QCACHE - SET BUFFERED READ\nAL = 00h disable, 01h enable"
      0x2E: "QCACHE - SET FLUSH COUNT\nBX = flush count"
      0x30: "QCACHE - GET INFO\nAL = 00h system info, 01h drive info, DS:DX -> buffer for info"
      0x41: "Check for INT 13h Extensions\nBX = 55AAh, DL = drive number\nReturn: CF set if not supported\nAH = extensions version\nBX = AA55h\nCX = Interface support bit map"
      0x42: "IBM/MS Extension - EXTENDED READ (DL - drive, DS:SI - disk address packet)"
      0x43: "IBM/MS Extension - EXTENDED WRITE (DL - drive, AL - verify flag, DS:SI - disk address packet)"
      0x44: "IBM/MS Extension - VERIFY SECTORS (DL - drive, DS:SI - disk address packet)"
      0x45: "IBM/MS Extension - LOCK/UNLOCK DRIVE (DL - drive, DS:SI - disk address packet)"
      0x46: "IBM/MS Extension - EJECT MEDIA (DL - drive) AL =" { al ?
            0x00: "lock media in drive"
            0x01: "unlock media"
            0x02: "check lock status"
      }
      0x47: "IBM/MS Extension - EXTENDED SEEK (DL - drive, DS:SI - disk address packet)"
      0x48: "IBM/MS Extension - GET DRIVE PARAMETERS (DL - drive, DS:SI - buffer)"
      0x49: "IBM/MS Extension - EXTENDED MEDIA CHANGED (DL - drive)"
      0x4A: "Bootable CD-ROM - INITIATE DISK EMULATION"
      0x4B: "Bootable CD-ROM - AL =" { al ?
            0x00: "TERMINATE DISK EMULATION"
            0x01: "GET STATUS"
      }
      0x4C: "Bootable CD-ROM - INITIATE DISK EMULATION AND BOOT"
      0x4D: "Bootable CD-ROM - AL =" { al ?
            0x00: "RETURN BOOT CATALOG"
      }
      0x4E: "IBM/MS Extension v2.1 - EXTENDED MEDIA CHANGED (DL - drive) AL =" { al ?
            0x00: "enable prefetch"
            0x01: "disable prefetch"
            0x02: "set maximum PIO transfer mode"
            0x03: "set PIO mode 0"
            0x04: "set default PIO mode"
            0x05: "enable INT 13h DMA maximum mode"
            0x06: "disable INT 13h DMA"
      }
      0x50: "AL =" { al ?
            0x00: "Enhanced Disk Drive Spec v3.0 - SEND PACKET COMMAND (DL - drive, ES:BX - commad packet)"
      }
      0x70: "Priam EDVR.SYS DISK PARTITIONING SOFTWARE???"
      0x81 || 0x82 || 0x83 || 0x84 || 0x85:
                "Super PC Kwik/PC-Cache 5.5 - ???"
      0x8E: "HyperDisk 4.01 - ???"
      0xA0: "Super PC Kwik - GET RESIDENT CODE SEGMENT"
      0xA1: "Super PC Kwik - FLUSH CACHE"
      0xA2: "Super PC Kwik - ???"
      0xAD: "Priam HARD DISK CONTROLLER???"
      0xB0: "Super PC Kwik - ???"
      0xEE: "SWBIOS - SET 1024 CYLINDER FLAG\nDL = drive number (80h, 81h)"
      0xF9: "SWBIOS - INSTALLATION CHECK\nDL = drive number (80h,81h)"
      0xFE: "SWBIOS - GET EXTENDED CYLINDER COUNT\nDL = drive number (80h, 81h)"
}
0x14: { ah ?
      0x00: "SERIAL I/O - INITIALIZE USART\nAL = initializing parameters, DX = port number (0-3)\nReturn: AH = RS-232 status code bits, AL = modem status bits"
      0x01: "SERIAL I/O - TRANSMIT CHARACTER\nAL = character, DX = port number (0-3)\nReturn: AH = RS-232 status code bits, AL = modem status bits"
      0x02: "SERIAL I/O - RECEIVE CHARACTER\nDX = port number (0-3)\nReturn: AL = character received, AH = RS-232 status code"
      0x03: "SERIAL I/O - GET USART STATUS\nDX = port number (0-3)\nReturn: AX = port status code"
      0x04: "SERIAL I/O - EXTENDED INITIALIZE (CONVERTIBLE,PS)\nAL = 00h if break, 01h if no break, BH = parity ..."
      0x05: "SERIAL I/O - EXTENDED COMMUNICATION PORT CONTROL (CONVERTIBLE,PS)\nAL = 00h read modem control register, AL = 01h write modem control register"
      0x06: "- FOSSIL - RAISE/LOWER DTR\nDX = port, AL = DTR state to be set"
      0x07: "- FOSSIL - RETURN TIMER TICK PARAMETERS\nReturn: AL = timer tick interrupt number\nAH = ticks per second on interrupt number in AL\nDX = approximate number of milliseconds per tick"
      0x08: "- FOSSIL - FLUSH OUTPUT BUFFER WAITING TILL ALL OUTPUT IS DONE\nDX = port number"
      0x09: "- FOSSIL - PURGE OUTPUT BUFFER THROWING AWAY ALL PENDING OUTPUT\nDX = port number"
      0x0A: "- FOSSIL - PURGE INPUT BUFFER THROWING AWAY ALL PENDING INPUT\nDX = port number"
      0x0B: "- FOSSIL - TRANSMIT NO WAIT\nAL = character, DX = port number\nReturn: AX = 0000h character not accepted, AX = 0001h character accepted"
      0x0C: "- FOSSIL - NON-DESTRUCTIVE READ AHEAD\nDX = port number\nReturn: AX = FFFFh character not available\nAX = 00xxh character xx available"
      0x0D: "- FOSSIL - KEYBOARD READ WITHOUT WAIT\nReturn: AX = FFFFh character not available\nAX = xxyyh standard IBM-style scan code"
      0x0E: "- FOSSIL - KEYBOARD READ WITH WAIT\nReturn: AX = xxyyh standard IBM-style scan code"
      0x0F: "- FOSSIL - ENABLE/DISABLE FLOW CONTROL\nAL = bit mask describing flow control requested\nDX = port number"
      0x10: "- FOSSIL - EXTENDED ^C/^K CHECKING AND TRANSMIT ON/OFF\nAL = bit mask\nDX = port number"
      0x11: "- FOSSIL - SET CURRENT CURSOR LOCATION\nDH = row, DL = column"
      0x12: "- FOSSIL - READ CURRENT CURSOR LOCATION\nReturn: DH = row, DL = column"
      0x13: "- FOSSIL - SINGLE CHARACTER ANSI WRITE TO SCREEN\nAL = character"
      0x14: "- FOSSIL - ENABLE OR DISABLE WATCHDOG PROCESSING\nAL = 01h enable watchdog\nAL = 00h disable watchdog\nDX = port number"
      0x15: "- FOSSIL - WRITE CHARACTER TO SCREEN USING BIOS SUPPORT ROUTINES\nAL = character"
      0x16: "- FOSSIL - INSERT/DELETE FUNCTION FROM TIMER TICK CHAIN\nAL = function, ES:DX -> routine to call\nReturn: AX = 0000h successful, AX = 0001h unsuccessful"
      0x17: "- FOSSIL - REBOOT SYSTEM\nAL = method"
      0x18: "- FOSSIL - READ BLOCK\nCX = maximum number of characters to transfer\nDX = port number, ES:DI -> user buffer\nReturn: AX = number of characters transfered"
      0x19: "- FOSSIL - WRITE BLOCK\nCX = maximum number of characters to transfer\nDX = port number, ES:DI -> user buffer\nReturn: AX = number of characters transfered"
      0x1A: "- FOSSIL - BREAK BEGIN OR END\nAL = 00h stop sending 'break'\nAL = 01h start sending 'break'\nDX = port number"
      0x1B: "- FOSSIL - RETURN INFORMATION ABOUT THE DRIVER\nDX = port number, CX = size of user buffer\nES:DI -> user buffer for driver info\nReturn: AX = number of characters transferred\nCX = 3058h, DX = 2030h"
      0x1C: "- X00 FOSSIL - ACTIVATE PORT\nDX = port number\nReturn: AX = 1954h if successful\nBL = maximum function number supported\nBH = revision of FOSSIL specification supported"
      0x1D: "- X00 FOSSIL - DEACTIVATE PORT\nDX = port number"
      0x1E: "- X00 FOSSIL - EXTENDED LINE CONTROL INITIALIZATION\nAL = break status, BH = parity, BL = number of stop bits\nCH = word length, CL = bps rate, DX = port number\nReturn: AX = port status code"
      0x1F: "- X00 FOSSIL - EXTENDED SERIAL PORT STATUS/CONTROL\nAL = 00h read modem control register\nAL = 01h write modem control register\nDX = port number"
      0x20: "- X00 FOSSIL - DESTRUCTIVE READ WITH NO WAIT\nDX = port number\nReturn: AH = 00h if character was available\nAL = next character, AX = FFFFh if no character available"
      0x21: "- X00 FOSSIL - STUFF RECEIVE BUFFER\nAL = character, DX = port number"
      0x7E: "- FOSSIL - INSTALL AN EXTERNAL APPLICATION FUNCTION\nAL = code assigned to external application\nES:DX -> entry point\nReturn: AX = 1954h, BL = code assigned to application\nDH = 00h failed, 01h successful"
      0x7F: "- FOSSIL - REMOVE AN EXTERNAL APPLICATION FUNCTION\nAL = code assigned to external application, ES:DX -> entry point\nReturn: AX = 1954h, BL = code assigned to application (same as input AL)\nDH = 00h failed, 01h successful"
      0x80: "- VIDEO FOSSIL - " { al ?
          0x00: "RETURN VFOSSIL INFORMATION\nES:DI -> buffer for VFOSSIL information\nReturn: AX = 1954h if installed"
          0x01: "OPEN VFOSSIL\nCX = length of buffer for application function table in bytes\nES:DI -> application function table\nReturn: AX = 1954h if installed"
          0x02: "CLOSE VFOSSIL\nReturn: AX = 1954h"
          0x03: "UNINSTALL\nReturn:     AX = 1954h"
      }
      0x81: "- COURIERS.COM - CHECK IF PORT BUSY\nAL = port number (1-4)\nReturn: AH = 00h port available\nAH = 01h port exists but already in use\nAH = 02h port nonexistent"
      0x82: "- KEYBOARD FOSSIL"
      0x83: "- SYSTEM FOSSIL"
      0x84: "- COURIERS.COM - READ CHARACTER\nReturn: ZF set if no characters available, ZF clear\nAL = character\nAH = modem status bits"
      0x85: "- COURIERS.COM - FLUSH PENDING INPUT"
      0x86: "- COURIERS.COM - START OUTPUT\nES:BX -> output buffer\nCX = length of output buffer"
      0x87: "- COURIERS.COM - OUTPUT STATUS\nReturn: AX = number of unsent characters"
      0x88: "- COURIERS.COM - ABORT OUTPUT"
      0x89: "- COURIERS.COM - SEND SINGLE CHARACTER\nCL = character to send"
      0x8A: "- COURIERS.COM - SEND BREAK"
      0x8C: "- COURIERS.COM - SET SPEED\nBX = speed in bps"
      0x8D: "- COURIERS.COM - DECONFIGURE PORT"
      0xA0: "- 3com BAPI SERIAL I/O - CONNECT TO PORT"
      0xA1: "- 3com BAPI SERIAL I/O - DISCONNECT FROM PORT"
      0xA4: "- 3com BAPI SERIAL I/O - WRITE BLOCK\nCX = length, DH = session number (00h), ES:BX -> buffer\nReturn: CX = number of bytes sent"
      0xA5: "- 3com BAPI SERIAL I/O - READ BLOCK\nCX = length, DH = session number (00h), ES:BX -> buffer\nReturn: CX = number of bytes read"
      0xA6: "- 3com BAPI SERIAL I/O - SEND SHORT BREAK\nDH = session number (00h)"
      0xA7: "- 3com BAPI SERIAL I/O - READ STATUS"
      0xAF: "- 3com BAPI SERIAL I/O - INSTALLATION CHECK"
      0xB0: "- 3com BAPI SERIAL I/O - ENABLE/DISABLE \"ENTER COMMAND MODE\" CHARACTER\nAL = 00h disable, AL = 01h enable"
      0xB1: "- 3com BAPI SERIAL I/O - ENTER COMMAND MODE"
      0xF9: "- IBM/Yale EBIOS SERIAL I/O - REGAIN CONTROL\nDX = port (00h-03h)"
      0xFA: "- IBM/Yale EBIOS SERIAL I/O - SEND BREAK\nDX = port (00h-03h)"
      0xFB: "- IBM/Yale EBIOS SERIAL I/O - SET OUTGOING MODEM SIGNALS\nAL = modem control register, DX = port (00h-03h)"
      0xFC: "- IBM/Yale EBIOS SERIAL I/O - READ CHARACTER, NO WAIT\nDX = port (00h-03h)\nReturn: AH = RS232 status bits, AL = character"
}

0x15: { ah ?
      0x00: "CASSETTE - TURN ON MOTOR (PC,Jr)\nReturn: CX = signed X count, DX = signed Y count"
      0x01: "CASSETTE - TURN OFF MOTOR (PC,Jr)\nReturn: CF set on error, AH = 86h if no cassette present"
      0x02: "CASSETTE - READ DATA BLOCKS (PC,Jr)\nCX = count of bytes, ES:BX -> data area\nReturn: CF set on error, AH = status, DX = count of bytes read\nES:BX = pointer past last byte read"
      0x03: "CASSETTE - WRITE DATA BLOCKS (PC,Jr)\nCX = count of bytes to write, ES:BX -> data area\nReturn: CF set on error, AH = status\nES:BX = pointer past last byte written, CX = 0"
      0x04: "SYSTEM - BUILD ABIOS SYSTEM PARAMETER TABLE (PS)\nES:DI -> results buffer length 20h for System Parameter Table\nDS = segment containing ABIOS RAM extensions\nReturn: AH = 00h success: results at ES:DI\nCF set on failure"
      0x05: "SYSTEM - BUILD ABIOS INITIALISATION TABLE (PS)\nES:DI -> results buffer length, DS = segment containing ABIOS RAM extensions\nReturn: AH = 00h success: results at ES:DI, CF set on failure"
      0x0F: "SYSTEM - FORMAT UNIT PERIODIC INTERRUPT (PS ESDI drives only)\nAL = " { al ?
            0x00: "00h - reserved"
            0x01: "01h - surface analysis"
            0x02: "02h - formatting"
      }
      0x10: "TopView - " { al ?
            0x00: "\"PAUSE\" - GIVE UP CPU TIME"
            0x01: "\"GETMEM\" - ALLOCATE \"SYSTEM\" MEMORY\nBX = number of bytes to allocate\nReturn: ES:DI -> block of memory or 0000h:0000h"
            0x02: "\"PUTMEM\" - DEALLOCATE \"SYSTEM\" MEMORY\nES:DI -> previously allocated block"
            0x03: "\"PRINTC\" - DISPLAY CHARACTER/ATTRIBUTE ON SCREEN\nBH = attribute, BL = character, DX = segment of object handle for window"
            0x12: "\"GETBIT\" - DEFINE A 2ND-LEVEL INTERRUPT HANDLER\nES:DI -> FAR service routine"
            0x13: "\"GETBIT\" - DEFINE A 2ND-LEVEL INTERRUPT HANDLER\nES:DI -> FAR service routine\nReturn: BX = bit mask indicating which bit was allocated\n0000h if no more bits available"
            0x14: "\"FREEBIT\" - UNDEFINE A 2ND-LEVEL INTERRUPT HANDLER\nBX = bit mask from INT 15/AX=1013h"
            0x15: "\"SETBIT\" - SCHEDULE ONE OR MORE 2ND-LEVEL INTERRUPTS\nBX = bit mask for interrupts to post"
            0x16: "\"ISOBJ\" - VERIFY OBJECT HANDLE\nES:DI = possible object handle\nReturn: BX = FFFFh if ES:DI is a valid object handle\nBX = 0000h if ES:DI is not"
            0x17: "UNIMPLEMENTED IN DV 2.x"
            0x18: "\"LOCATE\" - FIND WINDOW AT A GIVEN SCREEN LOCATION\nBH = column, BL = row, ES = segment of object handle for window below which to search"
            0x19: "\"SOUND\" - MAKE TONE\nBX = frequency in Hertz (0000h = silence)\nCX = duration in clock ticks (18.2 ticks/sec)"
            0x1A: "\"OSTACK\" - SWITCH TO TASK'S INTERNAL STACK"
            0x1B: "\"BEGINC\" - BEGIN CRITICAL REGION"
            0x1C: "\"ENDC\" - END CRITICAL REGION"
            0x1D: "\"STOP\" - STOP TASK\nES = segment of object handle for task to be stopped"
            0x1E: "\"START\" - START TASK\nES = segment of object handle for task to be started"
            0x1F: "\"DISPEROR\" - POP-UP ERROR WINDOW\nCH = width of error window, CL = height of error window\nDX = segment of object handle\nReturn: BX = status: 1 = left button, 2 = right, 27 = ESC pressed"
            0x20: "UNIMPLEMENTED IN DV 2.0x\nReturn: pops up \"Programming error\" window in DV 2.0x"
            0x21: "\"PGMINT\" - INTERRUPT ANOTHER TASK\nBX = segment of object handle for task to interrupt (not self)\nDX:CX -> FAR routine to jump to next time task is run"
            0x22: "\"GETVER\" - GET VERSION\nBX = 0\nReturn: BX nonzero, TopView or compatible loaded\n(BL = major version, BH = minor version)"
            0x23: "\"POSWIN\" - POSITION WINDOW\nBX = segment of object handle for parent window within which\nES = segment of object handle for window to be positioned\nDL = bit flags\n, CH = number of columns, CL = number of rows"
            0x24: "\"GETBUF\" - GET VIRTUAL SCREEN INFO\nBX = segment of object handle for window\nReturn: ES:DI -> virtual screen\nCX = size of virtual screen in bytes\nDL = " { dl ?
                  0x00: "text screen"
                  0x01: "graphics screen"
            }
            0x25: "\"USTACK\" - SWITCH BACK TO USER'S STACK\nReturn: stack switched back"
            0x2B: "DESQview 2.0 (TopView???) - \"POSTTASK\" - AWAKEN TASK\nBX = segment of object handle for task"
            0x2C: "DESQview 2.0 (TopView???) - START NEW APPLICATION IN NEW PROCESS\nES:DI -> contents of .PIF/.DVP file\nBX = size of .PIF/.DVP info\nReturn: BX = segment of object handle for new task"
            0x2D: "DESQview 2.0 - KEYBOARD MOUSE CONTROL\nBL = " { bl ?
                  0x00: "determine whether using keyboard mouse"
                  0x01: "turn keyboard mouse on"
                  0x02: "turn keyboard mouse off"
            }
      }
      0x11: { al ?
            0x17: "DESQview 2.2+ - \"ASSERTMAP\" - GET/SET MAPPING CONTEXT\nBX = 0000h  get current mapping context without setting\nnonzero    set new mapping context\nReturn: BX = mapping context in effect before call\ninterrupts enabled"
            0xDE: "DESQview - XDV.COM - INSTALLATION CHECK\nReturn: CF clear if installed\nAX = segment at which XDV is located"
      }
      0x12: { bh ?
            0x00: "SEND MESSAGE - \"HANDLE\" - RETURN OBJECT HANDLE\n BL = which handle to return\nReturn: DWORD on top of stack is object handle"
            0x01: "SEND MESSAGE - \"NEW\" - CREATE NEW OBJECT\n BL = object type to create\nSTACK: (if window object or WINDOW class)\nReturn: DWORD on top of stack is new object handle"
            0x02: "SEND MESSAGE - \"FREE\" - FREE AN OBJECT\n BL = object"
            0x03: "SEND MESSAGE - \"ADDR\" - GET HANDLE OF MESSAGE SENDER\nBL = object\nReturn: DWORD on stack is task handle of message sender"
            0x04: "SEND MESSAGE - \"READ\" - READ NEXT LOGICAL LINE OF WINDOW or\nGET NEXT RECORD FROM OBJECT\nBL = " { bl ?
                  0x00: "handle is DWORD on top of stack"
                  0x01: "use calling task's default window"
                  0x02: "get next message from mailbox (task's handle on top of stack)"
                  0x03: "get next message from current task's mailbox"
                  0x04: "get the next input from keyboard (handle on top of stack)"
                  0x05: "get the next input from task's default keyboard"
                  0x06: "wait for input from any object in OBJECTQ (handle on stack)"
                  0x07: "wait for input from any object in task's default OBJECTQ"
                  0x0C: "(DV 2.26+) default window of task owning handle on top of stack"
                  0x0D: "(DV 2.26+) default window of parent task of current task"
            }
            0x05: "SEND MESSAGE - \"WRITE\" - WRITE TO OBJECT or WRITE STRING TO WINDOW\nBL = " { bl ?
                  0x00: "handle is DWORD on top of stack"
                  0x01: "01h - write string to task's default window"
                  0x02: "send message by value/status=0 to mbox (task's handle on stack)"
                  0x03: "send message by value/status=0 to current task's mailbox"
                  0x04: "add input buffer to KEYBOARD queue (handle on top of stack)"
                  0x05: "add input buffer to task's default KEYBOARD queue"
                  0x06: "add an object to OBJECTQ (handle on top of stack)"
                  0x07: "add an object to task's default OBJECTQ"
                  0x0C: "0Ch - (DV 2.26+) default window of task owning handle on top of stack"
                  0x0D: "0Dh - (DV 2.26+) default window of parent of current task"
            }
            0x06: "DESQview 2.2+ - SEND MESSAGE - \"SETPRI\" - SET PRIORITY WITHIN OBJECTQ\nBL = " { bl ?
                  0x00: "00h - object handle in DWORD on top of stack"
                  0x04: "04h - given task's keyboard (task's handle on top of stack)"
                  0x05: "05h - current task's default keyboard"
            }
            0x07: "DESQview 2.2+ - SEND MESSAGE - \"GETPRI\" - GET PRIORITY WITHIN OBJECTQ\nBL = " { bl ?
                  0x00: "00h - object handle in DWORD on top of stack"
                  0x04: "04h - given task's keyboard (task's handle on top of stack)"
                  0x05: "05h - current task's default keyboard"
            }
            0x08: "SEND MESSAGE - \"SIZEOF\" - GET OBJECT SIZE\nBL = " { bl ?
                  0x00: "00h - handle in DWORD on top of stack"
                  0x01: "01h - total chars in current task's default window"
                  0x02: "02h - number of messages in task's mailbox (task's handle on stack)"
                  0x03: "03h - number of messages in current task's mailbox"
                  0x04: "04h - number of input buffers queued in task's kbd (handle on stack)"
                  0x05: "05h - number of input buffers queued for current task's default kbd"
                  0x06: "06h - number of objects queued in OBJECTQ (task's handle on stack)"
                  0x07: "07h - number of objects queued in current task's OBJECTQ"
                  0x0C: "0Ch - (DV 2.26+) total chars in window owning handle on top of stack"
                  0x0D: "0Dh - (DV 2.26+) total chars in parent task's window"
            }
            0x09: "SEND MESSAGE - \"LEN\" - GET OBJECT LENGTH\nBL = " { bl ?
                  0x00: "00h - handle in DWORD on top of stack"
                  0x01: "01h - get number of chars/line in current task's default window"
                  0x0C: "0Ch - (DV 2.26+) get chars/line in window owning handle on top of stk"
                  0x0D: "0Dh - (DV 2.26+) get chars/line in parent task's window"
            }
            0x0A: "SEND MESSAGE - \"ADDTO\" - WRITE CHARS AND ATTRIBS TO WINDOW or\nSEND MAILBOX MESSAGE/STAT BY VALUE or\nSET OBJECT BITS\nBL = " { bl ?
                  0x00: "00h - handle is DWORD on top of stack"
                  0x01: "01h - current task's default window"
                  0x02: "02h - default mailbox of task whose handle is on top of stack"
                  0x03: "03h - current task's default mailbox"
                  0x04: "04h - set control flags on KEYBOARD object (handle on top of stack)"
                  0x05: "05h - set control flags on task's default KEYBOARD object"
                  0x0C: "0Ch - (DV 2.26+) default window of task owning handle on top of stack"
                  0x0D: "0Dh - (DV 2.26+) default window of parent of current task"
            }
            0x0B: "SEND MESSAGE - \"SUBFROM\" - WRITE ATTRIBUTES TO WINDOW or\nSEND MAILBOX MESSAGE/STAT, BY REF or\nREMOVE OBJECT FROM OBJECTQ or\nRESET OBJECT BITS\nBL = " { bl ?
                  0x00: "handle is DWORD on top of stack"
                  0x01: "current task's default window"
                  0x02: "default mailbox of task whose handle is on top of stack"
                  0x03: "current task's default mailbox"
                  0x04: "clear control flags on KEYBOARD object (handle on top of stack)"
                  0x05: "clear control flags on task's default KEYBOARD object"
                  0x0C: "(DV 2.26+) default window of task owning handle on top of stack"
                  0x0D: "(DV 2.26+) default window of parent of current task"
            }
            0x0C: "SEND MESSAGE - \"OPEN\" - OPEN OBJECT\nBL = " { bl ?
                  0x00: "handle is DWORD on top of stack"
                  0x01: "fill task's default window with given char from scrl org to end"
                  0x02: "open given task's mailbox for input (task's handle on stack)"
                  0x03: "open current task's mailbox"
                  0x04: "attach a KEYBOARD to a window (handle on top of stack)"
                  0x05: "attach task's default KEYBOARD to a window"
                  0x06: "open a task's OBJECTQ (task's handle on top of stack)"
                  0x07: "open current task's OBJECTQ"
                  0x0C: "(DV 2.26+) fill def window of task owning handle on top of stck"
                  0x0D: "(DV 2.26+) fill default window of parent of current task"
            }
            0x0D: "SEND MESSAGE - \"CLOSE\" - CLOSE OBJECT\nBL = " { bl ?
                  0x00: "handle is DWORD on top of stack"
                  0x02: "close given task's mailbox (task's handle on top of stack)"
                  0x03: "close task's default mailbox"
                  0x04: "close KEYBOARD object (handle on top of stack)"
                  0x05: "close task's default KEYBOARD"
                  0x06: "close givent task's OBJECTQ (task's handle on top of stack)"
                  0x07: "close current task's OBJECTQ"
            }
            0x0E: "SEND MESSAGE - \"ERASE\" - ERASE OBJECT\nBL = " { bl ?
                  0x00: "handle is DWORD on top of stack"
                  0x01: "clear task's default window from scroll origin to end"
                  0x02: "discard all queued messages in mailbox (handle on top of stack)"
                  0x03: "discard all queued messages in current task's default mailbox"
                  0x04: "discard all input queued to KEYBOARD (handle on top of stack)"
                  0x05: "discard all input queued to task's default KEYBOARD"
                  0x06: "remove all objects from OBJECTQ (task's handle on top of stack)"
                  0x07: "remove all objects from current task's OBJECTQ"
                  0x0C: "(DV 2.26+) clear window of task owning handle on top of stack"
                  0x0D: "(DV 2.26+) clear default window of parent of current task"
            }
            0x0F: "SEND MESSAGE - \"STATUS\" - GET OBJECT STATUS\nBL = " { bl ?
                  0x00: "handle is DWORD on top of stack"
                  0x02: "return status of last msg READ from mailbox (handle on stack)"
                  0x03: "return status of last msg READ from task's default mailbox"
                  0x04: "get status of last msg from task's KEYBOARD (task handle on stk)"
                  0x05: "get status of last msg from task's default KEYBOARD"
                  0x06: "return whether OBJECTQ is open or not (handle on top of stack)"
                  0x07: "return whether task's default OBJECTQ is open or not"
            }
            0x10: "SEND MESSAGE - \"EOF\" - GET OBJECT EOF STATUS\nBL = " { bl ?
                  0x00: "handle is DWORD on top of stack"
                  0x01: "returns TRUE if logical cursor past end of task's def window"
                  0x02: "return ??? for task's mailbox (task's handle on top of stack)"
                  0x03: "return ??? for current task's mailbox"
                  0x0C: "(DV 2.26+) check log crsr of window owning handle on top of stk"
                  0x0D: "(DV 2.26+) check log cursor of window of parent task"
            }
            //?*? "\nReturn: DWORD on top of stack is status"
            0x11: "SEND MESSAGE - \"AT\" - POSITION OBJECT CURSOR\nBL = window for which to move cursor: " { bl ?
                  0x00: "window's handle is DWORD on top of stack"
                  0x01: "task's default window"
                  0x0C: "(DV 2.26+) default window of task owning handle on top of stack"
                  0x0D: "(DV 2.26+) default window of parent of current task"
            }
            0x12: "SEND MESSAGE - \"READN\" - GET NEXT N OBJECT BYTES\nBL = window to read from: " { bl ?
                  0x00: "handle is DWORD on top of stack"
                  0x01: "read next N chars or attributes on task's default window"
                  0x0C: "(DV 2.26+) read window of task owning handle on top of stack"
                  0x0D: "(DV 2.26+) read default window of parent of current task"
            }
            0x13: "SEND MESSAGE - \"REDRAW\" - REDRAW WINDOW\nBL = window object: " { bl ?
                  0x00: "DWORD on top of stack is handle for window to redraw"
                  0x01: "redraw task's default window"
                  0x0C: "(DV 2.26+) redraw window of task owning handle on top of stack"
                  0x0D: "(DV 2.26+) redraw default window of parent of current task"
            }
            0x14: "SEND MESSAGE - \"SETESC\" - SET ESCAPE ROUTINE ADDRESS\nBL = message modifier: " { bl ?
                  0x00: "handle is DWORD on top of stack"
                  0x01: "define user stream"
                  0x04: "intercept keystrokes from KEYBOARD to a window (handle on stack)"
                  0x05: "intercept keystrokes from task's default KEYBOARD to a window"
            }
            0x15: "DESQview 2.2+ - SEND MESSAGE - \"SETFLAGS\" - SET OBJECT FLAGS\nBL = " { bl ?
                  0x00: "DWORD on top of stack"
                  0x02: "mailbox for task whose handle is on top of stack"
                  0x03: "mailbox for current task"
                  0x04: "keyboard for task whose handle is on top of stack"
                  0x05: "keyboard for current task"
            }
            0x16: "DESQview 2.2+ - SEND MESSAGE - \"GETFLAGS\" - GET OBJECT FLAGS\nBL = " { bl ?
                  0x00: "DWORD on top of stack"
                  0x02: "mailbox for task whose handle is on top of stack"
                  0x03: "mailbox for current task"
                  0x04: "keyboard for task whose handle is on top of stack"
                  0x05: "keyboard for current task"
            }
            //?*?"\nReturn: STACK: DWORD current control flags"
      }
      0x20: { al ?
            0x00: "DOS 3.x PRINT.COM - DISABLE CRITICAL REGION FLAG (AT,XT286,PS50+)"
            0x01: "DOS 3.x PRINT.COM - SET CRITICAL REGION FLAG (AT,XT286,PS50+)\nES:BX -> byte which is to be incremented while in a DOS call"
            0x10: "OS HOOK - SETUP SYSREQ ROUTINE (AT,XT286,PS50+)"
            0x11: "OS HOOK - COMPLETION OF SYSREQ FUNCTION (AT,XT286,PS50+)"
      }
      0x21: "SYSTEM - POWER-ON SELF-TEST ERROR LOG (PS50+)\nAL = " { al ?
            0x00: "read POST log"
            0x01: "write POST log"
      }
      //?*?"\nReturn: CF set on error, AH = status\nif function 00h: BX = number of error codes stored, ES:DI -> error log"
      0x40: "SYSTEM - READ/MODIFY PROFILES (CONVERTIBLE)\nAL = " { al ?
            0x00: "get system profile in CX and BX"
            0x01: "set system profile from CX and BX"
            0x02: "get internal modem profile in BX"
            0x03: "set internal modem profile from BX"
      }
      0x41: "SYSTEM - WAIT ON EXTERNAL EVENT (CONVERTIBLE)\nAL = condition type, BH = condition compare or mask value\nBL = timeout value times 55 milliseconds, 00h means no timeout\nDX = I/O port address if AL bit 4 set"
      0x42: "SYSTEM - REQUEST POWER OFF (CONVERTIBLE): " { al ?
            0x00: "to use system profile"
            0x01: "to force suspend regardless of system profile"
      }
      0x43: "SYSTEM - READ SYSTEM STATUS (CONVERTIBLE)\nReturn: AL = status bits"
      0x44: "SYSTEM - (DE)ACTIVATE INTERNAL MODEM POWER (CONVERTIBLE)\nAL = 00h to power off, 01h to power on"
      0x46: { al ?
            0x00: "Compaq SLT/286 - READ POWER CONSERVATION/MODEM CONFIGURATION\nReturn: AH = modem configuration information\nBH = default system inactivity timeout\nBL = current system inactivity timeout\nCH = default video display inactivity timeout"
            0x01: "Compaq SLT/286 - Modify Power Conservation/Modem Configuration\nBL = system inactivity timeout, = FFh do not change\nCL = video display inactivity timeout, = FFh do not change\nDL = current fixed disk drive inactivity timeout"
      }
      0x4F: "OS HOOK - KEYBOARD INTERCEPT (AT model 3x9,XT2,XT286,CONV,PS)\nAL = scan code, CF set\nReturn: CF set - AL = scan code\nCF clear - scan code should be ignored"
      0x52: "Removable Media Eject Intercept\nDL = driver number\nReturn: CF clear, AH = 0: OK to eject\nCF set, AH = B1h or B3h, ejection rejected"
      0x53: "APM BIOS Services - " { al ?
            0x00: "Installation check\nBX = Power device ID (0000h = APM BIOS)\nReturn: CF clear on success\nAH:AL APM major:minor version number\nBX = 'PM'\nCX = APM flags"
            0x01: "Real mode interface connect\nBX = Power device ID (0000h = APM BIOS)"
            0x02: "16-bit protected mode interface connect"
            0x03: "32-bit protected mode interface connect"
            0x05: "CPU Idle"
            0x06: "CPU Busy"
            0x07: "Set power state"
            0x08: "Enable/disable power management"
            0x09: "Restore power-on defaults"
            0x0a: "Get power status"
            0x0b: "Get PM event"
            0x0c: "Get power state"
            0x0d: "Enable/disable device power management"
            0x0e: "APM driver version"
            0x0f: "Engage/disengage power management"
            0x10: "Get capabilities"
            0x11: "Get/Set/Disable Resume Timer"
            0x12: "Enable/Disable Resume on Ring Indicator"
            0x13: "Enable/Disable Timer Based Requests"
            0x80: "OEM APM functions"
      }
      0x54: "Omniview Multitasker - " { al ?
            0x00: "INSTALLATION NOTIFICATION\nES:BX -> device information tables, DI:DX -> dispatcher entry point"
            0x01: "PROCESS CREATION\nES:BX = process handle"
            0x02: "PROCESS DESTRUCTION\nES:DX = process handle"
            0x03: "SAVE\nES:DX = process swapping out"
            0x04: "RESTORE\nES:DX = process swapping in"
            0x05: "SWITCHING TO BACKGROUND\nES:DX = process swapping in"
            0x06: "SWITCHING TO FOREGROUND\nES:DX = process swapping in"
            0x07: "EXIT NOTIFICATION"
      }
      0x80: "OS HOOK - DEVICE OPEN (AT,XT2,XT286,PS)\nBX = device ID, CX = process type\nReturn: CF set on error, AH = status\nCF clear if successful, AH = 00h"
      0x81: "OS HOOK - DEVICE CLOSE (AT,XT2,XT286,PS)\nBX = device ID, CX = process type\nReturn: CF set on error, AH = status\nCF clear if successful, AH = 00h"
      0x82: "OS HOOK - DEVICE PROGRAM TERMINATE (AT,XT2,XT286,PS)\nBX = device ID\nReturn: CF set on error, AH = status\nCF clear if successful, AH = 00h"
      0x83: "SYSTEM - EVENT WAIT (AT,XT286,CONV,PS)\nAL = 00h - set interval, 01h - cancel\nES:BX -> event flag\nCX:DX = number of microseconds to wait\nReturn: CF set if function already busy"
      0x84: "SYSTEM - READ JOYSTICK (AT,XT2,XT286,PS)\nDX = " { dx ?
            0x00: "0000h get switch settings\nReturn: AL = switch settings"
            0x01: "0001h read joystick inputs\nReturn: AX = A(x) value"
      }
      0x85: "OS HOOK - SYSTEM REQUEST KEY PRESSED (AT,XT2,XT286,CONV,PS)\nAL = 00h press, = 01h release\nReturn: CF set on error, AH = status"
      0x86: "SYSTEM - WAIT (AT,XT2,XT286,CONV,PS)\nCX,DX = number of microseconds to wait\nReturn: CF clear: after wait elapses, CF set: immediately due to error"
      0x87: "EXTENDED MEMORY - BLOCK MOVE (AT,XT286,PS)\nCX = number of words to move, ES:SI -> global descriptor table\nReturn: CF set on error, AH = status"
      0x88: "Get Extended Memory Size\nReturn: CF clear on success\nAX = size of memory above 1M in K"
      0x89: "SYSTEM - SWITCH TO VIRTUAL MODE (AT,XT286,PS50+)\nBL = interrupt number of IRQ0 (IRQ1-7 use next 7 interrupts)\nBH = interrupt number of IRQ8 (IRQ9-F use next 7 interrupts)\nDS:SI -> GDT for protected mode"
      0x8a: "Big memory size (Phoenix)\nAX:DX = memory above 1024K in 1K blocks"
      0x90: "OS HOOK - DEVICE BUSY LOOP (AT,XT2,XT286,CONV,PS)\nAL = " { al ?
                0x00: "disk"
                0x01: "diskette"
                0x02: "keyboard"
                0x03: "PS/2 pointing device"
                0x80: "network"
                0xFC: "disk reset"
                0xFD: "diskette motor start"
                0xFE: "printer, ES:BX -> request block for type codes 80h through BFh"
      }
      0x91: "OS HOOK - SET FLAG AND COMPLETE INTERRUPT (AT,XT2,XT286,CONV,PS)\nAL = type code, ES:BX -> request block for type codes 80h through BFh"
      0xC0: "SYSTEM - GET CONFIGURATION (XT after 1/10/86,AT mdl 3x9,CONV,XT286,PS)"
      0xC1: "SYSTEM - RETURN EXTENDED-BIOS DATA-AREA SEGMENT ADDRESS (PS)\nReturn: CF set on error, CF clear if successful\nES = segment of data area"
      0xC2: "SYSTEM - POINTING DEVICE BIOS INTERFACE (PS) " { al ?
            0x00: "- ENABLE/DISABLE\n"
                  "BH = 00h disable, 01h enable\n"
                  "Return: CF set on error, AH = status"
            0x01: "- RESET\nReturn: CF set on error, AH = status\nCF clear if successful, BH = device ID"
            0x02: "- SET SAMPLING RATE\nBH = sampling rate" { bh ?
                        0x00: "\n10/second"
                        0x01: "\n20/second"
                        0x02: "\n40/second"
                        0x03: "\n60/second"
                        0x04: "\n80/second"
                        0x05: "\n100/second"
                        0x06: "\n200/second"
            }
            //?*?"\nReturn: CF set on error, AH = status"
            0x03: "SYSTEM - POINTING DEVICE BIOS INTERFACE (PS) - SET RESOLUTION\nBH = resolution" { bh ?
                      0x00: "one count per mm"
                      0x01: "two counts per mm"
                      0x02: "four counts per mm"
                      0x03: "eight counts per mm"
            }
            //?*?"\nReturn: CF set on error, AH = status"
            0x04: "SYSTEM - POINTING DEVICE BIOS INTERFACE (PS) - GET TYPE\nReturn: CF set on error, AH = status\nCF clear if successful, BH = device ID"
            0x05: "SYSTEM - POINTING DEVICE BIOS INTERFACE (PS) - INITIALIZE\nBH = data package size (1 - 8 bytes)\nReturn: CF set on error, AH = status"
            0x06: "SYSTEM - POINTING DEVICE BIOS INTERFACE (PS) - GET/SET SCALING FACTOR\nBH = subfunction" { bh ?
                      0x00: "return device status"
                      0x01: "set scaling at 1:1"
                      0x02: "set scaling at 2:1"
            }
            //?*?"\nReturn: CF set on error, AH = status"
            0x07: "SYSTEM - POINTING DEVICE BIOS INTERFACE (PS) - SET DEVICE HANDLER ADDR\nES:BX = user device handler\nReturn: CF set on error, AH = status"
      }
      0xC3: "SYSTEM - ENABLE/DISABLE WATCHDOG TIMEOUT (PS50+)\nAL = 00h disable / 01h enable, BX = timer counter\nReturn: CF set on error, CF clear if successful"
      0xC4: "SYSTEM - PROGRAMMABLE OPTION SELECT (PS50+)\nAL = 00h return base POS register address\n     01h enable slot (BL = slot number), 02h enable adapter\nReturn: CF set on error, DX = base POS register address"
      0xD8: "EISA SYSTEM ROM " { al ?
            0x00: "- READ SLOT CONFIGURATION INFORMATION\nCL = slot number (including embedded and virtual)\nReturn: CF clear if successful, CF set on error, AL bit flags\nBH = major revision level of configuration utility"
            0x01: "- READ FUNCTION CONFIGURATION INFORMATION\nCH = function number to read, CL = slot number\nDS:SI -> 320-byte buffer\nReturn: CF clear if successful, AH = 00h, DS:SI buffer filled\nCF set on error, AH = error code"
            0x02: "- CLEAR NONVOLATILE MEMORY (EISA CMOS)\nBH = EISA config utility major revision level\nBL = EISA config utility minor revision level\nReturn: CF clear if successful, AH = 00h\nCF set on error, AH = error code"
            0x03: "- WRITE NONVOLATILE MEMORY\nCX = length of data structure includes two bytes for config file checksum\nDS:SI -> configuration data\nReturn: CF clear if successful, AH = 00h\nCF set on error, AH = error code"
            0x04: "- READ PHYSICAL SLOT\nCL = slot number (including embedded and virtual)\nReturn: CF clear if successful, AH = 00h\nCF set on error, AH = error code\nSI:DI = 4-byte compressed ID"
            0x80: "- 32-bit CS ADDRESSING MODE CALLS\nReturn: as appropriate for AL=00h to 04h"
            0x81: "- 32-bit CS ADDRESSING MODE CALLS\nReturn: as appropriate for AL=00h to 04h"
            0x82: "- 32-bit CS ADDRESSING MODE CALLS\nReturn: as appropriate for AL=00h to 04h"
            0x83: "- 32-bit CS ADDRESSING MODE CALLS\nReturn: as appropriate for AL=00h to 04h"
            0x84: "- 32-bit CS ADDRESSING MODE CALLS\nReturn: as appropriate for AL=00h to 04h"
      }
      0xDE: "DESQview - " { al ?
            0x00: "GET PROGRAM NAME\nReturn: AX = offset into DESQVIEW.DVO of current program's record"
            0x01: "UPDATE \"OPEN WINDOW\" MENU"
            0x02: "SET ??? FLAG FOR CURRENT WINDOW"
            0x03: "GET ??? FOR CURRENT WINDOW\nReturn: AX = ??? for current window\nBX = ??? for current window"
            0x04: "GET AVAILABLE COMMON MEMORY\nReturn: BX = bytes of common memory available\nCX = largest block available\nDX = total common memory in bytes"
            0x05: "GET AVAILABLE CONVENTIONAL MEMORY\nReturn: BX = K of memory available\nCX = largest block available\nDX = total conventional memory in K"
            0x06: "GET AVAILABLE EXPANDED MEMORY\nReturn: BX = K of expanded memory available\nCX = largest block available\nDX = total expanded memory in K"
            0x07: "\"APPNUM\" - GET CURRENT PROGRAM'S NUMBER\nReturn: AX = number of program as it appears on the \"Switch Windows\" menu"
            0x08: "GET ???\nReturn: AX = 0000h if ??? is not set to the current task\n0001h if ??? is set to the current task"
            0x09: "UNIMPLEMENTED"
            0x0A: "2.x - \"DBGPOKE\" - DISPLAY CHARACTER ON STATUS LINE\nBL = character\nReturn: character displayed, next call will display in next position (which\nwraps back to the start of the line if off the right edge of screen)"
            0x0B: "2.x - \"APILEVEL\" - DEFINE MINIMUM API LEVEL REQUIRED\nBL = API level major version number\nBH = API level minor version number\nReturn: AX = maximum API level (AL = major, AH = minor)"
            0x0C: "2.x - \"GETMEM\" - ALLOCATE \"SYSTEM\" MEMORY\nBX = number of bytes\nReturn: ES:DI -> allocated block or 0000h:0000h (DV 2.26+)"
            0x0D: "2.x - \"PUTMEM\" - DEALLOCATE \"SYSTEM\" MEMORY\nES:DI -> previously allocated block"
            0x0E: "2.x - \"FINDMAIL\" - FIND MAILBOX BY NAME\nES:DI -> name to find, CX = length of name\nReturn: BX = 0000h not found, = 0001h found\nDS:SI = object handle"
            0x0F: "2.x - ENABLE DESQview EXTENSIONS\nReturn: AX and BX destroyed (seems to be bug, weren't saved&restored)"
            0x10: "2.x - \"PUSHKEY\" - PUT KEY INTO KEYBOARD INPUT STREAM\nBH = scan code, BL = character"
            0x11: "2.x - ENABLE/DISABLE AUTOMATIC JUSTIFICATION OF WINDOW\nBL = 00h      viewport will not move automatically\n   nonzero  viewport will move to keep cursor visible (default)"
            0x12: "2.01+ - \"CSTYLE\" - SET \"C\"-COMPATIBLE CONTROL CHAR INTERPRET\nBX = 0000h    select normal style (linefeed only moved down)\n    nonzero  select C style (linefeed moves to start of next line)"
            0x13: "2.2+ - GET CRITICAL NESTING COUNT\nReturn: BX = number of calls to BEGINC or ENTERC"
            0x14: "2.2+ - GET OBJECT TYPE\nReturn: BL = OBJECT TYPE"
            0x15: "2.2+ - SET ERROR HANDLING\n BL = " { bl ?
                      0x00: "post system error on all error conditions"
                      0x01: "return carry flag set on calls to ADDTO, SUBFROM, and WRITE\nmessages sent to mailboxes which fail due to lack of system\nor common memory"
                      0x02: "(v2.26+) same as 01h, but return null pointer for GETMEM\ncalls which fail due to lack of system memory"
                  }
            0x16: "2.2+ - GET ERROR HANDLING\nReturn: BL = 00h always post system error\nBL = 01h return carry flag set on failed mailbox writes\nBL = 02h return CF set on failed mailbox writes and NULL on failed\nGETMEM calls"
            0x17: "2.26+ - \"ASSERTMAP\" - GET/SET MAPPING CONTEXT\nBX = 0000h  get current mapping context without setting\n      nonzero set new mapping context"
            0x18: "2.2+ internal -\nBP = function number"
            0x19: "2.23+ - \"GETCOMMON\" - ALLOCATE \"COMMON\" MEMORY\nBX = number of bytes to allocate\nReturn: AX = 0000h successful, ES:DI -> allocated block\nnonzero insufficient memory"
            0x1A: "2.23+ - \"PUTCOMMON\" - DEALLOCATE \"COMMON\" MEMORY\nDS:SI -> previously allocated block"
            0x1B: "2.23+ internal - DECREMENT CRITICAL NESTING COUNT"
            0x1C: "2.23+ - \"ENTERC\" - INCREMENT CRITICAL NESTING COUNT"
            0x1D: "2.23+ - \"PUTKEY\" - FAKE USER KEYSTROKES\nDX = segment of handle for task to receive keystroke\nBL = character, BH = scan code\nReturn: AX = 0000h if successful\nnonzero if receiver's keyboard buffer was full"
            0x1E: "2.23+ - \"SCRNINFO\" - GET TRUE VIDEO PARAMETERS\nReturn:    CL = actual number of rows on screen\nCH = actual number of columns on screen\nBL = actual video mode (may differ from INT 10/AH=0Fh return) (v2.26+)"
            0x1F: "2.23+ - \"DOSUSER\" - GET HANDLE OF TASK CURRENTLY USING DOS\nReturn: BX = segment of task handle or 0000h if no tasks are using DOS"
            0x20: "2.26+ - \"DISPATCHINT\" - INTERRUPT ANOTHER TASK\nBX = segment of handle of task to interupt\nDX:CX -> FAR interrupt routine"
            0x21: "2.26+ - \"ASSERTVIR\" - CONTROL 386 SCREEN VIRTUALIZATION\nBX = 0000h turn off / nonzero turn on\nReturn: BX = old state of virtualization"
            0x22: "2.26+ - \"PROCESSMEM\" - GET TASK MEMORY STATUS\nDX = segment of task handle\nReturn: DX = total amount of memory in paragraphs\nBX = amount of system memory in paragraphs\nCX = largest block of system memory, AX = flags"
            0x23: "2.31+ - ???\nBX = ???, CX = ???"
            0xE0: "Compaq Systempro - MULTIPROCESSOR DISPATCH\nES:BX -> start of 2nd processor's execution\nReturn: AL = 0Fh successful, = 00h failure"
            0xE1: "Compaq Systempro - MULTIPROCESSOR END-OF-DISPATCH\nES:BX -> start of 2nd processor's execution\nReturn: AL = 0Fh successful (halted), = 00h failure (not halted)"
            0xE2: "Compaq Systempro - MULTIPROCESSOR AVAILABLE\nReturn: AX = 8000h if 2nd processor available"
      }
      0xE8: "BIOS Memory Services" { ah ?
            0x01: " - Get Memory Size for Large Configurations\nReturns: CF clear on success\nAX = extended memory between 1M and 16M, in K (max 3C00h=15 MB)\nBX = extended memory above 16M, in 64K blocks\nCX = configured memory 1M to 16M, in K\nDX = configured memory above 16M, in 64K blocks"
            0x20: " - Query System Address Map\nEDX = 534D4150h ('SMAP')\nEBX = continuation value or 0 to start from beginning\nECX = size of buffer for result\nES:DI -> buffer for result\nReturns: CF clear on success\nEAX=534D4150h ('SMAP')\nEBX = next offset or 0 if done\nECX = actual length"
            0x81: " - Get Memory Size (32-bit mode)\nReturns: CF clear on success\nEAX = extended memory between 1M and 16M, in K\nEBX = extended memory above 16M, in 64K blocks\nECX = configured memory 1M to 16M, in K\nEDX = configured memory above 16M, in 64K blocks"
      }
}
0x16: "KEYBOARD - " { ah ?
      0x00: "READ CHAR FROM BUFFER, WAIT IF EMPTY\nReturn: AH = scan code, AL = character"
      0x01: "CHECK BUFFER, DO NOT CLEAR\nReturn: ZF clear if character in buffer\nAH = scan code, AL = character\nZF set if no character in buffer"
      0x02: "GET SHIFT STATUS\nAL = shift status bits"
      0x03: "SET DELAYS (Jr,AT model 339,XT286,PS)\nBH = 00h - 03h for delays of 250ms, 500ms, 750ms, or 1s\nBL = 00h - 1Fh for typematic rates of 30cps down to 2cps\nAL = " { al ?
                0x00: "reset typematic (PCjr)"
                0x01: "increase initial delay (PCjr)"
                0x02: "increase continuing delay (PCjr)"
                0x03: "increase both delays (PCjr)"
                0x04: "turn off typematic (PCjr)"
                0x05: "Set typematic rate (AT or PS/2)"
      }
      0x04: "KEYCLICK (Jr,CONV)\nAL = 00h click off, 01h click on"
      0x05: "WRITE TO KEYBOARD BUFFER (AT model 339,XT2,XT286,PS)\nCH = scan code, CL = character\nReturn: AL = 01h if buffer full"
      0x10: "GET ENHANCED KEYSTROKE (AT model 339,XT2,XT286,PS)\nReturn: AH = scan code, AL = character"
      0x11: "CHECK ENHANCED KEYSTROKE (AT model 339,XT2,XT286,PS)\nReturn: ZF clear if keystroke available\nAH = scan code \\ meaningless if ZF = 1\nAL = character /\nZF set if kbd buffer empty"
      0x12: "GET ENHANCED SHIFT FLAGS (AT model 339,XT2,XT286,PS)\nReturn: AL = shift flags (same as for AH=02h)"
      0x55: "Microsoft Word internal - MICROSOFT WORD COOPERATION WITH TSR\nReturn: AX = 4D53h if keyboard TSR present"
      0x69: "PC Tools v5.1+ BACKTALK - UNHOOK\nReturn: resident code unhooked, but not removed from memory"
      0x6F: "MS Windows - ???"
      0x70: "FAKEY.COM - INSTALLATION CHECK\nReturn: AX = 1954h if installed"
      0x71: "FAKEY.COM - PUSH KEYSTROKES\nCX = number of keystrokes\nDS:SI -> array of words containing keystrokes to be returned by AH=00h"
      0x72: "FAKEY.COM - CLEAR FAKED KEYSTROKES"
      0x73: "FAKEY.COM - PLAY TONES\nCX = number of tones to play\nDS:SI -> array of tones"
      0x75: "pcANYWHERE - SET TICK COUNT FOR SCANNING\nAL = number of ticks between checks for new screen changes"
      0x76: "pcANYWHERE - SET ERROR CHECKING TYPE\nAL = 00h none, 01h fast, 02h slow"
      0x77: "pcANYWHERE - LOG OFF\nAL = " { al ?
                0x00: "wait for another call"
                0x01: "leave in Memory Resident Mode"
                0x02: "leave in Automatic Mode"
                0xFF: "leave in current operating mode"
      }
      0x79: "pcANYWHERE - CHECK STATUS\nReturn: AX = status"
      0x7A: "pcANYWHERE - CANCEL SESSION"
      0x7B: { al ?
            0x00: "pcANYWHERE - SUSPEND"
            0x01: "pcANYWHERE - RESUME"
      }
      0x7C: "pcANYWHERE - GET PORT CONFIGURATION\nReturn: AH = port number, AL = baud rate"
      0x7D: "pcANYWHERE - GET/SET TERMINAL PARAMETERS\nDS:CX -> terminal parameter block\nAL = subfunction " { al ?
                0x00: "set terminal parameters"
                0x01: "get terminal parameters"
                0x02: "get configuration header and terminal parameters"
      }
      0x7E: "pcANYWHERE - COMMUNICATIONS I/O THROUGH PORT\nAL = subfunction: " { al ?
                0x01: "port input status"
                0x02: "port input character"
                0x03: "port output character in CX"
                0x11: "hang up phone"
      }
      0x7F: "pcANYWHERE - SET KEYBOARD/SCREEN MODE\nAL = subfunction: "  { al ?
                0x00: "enable remote keyboard only"
                0x01: "enable host keyboard only"
                0x02: "enable both keyboards"
                0x08: "display top 24 lines"
                0x09: "display bottom 24 lines"
                0x10: "Hayes modem"
                0x11: "other modem"
                0x12: "direct connect"
      }
      0x80: "MAKEY.COM - INSTALLATION CHECK\nReturn: AX = 1954h if installed"
      0xAA: "PTxxx.COM - (xxx=CGA,EGA,VGA,HER...) CALL GATE FOR GRAPHICS\nReturn: Graphics performed"
      0xF0: "Compaq 386 - SET CPU SPEED\nAL = speed" { al ?
                0x00: "equivalent to 6 MHz 80286 (COMMON)"
                0x01: "equivalent to 8 MHz 80286 (FAST)"
                0x02: "full 16 MHz (HIGH)\ntoggles between 8 MHz-equivalent and speed set by system board\nswitch (AUTO or HIGH)"
                0x08: "full 16 MHz except 8 MHz-equivalent during floppy disk access"
                0x09: "specify speed directly\nCX = speed value, 1 (slowest) to 50 (full), 3 ~= 8088"
      }
      0xF1: "Compaq 386 - READ CURRENT CPU SPEED\nReturn:       AL = speed code\nif AL = 09h, CX = speed code"
      0xF2: "Compaq 386 - DETERMINE ATTACHED KEYBOARD TYPE\nReturn: AL = type\n00h if 11-bit AT keyboard is in use\n01h if 9-bit PC keyboard is in use"
      0xF3: "Compaq 80286s - SET CPU SPEED LIMIT (OVERRIDE JUMPER)\nAL = 00h limit is 6 Mhz / 01h limit is 8 Mhz/6 Mhz"
      0xF4: "Compaq Systempro - " { al ?
            0x00: "CACHE CONTROLLER STATUS\nReturn: AH = E2h, AL = status"
            0x01: "ENABLE CACHE CONTROLLER\nReturn: AX = E201h"
            0x02: "DISABLE CACHE CONTROLLER\nReturn: AX = E202h"
      }
}
0x17:  { ah ?
      0x00: "PRINTER - OUTPUT CHARACTER\nAL = character, DX = printer port (0-3)\nReturn: AH = status bits"
      0x01: "PRINTER - INITIALIZE\nDX = printer port (0-3)\nReturn: AH = status"
      0x02: "PRINTER - GET STATUS\nDX = printer port (0-3)\nReturn: AH = status"
      0x60: "FLASHUP.COM - INSTALLATION CHECK\nReturn: AL = 60h, DX = CS of resident code"
      0x61: "SPEEDSCR.COM - INSTALLATION CHECK\nReturn: AL = 61h, DX = CS of resident code"
      0xC0: "PC Magazine PCSpool - GET CONTROL BLOCK ADDRESS\nDX = printer port (0-3)\nReturn: ES:BX -> control block"
      0xC1: "PC Magazine PCSpool - BUILD CONTROL RECORD\nDX = printer port (0-3), DS:SI -> ASCIIZ string to save for display"
      0xC2: "PC Magazine PCSpool - FLUSH PENDING WRITES\nDX = printer port (0-3)"
      0xC3: "PC Magazine PCSpool - CANCEL PRINTER QUEUE (FLUSH ALL QUEUED OUTPUT)\nDX = printer port (0-3)"
      0xC4: "PC Magazine PCSpool - QUERY SPOOLER ACTIVE\nReturn: DI = B0BFh, SI = segment"
      0xC5: "PC Magazine PCSpool - JOB SKIP PRINTER QUEUE\nDX = printer port (0-3)"
      0xC6: "PC Magazine PCSpool - CHECK PRINTER QUEUE STATUS\nDX = printer port (0-3)\nReturn: AX = 0 printer not active or at pause\n= 1 printer busy"
      0xC7: "PC Magazine PCSpool - CLOSE QUEUE\nDX = printer port (0-3)"
      0xCD: "INSET - " { al ?
            0x00: "EXECUTE COMMAND STRING\nDS:DX -> ASCIZ command string (max 80 bytes)\nReturn: CX = 07C2h (1986d)"
            0x01: "GET IMAGE SIZE\nDS:DX -> ASCIZ name of image file\nReturn: AX = height in 1/720th inch\nBX = width in 1/720th inch\nCX = 07C2h (1986d)"
            0x02: "INITIALIZE\nReturn: CX = 07C2h (1986d)"
            0x03: "EXECUTE INSET MENU WITHIN OVERRIDE MODE\nReturn: CX = 07C2h (1986d)"
            0x04: "INITIALIZE LINKED MODE\nES:DI -> FAR routine for linked mode\nReturn: CX = 07C2h"
            0x05: "START MERGING IMAGE INTO TEXT\nDS:DX -> ASCIZ name of PIX file\nReturn: AH = printer type\n00h page-oriented (multiple images may be placed side-by-side)\n01h line-oriented\nCX = 07C2h (1986d)"
            0x06: "GRAPHICS LINE FEED\nReturn: AH = completion status\n00h image complete\n01h image incomplete\nCX = 07C2h (1986d)"
            0x07: "FLUSH GRAPHICS FROM MERGE BUFFER\nReturn: CX = 07C2h"
            0x08: "CANCEL LINK MODE\nReturn: CX = 07C2h"
            0x09: "ALTER GRAPHICS LINE SPACING\nReturn: CX = 07C2h"
            0x0A: "GET SETUP\nDS:DX -> buffer for IN.SET data\nReturn: CX = 07C2h"
            0x0B: "INSET - START GETTING SCALED IMAGE\nDS:SI -> ASCIZ pathname of .PIX file\nBX = number of bitplanes, CX = number of rows in output bitmap\nDX = number of columns in output bitmap\nReturn: AX = status, 0000h OK, FFFFh error"
            0x0C: "INSET - GET NEXT IMAGE STRIP\nReturn:AX = status, 0000h OK but not complete\n0001h OK and image complete, FFFFh error\nDS:SI -> buffer (max 4K) for bit map strip\nCX = start row, DX = number of rows\nBX = offset in bytes between"
      }
}
0x18: "TRANSFER TO ROM BASIC\ncauses transfer to ROM-based BASIC (IBM-PC)\noften reboots a compatible; often has no effect at all"
0x19: "DISK BOOT\ncauses reboot of disk system"
0x1A: { ah ?
      0x00: "CLOCK - GET TIME OF DAY\nReturn: CX:DX = clock count\nAL = 00h if clock was read or written (via AH=0,1) since the previous\nmidnight\nOtherwise, AL > 0"
      0x01: "CLOCK - SET TIME OF DAY\nCX:DX = clock count\nReturn: time of day set"
      0x02: "CLOCK - READ REAL TIME CLOCK (AT,XT286,CONV,PS)\nReturn: CH = hours in BCD\nCL = minutes in BCD\nDH = seconds in BCD"
      0x03: "CLOCK - SET REAL TIME CLOCK (AT,XT286,CONV,PS)\nCH = hours in BCD, CL = minutes in BCD\n DH = seconds in BCD,DL = 01h if daylight savings, 00h if standard time\nReturn: CMOS clock set"
      0x04: "CLOCK - READ DATE FROM REAL TIME CLOCK (AT,XT286,CONV,PS)\nReturn: DL = day in BCD\nDH = month in BCD\nCL = year in BCD\nCH = century (19h or 20h)"
      0x05: "CLOCK - SET DATE IN REAL TIME CLOCK (AT,XT286,CONV,PS)\nDL = day in BCD, DH = month in BCD, CL = year in BCD\nCH = century (19h or 20h)\nReturn: CMOS clock set"
      0x06: "CLOCK - SET ALARM (AT,XT286,CONV,PS)\nCH = hours in BCD, CL = minutes in BCD\nDH = seconds in BCD\nReturn: CF set if alarm already set or clock inoperable\nINT 4Ah will be called when alarm goes off, every 24 hours until reset"
      0x07: "CLOCK - RESET ALARM (AT,XT286,CONV,PS)\nReturn: alarm disabled"
      0x08: "CLOCK - SET RTC ACTIVATED POWER ON MODE (CONVERTIBLE)\nCH = hours in BCD, CL = minutes in BCD\nDH = seconds in BCD"
      0x09: "CLOCK - READ RTC ALARM TIME AND STATUS (CONV,PS30)\nReturn: CH = hours in BCD\nCL = minutes in BCD\nDH = seconds in BCD\nDL = alarm status"
      0x0A: "CLOCK - READ SYSTEM-TIMER DAY COUNTER (XT2,PS)\nReturn: CF set on error\nCX = count of days since Jan 1,1980"
      0x0B: "CLOCK - SET SYSTEM-TIMER DAY COUNTER (XT2,PS)\nCX = count of days since Jan 1,1980\nReturn: CF set on error\nCF clear if successful"
      0x36: "WORD PERFECT 5.0 Third Party Interface - INSTALLATION CHECK\nReturn: DS:SI = routine to monitor keyboard input, immediately preceded by the\nASCIZ string \"WPCORP\""
      0x80: "PCjr - SET UP SOUND MULTIPLEXOR\nAL = " { al ?
               0x00: "source is 8253 channel 2"
               0x01: "source is cassette input"
               0x02: "source is I/O channel \"Audio IN\""
               0x03: "source is sound generator chip"
      }
     0xA0: "Disk Spool II - INSTALLATION CHECK\nReturn: AH = B0h, ES = code segment\nBX -> name of current spool file\nSI -> current despool file"
     0xB1: "PCI BIOS CALL" { al ?
               0x01: " - PCI BIOS Present\nReturn: CF clear on success\nEDX = 'PCI '\nAL = Hardware mechanism\nAH = 00h\nBH:BL Interface Level Major:Minor Version\nCL = last PCI bus in the system"
               0x02: " - Find PCI Device\nCX = Device ID\nDX = Vendor ID\nSI = Index\nReturn: CF set on error\nAH = error code\nBH = Bus Number\nBL = bits 7..3 Device Number, bits 2..0 Function Number"
               0x03: " - Find PCI Class Code\nECX = Class Code (low three bytes)\nSI = Index\nReturn: CF set on error\nAH = error code\nBH = Bus Number\nBL = bits 7..3 Device Number, bits 2..0 Function Number"
               0x06: " - Generate Special Cycle\nBH = Bus Number\nEDX = Special Cycle Data\nReturn: CF set on error\nAH = error code"
               0x08: " - Read Configuration Byte\nBH = Bus Number\nBL = bits 7..3 Device Number, bits 2..0 Function Number\nDI = Register Number (0...255)\nReturn: CL = Byte Read\nCF set on error\nAH = error code"
               0x09: " - Read Configuration Word\nBH = Bus Number\nBL = bits 7..3 Device Number, bits 2..0 Function Number\nDI = Register Number (0,2,...254)\nReturn: CX = Word Read\nCF set on error\nAH = error code"
               0x0A: " - Read Configuration Dword\nBH = Bus Number\nBL = bits 7..3 Device Number, bits 2..0 Function Number\nDI = Register Number (0,4,...252)\nReturn: ECX = Word Read\nCF set on error\nAH = error code"
               0x0B: " - Write Configuration Byte\nBH = Bus Number\nBL = bits 7..3 Device Number, bits 2..0 Function Number\nDI = Register Number (0...255)\nCL = Byte Value to Write\nReturn: CF set on error\nAH = error code"
               0x0C: " - Write Configuration Word\nBH = Bus Number\nBL = bits 7..3 Device Number, bits 2..0 Function Number\nDI = Register Number (0,2,...254)\nCX = Word Value to Write\nReturn: CF set on error\nAH = error code"
               0x0D: " - Write Configuration Dword\nBH = Bus Number\nBL = bits 7..3 Device Number, bits 2..0 Function Number\nDI = Register Number (0,4,...252)\nECX = Dword Value to Write\nReturn: CF set on error\nAH = error code"
               0x0E: " - Get PCI IRQ Routing Options\nBX = 0000h\nES:DI = Route Buffer\nReturn: CF set on error\nAH = error code\nBX = bitmap of IRQs dedicated to PCI devices"
               0x0F: " - Set PCI Hardware Interrupt\nCL = PCI Interrupt Pin (0Ah..0Dh)\nCH = IRQ Number (0-15)\nBH = Bus Number\nBL = bits 7..3 Device Number, bits 2..0 Function Number\nReturn: CF set on error\nAH = error code"
     }
     0xBB: "Trusted Computing Group call" { al ?
               0x00: " - TCG_StatusCheck\nReturn: EAX = 0 if supported\nEBX = 41504354h ('TCPA')\nCH:CL = TCG BIOS Version\nEDX = BIOS TCG Feature Flags\nESI = Pointer to Event Log\n"
               0x01: " - TCG_HashLogExtendEvent\nES:DI = HashLogExtendEvent input parameter block\nDS:SI = HashLogExtendEvent output parameter block\nEBX = 41504354h ('TCPA')\nReturn: EAX = Return Code"
               0x02: " - TCG_PassThroughToTPM\nES:DI = TPM input parameter block\nDS:SI = TPM output parameter block\nEBX = 41504354h ('TCPA')\nECX = 0\nReturn: EAX = Return Code"
               0x03: " - TCG_ShutdownPreBootInterface\nEBX = 41504354h ('TCPA')\nReturn: EAX = Return Code"
               0x04: " - TCG_HashLogEvent\nES:DI = LogEvent input parameter block\nDS:SI = LogEvent output parameter block\nEBX = 41504354h ('TCPA')\nECX = 0\nEDX = 0\nReturn: EAX = Return Code"
               0x05: " - TCG_HashAll\nES:DI = HashAll input parameter block\nDS:SI = pointer to Digest\nEBX = 41504354h ('TCPA')\nECX = 0\nEDX = 0\nReturn: EAX = Return Code"
               0x06: " - TCG_TSS\nES:DI = TSS input parameter block\nDS:SI = TSS output parameter block\nEBX = 41504354h ('TCPA')\nECX = 0\nEDX = 0\nReturn: EAX = Return Code"
               0x07: " - TCG_CompactHashLogExtendEvent\nES:DI = data buffer to be hashed\nESI = informative value to be places in event field\nEBX = 41504354h ('TCPA')\nECX = length of the buffer\nEDX = PCR number to which the hashed result is to be extended\nReturn: EAX = Return Code\nEDX = Event number of the event that was logged"
     }
     0xD0: "Disk Spool II - FUNCTION CALLS: " { al ?
               0x01: "enable spooler and despooler"
               0x02: "enable spooler only"
               0x03: "enable despooler at beginning of file"
               0x04: "disable the despooler"
               0x05: "disable the despooler and spooler"
               0x06: "clear the spool file"
               0x08: "inhibit the popup menu"
               0x09: "enable the popup menu"
               0x0B: "disable the spooler"
               0x0C: "start despooler after last successfully printed document"
               0x0D: "start despooler at the exact point where it last left off"
               0x0E: "pop up the menu"
               0x20: "clear file pointed to be the despooler"
     }
     0xFE: "AT&T 6300 - READ TIME AND DATE\nReturn: BX = day count (0 = Jan 1, 1984)\nCH = hour, CL = minute, DH = second, DL = hundredths"
     0xFF: "AT&T 6300 - SET TIME AND DATE\nBX = day count (0 = Jan 1, 1984)\nCH = hour, CL = minute, DH = second, DL = hundredths"
}
0x1B: "CTRL-BREAK KEY"
0x1C: "CLOCK TICK"
0x1D: "(NOT a vector!) 6845 VIDEO INIT TABLES"
0x1E: "(NOT a vector!) DISKETTE PARAMS (BASE TABLE)\ndefault parameters at F000h:EFC7h in PC and most compatibles"
0x1F: "(NOT a vector!) GRAPHICS SET 2\npointer to bitmaps for high 128 chars (eight bytes per character)"
0x20: {
    op2 ?
#include "vxd.cmt"
  0xFFFFFFFE: "DOS - PROGRAM TERMINATION\nreturns to DOS--identical to INT 21/AH=00h"
}
0x21: "DOS - " { ah ?
      0x00: "PROGRAM TERMINATION"
      0x01: "KEYBOARD INPUT\nReturn: AL = character read"
      0x02: "DISPLAY OUTPUT\nDL = character to send to standard output"
      0x03: "AUX INPUT"
      0x04: "AUX OUTPUT\nDL = character to send"
      0x05: "PRINTER OUTPUT\nDL = character to print"
      0x06: "DIRECT CONSOLE I/O CHARACTER OUTPUT\nDL = character <> FFh\n Return: ZF set = no character\n  ZF clear = character recieved, AL = character"
      0x07: "DIRECT STDIN INPUT, NO ECHO"
      0x08: "KEYBOARD INPUT, NO ECHO\nReturn: AL = character"
      0x09: "PRINT STRING\nDS:DX -> string terminated by \"$\""
      0x0A: "BUFFERED KEYBOARD INPUT\nDS:DX -> buffer"
      0x0B: "CHECK STANDARD INPUT STATUS\nReturn: AL = FFh if character available\n00h if no character"
      0x0C: "CLEAR KEYBOARD BUFFER\nAL must be 01h, 06h, 07h, 08h, or 0Ah."
      0x0D: "DISK RESET"
      0x0E: "SELECT DISK\nDL = new default drive number (0 = A, 1 = B, etc.)\nReturn: AL = number of logical drives"
      0x0F: "OPEN DISK FILE\nDS:DX -> FCB\nReturn: AL = 00h file found, FFh file not found"
      0x10: "CLOSE DISK FILE\nDS:DX -> FCB\nReturn: AL = 00h directory update successful\nFFh file not found in directory"
      0x11: "SEARCH FIRST USING FCB\nDS:DX -> FCB"
      0x12: "SEARCH NEXT USING FCB\nDS:DX -> FCB\nReturn: AL = status"
      0x13: "DELETE FILE via FCB\nDS:DX -> FCB with filename field filled with\ntemplate for  deletion ('?' wildcard allowed, but not '*')\nReturn: AL = 00h file found, FFh file not found"
      0x14: "SEQUENTIAL DISK FILE READ\nDS:DX -> FCB"
      0x15: "SEQUENTIAL DISK RECORD WRITE\nDS:DX -> FCB"
      0x16: "CREATE A DISK FILE\nDS:DX -> FCB"
      0x17: "RENAME FILE via FCB\nDS:DX -> FCB\nFCB contains new name starting at byte 17h."
      0x18: "internal - UNUSED"
      0x19: "GET DEFAULT DISK NUMBER"
      0x1A: "SET DISK TRANSFER AREA ADDRESS\nDS:DX -> disk transfer buffer"
      0x1B: "GET ALLOCATION TABLE INFORMATION FOR DEFAULT DRIVE\nReturn: DS:BX -> FAT ID byte for default drive"
      0x1C: "GET ALLOCATION TABLE INFORMATION FOR SPECIFIC DRIVE\nDL = drive number to check (0=default, 1=A, etc)"
      0x1D: " UNUSED"
      0x1E: " UNUSED"
      0x1F: " GET DEFAULT DRIVE PARAMETER BLOCK\nReturn: AL = 00h No Error, FFh Error\nDS:BX -> drive parameter block"
      0x20: "UNUSED"
      0x21: "RANDOM DISK RECORD READ\nDS:DX -> FCB"
      0x22: "RANDOM DISK RECORD WRITE\nDS:DX -> FCB"
      0x23: "GET FILE SIZE\nDS:DX -> unopened FCB with filename and record size\nfields initialized"
      0x24: "SET RANDOM RECORD FIELD\nDS:DX -> open FCB"
      0x25: "SET INTERRUPT VECTOR\nAL = interrupt number\nDS:DX = new vector to be used for specified interrupt"
      0x26: "CREATE PSP\nDX = segment number at which to set up PSP"
      0x27: "RANDOM BLOCK READ\nDS:DX -> FCB\nCX = number of records to be read"
      0x28: "RANDOM BLOCK WRITE\nDS:DX -> FCB\nCX = number of records to be written\nif zero, truncate file to current random file position"
      0x29: "PARSE FILENAME\nDS:SI -> string to parse\nES:DI -> buffer to fill with unopened FCB\nAL = bit mask to control parsing"
      0x2A: "GET CURRENT DATE\nReturn: DL = day, DH = month, CX = year\nAL = day of the week (0=Sunday, 1=Monday, etc.)"
      0x2B: "SET CURRENT DATE\nDL = day, DH = month, CX = year\nReturn: AL = 00h if no error /= FFh if bad value sent to routine"
      0x2C: "GET CURRENT TIME\nReturn: CH = hours, CL = minutes, DH = seconds\nDL = hundredths of seconds"
      0x2D: "SET CURRENT TIME\nCH = hours, CL = minutes, DH = seconds, DL = hundredths of seconds\nReturn: AL = 00h if no error / = FFh if bad value sent to routine"
      0x2E: "SET VERIFY FLAG\nDL = 00h, AL = 01h VERIFY on / 00h VERIFY off"
      0x2F: "GET DISK TRANSFER AREA ADDRESS\nReturn: ES:BX -> DTA"
      0x30: "GET DOS VERSION\nReturn: AL = major version number (00h for DOS 1.x)"
      0x31: "DOS 2+ - TERMINATE BUT STAY RESIDENT\nAL = exit code, DX = program size, in paragraphs"
      0x32: "2+ internal - GET DRIVE PARAMETER BLOCK\nDL = drive number, 0 = default, 1 = A, etc."
      0x33: { al ?
            0x03: "3.4+ Get Current CPSW state"
            0x04: "3.4+ Set CPSW state"
            0x05: "4+ Get Boot Drive (DL = boot drive, 1 = A:, ...)"
            0x06: "5+ Get TRUE Version Number (BL major, BH minor, DL revision, DH flags)"
            0x07: "7+ SET/CLEAR DOS FLAG (DL = 0 clear, 1 - set)"
            other: "EXTENDED CONTROL-BREAK CHECKING\n"
                   "AL = 00h get state / 01h set state / 02h set AND get\n"
                   "DL = 00h for OFF or 01h for ON"
      }
      0x34: "2+ internal - RETURN CritSectFlag (InDOS) POINTER"
      0x35: "2+ - GET INTERRUPT VECTOR\nAL = interrupt number\nReturn: ES:BX = value of interrupt vector"
      0x36: "2+ - GET DISK SPACE\nDL = drive code (0 = default, 1 = A, 2 = B, etc.)"
      0x37: "2+ internal - GET SWITCHAR/AVAILDEV\n" { al ?
            0x00: "Return: AL = FFh unsupported subfunction\nDL = current switch character"
            0x01: "DL = new switch character"
            0x02: "read device availability (as set by AL=03h)\nReturn: DL = device availability (always FFh under DOS 4.0)"
            0x03: "set device availability, where:\nDL = 00h means \DEV\ must preceed device names\nDL <> 00h means \DEV\ need not preceed device names"
      }
      0x38: "2+ - GET COUNTRY-DEPENDENT INFORMATION\n" { al ?
            0x00: "get current-country info\nDS:DX -> buffer for returned info"
            0x01: "thru 0FEh for specific country with code <255"
            0xFF: "for specific country with code >= 255\nBX = 16-bit country code, DX = FFFFh"
      }
      0x39: "2+ - CREATE A SUBDIRECTORY (MKDIR)\nDS:DX -> ASCIZ pathname (may include drive)"
      0x3A: "2+ - REMOVE A DIRECTORY ENTRY (RMDIR)\nDS:DX -> ASCIZ pathname (may include drive)"
      0x3B: "2+ - CHANGE THE CURRENT DIRECTORY (CHDIR)\nDS:DX -> ASCIZ directory name (may include drive)"
      0x3C: "2+ - CREATE A FILE WITH HANDLE (CREAT)\n"
            "CX = attributes for file\n"
            "DS:DX -> ASCIZ filename (may include drive and path)"
      0x3D: "2+ - OPEN DISK FILE WITH HANDLE\n"
            "DS:DX -> ASCIZ filename\n"
            "AL = access mode\n" { al ?
              0: "0 - read"
              1: "1 - write"
              2: "2 - read & write"
              other: "0 - read, 1 - write, 2 - read & write"
            }
      0x3E: "2+ - CLOSE A FILE WITH HANDLE\nBX = file handle"
      0x3F: "2+ - READ FROM FILE WITH HANDLE\nBX = file handle, CX = number of bytes to read\nDS:DX -> buffer"
      0x40: "2+ - WRITE TO FILE WITH HANDLE\nBX = file handle, CX = number of bytes to write, DS:DX -> buffer"
      0x41: "2+ - DELETE A FILE (UNLINK)\nDS:DX -> ASCIZ pathname of file to delete (no wildcards allowed)"
      0x42: "2+ - MOVE FILE READ/WRITE POINTER (LSEEK)\nAL = method: " { al ?
                0x00: "offset from beginning of file"
                0x01: "offset from present location"
                0x02: "offset from end of file"
                other: "\n0-from beginnig,1-from current,2-from end"
      }
      0x43: { al ?
            0x00: "2+ - GET FILE ATTRIBUTES\n"
                  "DS:DX -> ASCIZ file name or directory\n"
                  "name without trailing slash"
            0x01: "2+ - SET FILE ATTRIBUTES\n"
                  "DS:DX -> ASCIZ file name\n"
                  "CX = file attribute bits"
      }
      0x44: "2+ - IOCTL - " { al ?
            0x00: "GET DEVICE INFORMATION\nBX = file or device handle"
            0x01: "SET DEVICE INFORMATION\nBX = device handle, DH = 0\nDL = device information to set (bits 0-7 from function 0)"
            0x02: "READ CHARACTER DEVICE CONTROL STRING\nBX = device handle, CX = number of bytes to read DS:DX -> buffer"
      }
      0x45: "2+ - CREATE DUPLICATE HANDLE (DUP)\nBX = file handle to duplicate"
      0x46: "2+ - FORCE DUPLICATE HANDLE (FORCDUP,DUP2)\nBX = existing file handle, CX = new file handle"
      0x47: "2+ - GET CURRENT DIRECTORY\nDL = drive (0=default, 1=A, etc.)\nDS:SI points to 64-byte buffer area"
      0x48: "2+ - ALLOCATE MEMORY\nBX = number of 16-byte paragraphs desired"
      0x49: "2+ - FREE MEMORY\nES = segment address of area to be freed"
      0x4A: "2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)\nES = segment address of block to change\nBX = new size in paragraphs"
      0x4B: "2+ - LOAD OR EXECUTE (EXEC)\n"
            "DS:DX -> ASCIZ filename\n"
            "ES:BX -> parameter block\n"
            "AL = subfunc: " { al ?
            0x00: "load & execute program"
            0x01: "load but do not execute (internal)"
            0x02: "load overlay; do not create PSP\n"
            0x03: "called by MSC spawn(P_NOWAIT,...) when running DOS 4.x."
            other: "0-exec,1-load,2-overlay,3-MSC spawn"
      }
      0x4C: "2+ - QUIT WITH EXIT CODE (EXIT)\n"
            "AL = exit code"
      0x4D: "2+ - GET EXIT CODE OF SUBPROGRAM (WAIT)"
      0x4E: "2+ - FIND FIRST ASCIZ (FINDFIRST)\n"
            "CX = search attributes\n"
            "DS:DX -> ASCIZ filespec\n"
            "(drive, path, and wildcards allowed)"
      0x4F: "2+ - FIND NEXT ASCIZ (FINDNEXT)\n"
            "[DTA] = data block from\n"
            "last AH = 4Eh/4Fh call"
      0x50: "2+ internal - SET PSP SEGMENT\nBX = segment address of new PSP"
      0x51: "2+ internal - GET PSP SEGMENT\nReturn: BX = current PSP segment"
      0x52: "2+ internal - GET LIST OF LISTS\nReturn: ES:BX -> DOS list of lists"
      0x53: "2+ internal - TRANSLATE BIOS PARAMETER BLOCK\nDS:SI -> BPB (BIOS Parameter Block)\nES:BP -> buffer for DOS Drive Parameter Block"
      0x54: "2+ - GET VERIFY FLAG\nReturn: AL = 00h if flag OFF\nAL = 01h if flag ON"
      0x55: "2+ internal - CREATE PSP\nDX = segment number at which to set up PSP\nSI = (DOS 3+) value to place in memory size field at DX:[0002h]"
      0x56: "2+ - RENAME A FILE\nDS:DX -> ASCIZ old name (drive and path allowed, no wildcards)\nES:DI -> ASCIZ new name"
      0x57: "2+ - " { al ?
            0x00: "GET FILE'S DATE/TIME\nBX = file handle"
            0x01: "SET FILE'S DATE/TIME\nBX = file handle, CX = time to be set\nDX = date to be set"
            0x02: "4.0 - GET ???\nBX = ??? (0000h through 0004h)\nDS:SI -> ???, ES:DI -> result buffer\nCX = size of result buffer"
            0x03: "4.0 - GET ???\nBX = ??? (0000h through 0004h)\nDS:SI -> ???, ES:DI -> result buffer\nCX = size of result buffer"
            0x04: "4.0 - ???\nBX = ??? (0000h through 0004h)\nDS:SI -> ???, ES:DI -> result buffer\nCX = size of result buffer"
      }
      0x58: "3+ - GET/SET MEMORY ALLOCATION STRATEGY\nAL = function code: " { al ?
                0x00: "get allocation strategy"
                0x01: "set allocation strategy"
                0x02: "(DOS 5beta) get UMB link state"
                0x03: "(DOS 5beta) set UMB link state"
      }
      0x59: "3+ - GET EXTENDED ERROR CODE\nBX = version code (0000h for DOS 3.x)"
      0x5A: "3+ - CREATE UNIQUE FILE\nDS:DX -> ASCIZ directory path name ending with a '\' + 13 bytes to\nreceive generated filename\nCX = file attributes (only bits 0,1,2,5 may be set)"
      0x5B: "3+ - CREATE NEW FILE\nDS:DX -> ASCIZ directory path name\nCX = file attribute"
      0x5C: "3+ - LOCK/UNLOCK FILE ACCESS\nAL = 00h lock / 01h unlock\nBX = file handle, CX:DX = starting offset of region to lock\nSI:DI = size of region to lock"
      0x5D: "3.1+ internal - " { al ?
            0x00: "SERVER FUNCTION CALL\nDS:DX -> DOS parameter list\nDPL contains all register values for a call to INT 21h"
            0x01: "COMMIT ALL FILES FOR SPECIFIED COMPUTER/PROCESS\nDS:DX -> DOS parameter list, only computer ID and\nprocess ID fields used"
            0x02: "SHARE.EXE - CLOSE FILE BY NAME\nDS:DX -> DOS parameter list, only fields DX, DS,\ncomputer ID, and process ID used\nDPL's DS:DX -> ASCIZ name of file to close"
            0x03: "SHARE.EXE - CLOSE ALL FILES FOR GIVEN COMPUTER\nDS:DX -> DOS parameter list, only computer ID used"
            0x04: "SHARE.EXE - CLOSE ALL FILES FOR GIVEN PROCESS\nDS:DX -> DOS parameter list, only computer ID and\nprocess ID fields used"
            0x05: "SHARE.EXE - GET OPEN FILE LIST ENTRY\nDS:DX -> DOS parameter list\nDPL's BX = index of sharing record\nDPL's CX = index of SFT in sharing record's SFT list"
            0x06: "GET ADDRESS OF DOS SWAPPABLE DATA AREA\nReturn: CF set on error, CF clear if successful"
            0x07: "GET REDIRECTED PRINTER MODE\nReturn: DL = 00h redirected output is combined,\n             01h redirected output in separate print jobs"
            0x08: "SET REDIRECTED PRINTER MODE\nDL = 00h redirected output is combined\n     01h redirected output placed in separate jobs\nstart new print job now"
            0x09: "FLUSH REDIRECTED PRINTER OUTPUT"
            0x0A: "SET EXTENDED ERROR INFORMATION\nDS:DX -> 11-word DOS parameter list"
            0x0B: "4.x internal - GET DOS SWAPPABLE DATA AREAS"
      }
      0x5E: "3.1 + Microsoft Networks - " { al ?
            0x00: "GET MACHINE NAME\nDS:DX -> buffer for blank-padded ASCIZ name (16 bytes)"
            0x01: "SET MACHINE NAME\nCH = 00h undefine name,  <> 0  define name, CL = name number\nDS:DX -> 15-character blank-padded ASCIZ name"
            0x02: "SET PRINTER SETUP\nBX = redirection list index\nCX = length of setup string (<= 64)\nDS:SI -> string buffer"
            0x03: "GET PRINTER SETUP\nBX = redirection list index\nES:DI -> string buffer"
            0x04: "SET PRINTER MODE\nBX = redirection list index\nDX = mode"
            0x05: "GET PRINTER MODE\nBX = redirection list index"
      }
      0x5F: { al ?
            0x00: "3.1+ network - GET REDIRECTION MODE\nBL = 03h printer / 04h disk drive"
            0x01: "3.1+ network - SET REDIRECTION MODE\nBL = 03h printer / 04h disk drive\nBH = 00h off / 01h on"
            0x02: "3.1 + Microsoft Networks, VINES - GET REDIRECTION LIST ENTRY\nBX = redirection list index\nDS:SI -> 16 char local device name buffer\nES:DI -> 128 char network name buffer"
            0x03: "3.1 + Microsoft Networks, Banyan VINES - REDIRECT DEVICE\nBL = 03h = printer device / 04h = file device\nCX = stored parameter value, DS:SI -> ASCIZ source device name\nES:DI -> destination ASCIZ network path + ASCIZ password"
            0x04: "3.1 + Microsoft Networks, Banyan VINES - CANCEL REDIRECTION\nDS:SI -> ASCIZ device name or network path"
            0x05: "3.1 + Microsoft Networks, GET REDIRECTION LIST EXTENDED ENTRY\nBX = redirection list index\nDS:SI -> buffer for ASCIZ source device name\nES:DI -> buffer for destination ASCIZ network path"
            0x06: "STARLITE architecture - UNMAP DRIVE LETTER\nDL = drive to be unmapped (0=A:)"
            0x07: "STARLITE architecture - MAKE NAMED OBJECT AVAILABLE ON NETWORK\nDS:SI -> ASCIZ name of object to offer to network\nES:DI -> ASCIZ name under which object will be known on the network\nMUST begin with three slashes"
            0x08: "STARLITE architecture - REMOVE GLOBAL NETWORK NAME OF OBJECT\nDS:SI -> ASCIZ network name (not local name) of object to unshare"
            0x09: "STARLITE architecture - BIND TO NETWORK DEVICE\nDS:DX -> ASCIZ name of the device driver to attach to"
            0x0A: "STARLITE architecture - DETACH FROM NETWORK DEVICE\nDS:DX -> ASCIZ name of device driver to detach from"
            0x80: "- LANtastic - GET LOGIN ENTRY\nBX = login entry index (0-based)\nES:DI -> 16-byte buffer for machine name"
            0x81: "- LANtastic - LOGIN TO SERVER\nES:DI -> ASCIZ login path followed immediately by ASCIZ password\nBL = adapter number, FFh try all valid adapters\n00h-03h try only specified adapter"
            0x82: "- LANtastic - LOGOUT FROM SERVER\nES:DI -> ASCIZ server name"
            0x83: "- LANtastic - GET USERNAME ENTRY\nBX = login entry index (0-based)\nES:DI -> 16-byte buffer for username currently logged into"
            0x84: "- LANtastic - GET INACTIVE SERVER ENTRY\nBX = server index not currently logged into\nES:DI -> 16-byte buffer for server name which is available for logging"
            0x85: "- LANtastic - CHANGE PASSWORD\nES:DI -> buffer containing"
            0x86: "- LANtastic - DISABLE ACCOUNT\nES:DI -> ASCIZ machine name and password in form"
            0x87: "- LANtastic - GET ACCOUNT\nDS:SI -> 128-byte buffer for account information\nES:DI -> ASCIZ machine name in form \"machine\""
            0x97: "- LANtastic - COPY FILE\nCX:DX = number of bytes to copy (FFFFFFFFh = entire file)\nSI = source file handle, DI = destination file handle"
            0x98: "- LANtastic - SEND UNSOLICITED MESSAGE\nDS:SI -> message buffer"
            0x99: "- LANtastic - GET LAST RECEIVED UNSOLICITED MESSAGE\nES:DI -> messsage buffer"
            0x9A: "- LANtastic - GET MESSAGE PROCESSING FLAG"
            0x9B: "- LANtastic - SET MESSAGE PROCESSING FLAG\nDL = bits describing processing for received unsolicited messages\n"
            0x9C: "- LANtastic - POP UP LAST RECEIVED MESSAGE\nCX = time to leave on screen in clock ticks\nDH = 0-based screen line on which to place message"
            0xA0: "- LANtastic - GET QUEUE ENTRY\nBX = queue entry index (0000h is first entry)\nDS:SI -> buffer for queue entry\nES:DI -> ASCIZ server name in form \"name\""
            0xA1: "- LANtastic - SET QUEUE ENTRY\nBX = handle of opened queue entry\nDS:SI -> queue entry"
            0xA2: "- LANtastic - CONTROL QUEUE\nCX:DX = sequence number to control (commands 06h-09h)\nDX = physical printer number (commands 00h-05h)\nES:DI -> ASCIZ computer name\nBL = control command - \n" { bl ?
                  0x00: "start despooling (privileged)"
                  0x01: "halt despooling (privileged)"
                  0x02: "halt despooling at end of job (privileged)"
                  0x03: "pause despooler at end of job (privileged)"
                  0x04: "print single job (privileged)"
                  0x05: "restart current job (privileged)"
                  0x06: "cancel the current job"
                  0x07: "hold queue entry"
                  0x08: "release a held queue entry"
                  0x09: "make queue entry a rushed job (privileged)"
            }
            0xA3: "- LANtastic - GET PRINTER STATUS\nBX = physical printer number (00h-02h = LPT1-LPT3, 03h-04h = COM1-COM2)\nDS:SI -> buffer for printer status\nES:DI -> ASCIZ server name in form \"machine\""
            0xA4: "- LANtastic - GET STREAM INFO\nBX = 0-based stream index number\nDS:SI -> buffer for stream information\nES:DI -> ASCIZ machine name in form \"machine\""
            0xA5: "- LANtastic - SET STREAM INFO\nBX = 0-based stream index number\nDS:SI -> buffer containing stream information\nES:DI -> ASCIZ machine name in form \"machine\""
            0xA7: "- LANtastic - CREATE USER AUDIT ENTRY\nDS:DX -> ASCIZ reason code (max 8 bytes)\nDS:SI -> ASCIZ variable reason code (max 128 bytes)\nES:DI -> ASCIZ machine name in form \"machine\""
            0xB0: "- LANtastic - GET ACTIVE USER INFORMATION\nBX = server login entry index\nDS:SI -> buffer for active user entry\nES:DI -> ASCIZ machine name in form \"server\""
            0xB1: "- LANtastic - GET SHARED DIRECTORY INFORMATION\nDS:SI -> 64-byte buffer for link description\nES:DI -> ASCIZ machine and shared directory name in form"
            0xB2: "- LANtastic - GET USERNAME FROM ACCOUNT FILE\nBX = username entry index (0 for first)\nDS:SI -> 16-byte buffer for username\nES:DI -> ASCIZ server name in form \"machine\""
            0xB3: "- LANtastic - TRANSLATE PATH\nDS:SI -> 128-byte buffer for ASCIZ result\nES:DI -> full ASCIZ path, including server name\nDX = types of translation to be performed"
            0xB4: "- LANtastic - CREATE INDIRECT FILE\nDS:SI -> 128-byte buffer containing ASCIZ contents of indirect file\nES:DI -> full ASCIZ path of indirect file to create, incl machine name"
            0xB5: "- LANtastic - GET INDIRECT FILE CONTENTS\nDS:SI -> 128-byte buffer for ASCIZ indirect file contents\nES:DI -> full ASCIZ path of indirect file"
            0xC0: "- LANtastic - GET TIME FROM SERVER\nDS:SI -> time block\nES:DI -> ASCIZ server name to get time from"
            0xD0: "- LANtastic - GET REDIRECTED PRINTER TIMEOUT"
            0xD1: "- LANtastic - SET REDIRECTED PRINTER TIMEOUT\nCX = printer timeout in clock ticks of 55ms, 0000h to disable timeouts"
            0xE0: "- LANtastic - GET DOS SERVICE VECTOR"
            0xE1: "SET DOS SERVICE VECTOR\nES:BX -> FAR routine to call for DOS service"
            0xE2: "- LANtastic - GET MESSAGE SERVICE VECTOR"
            0xE3: "- LANtastic - SET MESSAGE SERVICE VECTOR\nES:BX -> FAR routine for processing network messages"
      }
      0x60: "RESOLVE PATH STRING TO CANONICAL PATH STRING\nDS:SI -> ASCIZ relative path string or directory name\nES:DI -> 128-byte buffer for ASCIZ canonical fully qualified name"
      0x61: "3+internal - UNUSED"
      0x62: "3+ - GET PSP ADDRESS"
      0x63: "2.25 only - GET LEAD BYTE TABLE (2-BYTE CHARACTER SUPPORT)\nAL = " { al ?
                0x00: "get system lead byte table"
                0x01: "set/clear interim console flag"
                0x02: "get interim console flag"
      }
      0x63: "3.2+ only - " { al ?
            0x00: "GET DOUBLE BYTE CHARACTER SET LEAD TABLE"
            0x01: "SET KOREAN (HONGEUL) INPUT MODE\nDL = new mode\n00h return only full characters on DOS keyboard input functions\n01h return partially-formed characters also"
            0x02: "GET KOREAN (HONGEUL) INPUT MODE"
      }
      //?*?
      0x64: "3.2 internal - GET/SET ???\nAL = subfunction: " { al ?
                0x00: "get ???"
                0x01: "set ???"
                0x02: "get and set ???"
      }
      0x64: "3.3+ internal - SET ???\nAL = 00h  ??? / nonzero  ???"
      //?*?
      0x65: "3.3+ - GET EXTENDED COUNTRY INFORMATION\n"
            "CX = size of buffer (>= 5)\n"
            "BX = code page, DX = country ID\n"
            "ES:DI -> country information buffer\n"
            "AL = info ID - " { al ?
                0x01: "get general internationalization info"
                0x02: "get pointer to uppercase table"
                0x04: "get pointer to filename uppercase table"
                0x05: "(DOS 3.3+ internal) get pointer to filename terminator table"
                0x06: "get pointer to collating sequence table"
                0x07: "(DOS 4.x) get pointer to Double-Byte Character Set table"
      }
      0x65: "4.x internal - COUNTRY-DEPENDENT CHARACTER CAPITALIZATION\nDS:DX -> ASCIZ string to capitalize\nAL = function - " { al ?
                0x20: "capitalize character"
                0x21: "capitalize string"
                0x22: "capitalize ASCIZ string"
            }
      0x65: { al ? 0x23: "4.x internal - DETERMINE IF CHARACTER REPRESENTS YES/NO RESPONSE\nDL = character\nDH = second character of double-byte character (if applicable)" }
      0x65: "4.x internal - COUNTRY-DEPENDENT FILENAME CAPITALIZATION\nAL = function - " { al  ?
                0xA0: "capitalize filename character\nDL = character to capitalize"
                0xA1: "capitalize counted filename string\nDS:DX -> filename string to capitalize\nCX = length of string"
                0xA2: "capitalize ASCIZ filename\nDS:DX -> ASCIZ filename to capitalize"
      }
      0x66: "3.3+ - " { al ?
            0x01: "GET GLOBAL CODE PAGE TABLE"
            0x02: "SET GLOBAL CODE PAGE TABLE\nBX = active code page \nDX = system code page (active page at boot time)"
      }
      0x67: "3.3+ - SET HANDLE COUNT\nBX = desired number of handles (max 255)"
      0x68: "3.3+ - COMMIT FILE, WRITE ALL BUFFERED DATA TO DISK\nBX = file handle"
      0x69: "4.0 internal - GET/SET DISK SERIAL NUMBER\nAL = 00h get serial number / 01h set serial number\nBL = drive (0=default, 1=A, 2=B, etc)\nDS:DX -> disk info"
      0x6A: "4.0 internal - ???"
      0x6B: "4.0 internal - ???"
      0x6C: "4.0 - EXTENDED OPEN/CREATE\nBL = open mode as in AL for normal open (INT 21h/AH=3Dh)\nBH = flags, CX = create attribute, DL = action if file exists/does not exists\nDH = 00h (reserved), DS:SI -> ASCIZ file name"
      0xA0: "Extra - GET 3270 DISPLAY STATE"
      0xA1: "Extra - SET 3270 DISPLAY STATE\nAL = set status byte"
      0xA2: "Extra - SET HOST WINDOW STATE\nAL = set status byte"
      0xA3: "Extra - SEND KEYSTROKES TO HOST WINDOW\nAL = window number (1-4=host B-E)\nCX = 0001h, DS:BX -> keystroke buffer\nDL = zero if keystroke buffer contains host function code,\n     non-zero if keyYroke buffer contains ASCII character"
      0xA4: "Extra - GET HOST WINDOW BUFFER ADDRESS\nAL = window number (1-4=host B-E)"
      0xA5: "Extra - GET HOST WINDOW CURSOR POSITION\nAL = window number (1-4=host B-E)"
      0xAF: "Extra - GET TRANSLATE TABLE ADDRESS"
      0xB5: "NetWare shell 3.01 - TASK MODE CONTROL\nAL = 03h get task mode / 04h get task mode pointer"
      0xB6: "Novell NetWare SFT Level II - EXTENDED FILE ATTRIBUTES\nAL = 00h get extended file attributes / 01h set extended file attributes\nCL = attributes, DS:DX -> ASCIZ pathname"
      0xB8: "Novell Advanced NetWare 2.0+ - PRINT JOBS\nCX = buffer size ES:BX -> buffer\nAL = subfunction - " { al ?
                0x00: "get default print job flags"
                0x01: "set default capture flags"
                0x02: "get specific capture flags"
                0x03: "set specific print job flags"
                0x04: "get default local printer"
                0x05: "set default local printer"
                0x06: "set capture print queue"
                0x07: "set capture print job"
                0x08: "get banner user name"
                0x09: "set banner user name"
      }
      0xBB: "Novell NetWare 4.0 - SET END OF JOB STATUS\nAL = 00h disable EOJs / otherwise enable EOJs"
      0xBC: "Novell NetWare 4.6 - LOG/LOCK PHYSICAL RECORD\nAL = bit 0: lock as well as log record / 1: non-exclusive lock\nBX = file handle, CX:DX = offset\nBP = timeout in timer ticks (1/18 sec), SI:DI = length"
      0xBD: "Novell NetWare 4.6 - RELEASE PHYSICAL RECORD\nBX = file handle, CX:DX = offset"
      0xBE: "Novell NetWare 4.6 - CLEAR PHYSICAL RECORD\nBX = file handle, CX:DX = offset"
      0xBF: "Novell NetWare 4.6 - LOG/LOCK RECORD (FCB)\nAL = bit 0: lock as well as log record / 1: non-exclusive lock\nDS:DX -> FCB, BX:CX = offset\nBP = timeout in timer ticks (1/18 sec), SI:DI = length"
      0xC0: "Novell NetWare 4.6 - RELEASE RECORD (FCB)\nDS:DX -> FCB, BX:CX = offset"
      0xC1: "Novell NetWare 4.6 - CLEAR RECORD (FCB)\nDS:DX -> FCB, BX:CX = offset"
      0xC2: "Novell NetWare 4.6 - LOCK PHYSICAL RECORD SET\nAL = bit 1: non-exclusive lock\nBP = timeout in timer ticks (1/18 sec)"
      0xC3: "Novell NetWare 4.6 - RELEASE PHYSICAL RECORD SET"
      0xC4: "Novell NetWare 4.6 - CLEAR PHYSICAL RECORD SET"
      0xC5: "Novell NetWare 4.6 - SEMAPHORES\nAL = subfunction - " { al ?
                0x00: "open semaphore"
                0x01: "examine semaphore"
                0x02: "wait on semaphore"
                0x03: "signal semaphore"
                0x04: "close semaphore"
      }
      0xC6: "Novell NetWare 4.6 - GET OR SET LOCK MODE\nAL = subfunction - " { al ?
                0x00: "set old \"compatibility\" mode"
                0x01: "set new extended locks mode"
                0x02: "get lock mode"
      }
      0xC7: "Novell NetWare 4.0 - TTS\nAL = subfunction - " { al ?
                0x00: "begin transaction (NetWare SFT level II)"
                0x01: "end transaction (NetWare SFT level II)"
                0x02: "TTS available (NetWare SFT level II)"
                0x03: "abort transaction (NetWare SFT level II)"
                0x04: "transaction status"
                0x05: "get application thresholds"
                0x06: "set application thresholds"
                0x07: "get workstation thresholds"
                0x08: "set workstation thresholds"
      }
      0xC8: "Novell NetWare 4.0 - BEGIN LOGICAL FILE LOCKING\nif function C6h lock mode 00h: DL = 00h no wait / 01h wait\nif function C6h lock mode 01h: BP = timeout in timer ticks (1/18 sec)"
      0xC9: "Novell NetWare 4.0 - END LOGICAL FILE LOCKING"
      0xCA: "Novell NetWare 4.0 - LOG/LOCK PERSONAL FILE (FCB)\nif function C6h lock mode 01h: AL = 00h log file only / 01h lock as well as log file\nBP = timeout in timer ticks (1/18 sec), DS:DX -> FCB"
      0xCB: "Novell NetWare 4.0 - LOCK FILE SET\nif function C6h lock mode 00h: DL = 00h no wait / 01h wait\nif function C6h lock mode 01h: BP = timeout in timer ticks (1/18 sec)"
      0xCC: "Novell NetWare 4.0 - RELEASE FILE (FCB)\nDS:DX -> FCB"
      0xCD: "Novell NetWare 4.0 - RELEASE FILE SET"
      0xCE: "Novell NetWare 4.0 - CLEAR FILE (FCB)\nDS:DX -> FCB"
      0xCF: "Novell NetWare 4.0 - CLEAR FILE SET"
      0xD0: "Novell NetWare 4.6, Banyan VINES - LOCK LOGICAL RECORD\nDS:DX -> record string"
      0xD1: "Novell NetWare 4.6, Banyan VINES - LOCK LOGICAL RECORD SET\nif function C6h lock mode 00h: DL = 00h no wait / 01h wait\nif function C6h lock mode 01h: (Novell only)\nBP = timeout in timer ticks (1/18 sec)"
      0xD2: "Novell NetWare 4.0, Banyan VINES - UNLOCK LOGICAL RECORD\nDS:DX -> semaphore identifier (counted string up to 100 chars long)"
      0xD3: "Novell NetWare 4.0, Banyan VINES - UNLOCK LOGICAL RECORD SET"
      0xD4: "Novell NetWare 4.0, Banyan VINES - CLEAR LOGICAL RECORD\nDS:DX -> semaphore identifier (counted string up to 100 chars long)"
      0xD5: "Novell NetWare 4.0, Banyan VINES - CLEAR LOGICAL RECORD SET"
      0xD6: "Novell NetWare 4.0 - END OF JOB"
      0xD7: "Novell NetWare 4.0 - SYSTEM LOGOUT"
      0xD8: "Novell NetWare, Banyan VINES - ALLOCATE RESOURCE\nDL = resource number"
      0xD9: "Novell NetWare, Banyan VINES - DEALLOCATE RESOURCE\nDL = resource number"
      0xDA: "Novell NetWare 4.0 - GET VOLUME STATISTICS\nDL = volume number\nES:DI -> reply buffer"
      0xDB: "Novell NetWare 4.0 - GET NUMBER OF LOCAL DRIVES"
      0xDC: "Novell NetWare 4.0, Banyan VINES - GET STATION NUMBER"
      0xDD: "Novell NetWare 4.0 - SET ERROR MODE\nDL = error mode - " { dl ?
                0x00: "display critical I/O errors"
                0x01: "extended errors for all I/O in AL"
                0x02: "extended errors for critical I/O in AL"
      }
      0xDE: "Novell NetWare 4.0 - SET BROADCAST MODE\nAL = broadcast mode - " { al ?
                0x00: "receive console and workstation broadcasts"
                0x01: "receive console broadcasts only"
                0x02: "receive no broadcasts"
                0x03: "store all broadcasts for retrieval"
                0x04: "get broadcast mode"
                0x05: "disable shell timer interrupt checks"
                0x06: "enable shell timer interrupt checks"
      }
      0xDF: "Novell NetWare 4.0 - CAPTURE\nAL = subfunction - " { al ?
                0x00: "start LPT capture"
                0x01: "end LPT capture"
                0x02: "cancel LPT capture"
                0x03: "flush LPT capture"
                0x04: "start specific capture"
                0x05: "end specific capture"
                0x06: "cancel specific capture"
                0x07: "flush specific capture"
      }
      0xE0: "Novell NetWare 4.0 - PRINT SPOOLING\nDS:SI -> request buffer\nES:DI -> reply buffer"
      0xE0: "OS/286, OS/386 - INITIALIZE REAL PROCEDURE"
      0xE1: "Novell NetWare 4.0 - BROADCAST MESSAGES\nDS:SI -> request buffer\nES:DI -> reply buffer"
      0xE2: "Novell NetWare 4.0 - DIRECTORY FUNCTIONS\nDS:SI -> request buffer\nES:DI -> reply buffer"
      0xE3: "Novell NetWare 4.0 - CONNECTION CONTROL\nDS:SI -> request buffer\nES:DI -> reply buffer\nAL = interrupt number"
      0xE4: "Novell NetWare 4.0 - SET FILE ATTRIBUTES (FCB)\nCL = file attributes, DX:DX -> FCB"
      0xE4: "DoubleDos - INSTALLATION CHECK"
      0xE5: "Novell NetWare 4.0 - UPDATE FILE SIZE (FCB)\nDS:DX -> FCB"
      0xE6: "Novell NetWare 4.0 - COPY FILE TO FILE (FCB)\nCX:DX = number of bytes to copy\nDS:SI -> source FCB, ES:DI -> destination FCB"
      0xE7: "Novell NetWare 4.0, Banyan VINES - GET FILE SERVER DATE AND TIME\nDS:DX -> reply buffer"
      0xE8: "Novell NetWare 4.6 - SET FCB RE-OPEN MODE\nDL = 00h no automatic re-open / 01h auto re-open"
      0xE9: "Novell NetWare " { al ?
            0x00: "4.6 - SHELL'S \"GET BASE STATUS\"\nDX = drive number to check (0 = A:)"
            0x05: "shell 3.01 - MAP A FAKE ROOT DIRECTORY\nBL = drive number (0=default, 1=A:, ...)\nDS:DX -> ASCIZ path for fake root (may include server name or be empty)"
            0x06: "Novell NetWare shell 3.01 - DELETE FAKE ROOT DIRECTORY\nBL = drive number (0=default, 1=A:, ...)"
            0x07: "Novell NetWare shell 3.01 - GET RELATIVE DRIVE DEPTH\nBL = drive number (0=default, 1=A:, ...)"
            0x08: "Novell NetWare shell 3.01 - SET SHOW DOTS\nBL = 00h don't return '.' or '..' during directory scans"
      }
      0xEA: "Novell NetWare 4.6 - RETURN SHELL VERSION\nAL = return version environment string"
      0xEB: "Novell NetWare 4.6 - LOG FILE\nDS:DX -> ASCIZ filename\nif function C6h lock mode 01h: AL = 00h log file only / 01h lock as well as log file\nBP = timeout in timer ticks (1/18 second)"
      0xEC: "Novell NetWare 4.6 - RELEASE FILE\nDS:DX -> ASCIZ filename"
      0xED: "Novell NetWare - CLEAR FILE\nDS:DX -> ASCIZ filename"
      0xEE: "Novell NetWare 4.6 - GET PHYSICAL STATION NUMBER"
      0xEF: "Novell Advanced NetWare 1.0+ - GET DRIVE INFO\nAL = subfunction - " { al ?
                    0x00: "get drive handle table"
                    0x01: "get drive flag table"
                    0x02: "get drive connection ID table"
                    0x03: "get connection ID table"
                    0x04: "get file server name table"
      }
      0xF0: "Novell Advanced NetWare 1.0+ - CONNECTION ID\nAL = subfunction - " { al ?
                    0x00: "set preferred connection ID"
                    0x01: "get preferred connection ID"
                    0x02: "get default connection ID"
                    0x03: "LPT capture active"
                    0x04: "set primary connection ID"
                    0x05: "get primary connection ID"
      }
      0xF1: "Novell Advanced NetWare 1.0+ - FILE SERVER CONNECTION\nAL = subfunction - " { al ?
                0x00: "attach to file server"
                0x01: "detach from file server"
                0x02: "logout from file server"
      }
      0xF2: "Novell NetWare - ???"
      0xF3: "Novell Advanced NetWare 2.0+ - FILE SERVER FILE COPY\nES:DI -> request string"
      0xF8: "DOS v??? - SET OEM INT 21 HANDLER\nDS:DX -> OEM INT 21 handler for functions F9h to FFh\n         FFFFh:FFFFh resets to original handlers"
      0xF9: "DOS v??? - OEM FUNCTION"
      0xFA: "DOS v??? - OEM FUNCTION"
      0xFB: "DOS v??? - OEM FUNCTION"
      0xFC: "DOS v??? - OEM FUNCTION"
      0xFD: "DOS v??? - OEM FUNCTION"
      0xFE: "DOS v??? - OEM FUNCTION"
      0xFF: "DOS v??? - OEM FUNCTION"
}
0x22: "DOS - TERMINATE ADDRESS\nFAR (DWORD) address to jump to when program \"returns to DOS\"."
0x23: "DOS - CONTROL \"C\" EXIT ADDRESS\nReturn: return via RETF 2 with CF set\nDOS will abort program with errorlevel 0\nelse\ninterrupted DOS call continues"
0x24: "DOS - FATAL ERROR HANDLER ADDRESS\nAutomatically called upon detection of unrecoverable I/O error."
0x25: "DOS - ABSOLUTE DISK READ (except DOS 4.0/COMPAQ DOS 3.31 >32M partitn)\nAL = drive number (0=A, 1=B, etc), DS:BX = Disk Transfer Address (buffer)\nCX = number of sectors to read, DX = first relative sector to read\nReturn: CF set on error"
0x26: "DOS - ABSOLUTE DISK WRITE (except DOS 4.0/COMPAQ DOS 3.31 >32M partn)\nAL = drive number (0=A, 1=B, etc), DS:BX = Disk Transfer Address (buffer)\nCX = number of sectors to write, DX = first relative sector to write\nReturn: CF set on error"
0x27: "DOS - TERMINATE BUT STAY RESIDENT\nCS = current program segment\nDX = last program byte + 1"
0x28: "DOS 2+ internal - KEYBOARD BUSY LOOP"
0x29: { filetype ?
  f_PE: "Win8: RtlFailFast(ecx)"
  other: "DOS 2+ internal - FAST PUTCHAR\nAL = character to display"
  }
0x2A: { ah ?
        0x00: "Microsoft/LANtastic NETWORK - INSTALLATION CHECK\nReturn: AH <> 00h if installed"
        0x01: "Microsoft/LANtastic NETWORK - EXECUTE NETBIOS REQUEST, NO ERROR RETRY\nES:BX -> NCB\nReturn: AL = NetBIOS error code\nAH = 00h if no error\n   = 01h on error"
        0x02: "Microsoft Networks - SET NET PRINTER MODE"
        0x03: "Microsoft Networks - CHECK DIRECT I/O\nDS:SI -> ASCIZ disk device name (may be full path or only drive\nspecifier--must include the colon)\nReturn: CF clear if absolute disk access allowed"
        0x04: "Microsoft/LANtastic NETWORK - EXECUTE NETBIOS REQUEST\nAL = 00h for error retry, 01h for no retry\nES:BX -> NCB\nReturn: AX = 0000h for no error\nAH = 01h, AL = error code"
        0x05: "Microsoft/LANtastic NETWORK - GET NETWORK RESOURCE INFORMATION\nReturn: AX = reserved\nBX = number of network names available\nCX = number of commands (NCBs) available\nDX = number of sessions available"
        0x06: "NETBIOS - NETWORK PRINT-STREAM CONTROL\nAL = " { al ?
              0x01: "set concatenation mode"
              0x02: "set truncation mode"
              0x03: "flush printer output and start new print job"
        }
        //?*?\nReturn: CF set on error\nAX = error code\nCF clear if successful"
        0x20: "MS Networks or NETBIOS - ???"
        0x80: "Microsoft Networks - BEGIN DOS CRITICAL SECTION\nAL = critical section number (00h-0Fh)"
        0x81: "Microsoft Networks - END DOS CRITICAL SECTION\nAL = critical section number (00h-0Fh)"
        0x82: "Microsoft Networks - END DOS CRITICAL SECTIONS 0 THROUGH 7"
        0x84: "Microsoft Networks - KEYBOARD BUSY LOOP"
        0x87: "??? - CRITICAL SECTION\nAL = start/end\n00h start\n01h end"
        0x89: "Network - ???\nAL = ???  (ASSIGN uses 08h)"
        0xC2: "Network - ???\nAL = subfunction, 07h ???, 08h ???\nBX = 0001h"
}
0x2B: "Internal routine for MSDOS (IRET)"
0x2C: { filetype ?
  f_PE: "Windows NT - assertion failure"
  other: "Internal routine for MSDOS (IRET)"
}
0x2D: { filetype ?
  f_PE: "Windows NT - " { al ?
    1 : "eax = 1: debug print"
    2 : "eax = 2: debug prompt"
    3 : "eax = 3: debug load symbols"
    4 : "eax = 4: debug unload symbols"
    5 : "eax = 5: debug command string"
    other: "debugging services: eax = type"
  }
  other: "Internal routine for MSDOS (IRET)"
}
0x2E: {
    op2 ?
#include "ntos.cmt"
  0xFFFFFFFE: "DOS 2+ internal - EXECUTE COMMAND\nDS:SI -> counted CR-terminated command string"
}
0x2F: { ah ?
      0x01: "Multiplex - DOS 3+ PRINT.COM - " { al ?
            0x00: "INSTALLATION CHECK\nReturn: AL = 00h not installed, OK to install\n01h not installed, not OK to install\nFFh installed"
            0x01: "SUBMIT FILE\nDS:DX -> packet\nReturn: CF set on error"
            0x02: "REMOVE FILE\nDS:DX -> ASCIZ file name (wildcards allowed)\nReturn: CF set on error"
            0x03: "Multiplex - DOS 3+ PRINT.COM - REMOVE ALL FILES\nReturn: CF set on error"
            0x04: "Multiplex - DOS 3+ PRINT.COM - HOLD QUEUE/GET STATUS\nReturn: CF set on error, DX = error count\nDS:SI -> print queue (null-string terminated list of 64-byte ASCIZ file names)"
            0x05: "Multiplex - DOS 3+ PRINT.COM - RESTART QUEUE\nReturn: CF set on error"
            0x06: "Multiplex - DOS 3.3+ PRINT.COM - CHECK IF ERROR ON OUTPUT DEVICE\nReturn: CF set on error"
      }
      0x02: "Multiplex - PC LAN PROGRAM REDIR/REDIRIFS internal - " { al ?
            0x00: "INSTALL CHECK\nReturn: AL = FFh if installed"
            0x01: "???"
            0x02: "???"
            0x03: "???"
            0x04: "???"
      }
      0x05: "Multiplex - DOS 3+ CRITICAL ERROR HANDLER - " { al ?
            0x00: "INSTALLATION CHECK\nReturn: AL = 00h not installed, OK to install\n01h not installed, can't install\nFFh installed"
      }
      0x06: "Multiplex - ASSIGN - " { al ?
            0x00: "INSTALLATION CHECK\nReturn: AL <> 00h if installed"
            0x01: "GET MEMORY SEGMENT\nReturn: ES = segment of ASSIGN work area and assignment table"
      }
      0x80: "Multiplex - DRIVER.SYS support - " { al ?
            0x00: "INSTALLATION CHECK\nReturn:  AL = 00h not installed, OK to install\n01h not installed, not OK to install\nFFh installed"
            0x01: "ADD NEW BLOCK DEVICE\nDS:DI -> drive data table"
            0x02: "EXECUTE DEVICE DRIVER REQUEST\nES:BX -> device driver request header\nReturn: request header updated as per requested operation"
            0x03: "GET DRIVE DATA TABLE LIST\nReturn: DS:DI -> first drive data table in list"
      }
      0x10: "Multiplex - " { al ?
            0x00: "SHARE - INSTALLATION CHECK\nReturn: AL = 00h  not installed, OK to install\n01h  not installed, not OK to install\nFFh  installed"
            0x40: "DOS 4.0 SHARE internal - ???"
            0x80: "DOS 4.0 SHARE internal - CLEAR ??? FLAG\nReturn: AL = F0h function supported"
            0x81: "DOS 4.0 SHARE internal - SET ??? FLAG\nReturn: AL = F0h function supported"
      }
      0x11: "Multiplex - " { al ?
            0x00: "NETWORK REDIRECTOR - INSTALLATION CHECK\nReturn: AL = 00h  not installed, OK to install\n01h  not installed, not OK to install\nFFh  installed"
            0x01: "NETWORK REDIRECTOR - REMOVE REMOTE DIRECTORY\nSS = DOS CS\nSDA first filename pointer -> fully-qualified directory name\nSDA CDS pointer -> current directory \nReturn: CF set on error, AX = DOS error code\nCF clear if successful"
            0x02: "DOS 4 IFSFUNC.EXE - REMOVE REMOTE DIRECTORY\nSS = DOS CS\nSDA first filename pointer -> fully-qualified directory name\nSDA CDS pointer -> current directory \nReturn: CF set on error, AX = DOS error code\nCF clear if successful"
            0x03: "NETWORK REDIRECTOR - MAKE REMOTE DIRECTORY\nSS = DOS CS\nSDA first filename pointer -> fully-qualified directory name\nSDA CDS pointer -> current directory \nReturn: CF set on error, AX = DOS error code\nCF clear if successful"
            0x04: "DOS 4 IFSFUNC.EXE - MAKE REMOTE DIRECTORY\nSS = DOS CS\nSDA first filename pointer -> fully-qualified directory name\nSDA CDS pointer -> current directory \nReturn: CF set on error, AX = DOS error code\nCF clear if successful"
            0x05: "NETWORK REDIRECTOR - CHDIR\nSS = DOS CS\nSDA first filename pointer -> fully-qualified directory name\nSDA CDS pointer -> current directory \nReturn: CF set on error, AX = DOS error code\nCF clear if successful"
            0x06: "NETWORK REDIRECTOR - CLOSE REMOTE FILE\nES:DI -> SFT\nSFT DPB field -> DPB of drive containing file\nReturn: CF set on error, AX = DOS error code\nCF clear if successful"
            0x07: "NETWORK REDIRECTOR - COMMIT REMOTE FILE\nES:DI -> SFT\nSFT DPB field -> DPB of drive containing file\nReturn: CF set on error, AX = DOS error code\nCF clear if successful"
            0x08: "NETWORK REDIRECTOR - READ FROM REMOTE FILE\nES:DI -> SFT\nSFT DPB field -> DPB of drive containing file\nCX = number of bytes, SS = DOS CS, SDA DTA field -> user buffer\nReturn: CF set on error, CX = bytes read"
            0x09: "NETWORK REDIRECTOR - WRITE TO REMOTE FILE\nES:DI -> SFT\nSFT DPB field -> DPB of drive containing file\nCX = number of bytes, SS = DOS CS, SDA DTA field -> user buffer\nReturn: CF set on error, CX = bytes written"
            0x0A: "NETWORK REDIRECTOR - LOCK REGION OF FILE\nBX = file handle, CX:DX = starting offset, SI = high word of size\nSTACK: WORD low word of size, ES:DI -> SFT\nSFT DPB field -> DPB of drive containing file, SS = DOS CS\nReturn: CF set error"
            0x0B: "NETWORK REDIRECTOR - UNLOCK REGION OF FILE\nBX = file handle, CX:DX = starting offset, SI = high word of size\nSTACK: WORD low word of size, ES:DI -> SFT for file\nSFT DPB field -> DPB of drive containing file\nReturn: CF set error"
            0x0C: "NETWORK REDIRECTOR - GET DISK SPACE\nES:DI -> current directory\nReturn: AL = sectors per cluster, BX = total clusters\nCX = bytes per sector, DX = number of available clusters"
            0x0D: "DOS 4 IFSFUNC.EXE - ???\nSDA first filename pointer -> name of file"
            0x0E: "NETWORK REDIRECTOR - SET REMOTE FILE'S ATTRIBUTES\nSS = DOS CS, SDA first filename pointer -> fully-qualified name of file\nSDA CDS pointer -> current directory\nSTACK: WORD new file attributes\nReturn: CF set on error"
            0x0F: "NETWORK REDIRECTOR - GET REMOTE FILE'S ATTRIBUTES\nSS = DOS CS, SDA first filename pointer -> fully-qualified name of file\nSDA CDS pointer -> current directory\nReturn: CF set on error, AX = file attributes"
            0x10: "DOS 4 IFSFUNC.EXE - ???\nSDA first filename pointer -> name of file"
            0x11: "NETWORK REDIRECTOR - RENAME REMOTE FILE\nSS = DS = DOS CS, SDA first filename pointer = offset of fully-qualified old name\nSDA CDS pointer -> current directory\nReturn: CF set on error"
            0x12: "DOS 4 IFSFUNC.EXE - ???\nSS = DS = DOS CS, SDA first filename pointer -> name of file"
            0x13: "NETWORK REDIRECTOR - DELETE REMOTE FILE\nSS = DS = DOS CS, SDA first filename pointer -> fully-qualified filename in DOS CS\nSDA CDS pointer -> current directory structure for drive with file\nReturn: CF set on error"
            0x14: "DOS 4 IFSFUNC.EXE - ???\nSDA first filename pointer -> name of file"
            0x15: "DOS 4 IFSFUNC.EXE - ???\nSS = DOS CS, ES:DI -> SFT ???"
            0x16: "NETWORK REDIRECTOR - OPEN EXISTING REMOTE FILE\nES:DI -> uninitialized SFT, SS = DOS CS\nSDA first filename pointer -> fully-qualified name of file to open\nSTACK: WORD file open mode\nReturn: CF set on error"
            0x17: "NETWORK REDIRECTOR - CREATE/TRUNCATE REMOTE FILE\nES:DI -> uninitialized SFT, SS = DOS CS\nSDA first filename pointer -> fully-qualified name of file to open\nSDA CDS pointer -> current directory\nReturn: CF set on error"
            0x18: "NETWORK REDIRECTOR - CREATE/TRUNCATE FILE\nES:DI -> uninitialized SFT, SS = DOS CS\nSDA first filename pointer -> fully-qualified name of file\nSTACK: WORD file creation mode???"
            0x19: "NETWORK REDIRECTOR - ???"
            0x1A: "DOS 4 IFSFUNC.EXE - ???"
            0x1B: "NETWORK REDIRECTOR - FINDFIRST\nSS = DS = DOS CS, [DTA] = uninitialized 21-byte findfirst search data\nSDA first filename pointer -> fully-qualified search template\nSDA CDS pointer -> current directory\nReturn: CF set on error"
            0x1C: "NETWORK REDIRECTOR - FINDNEXT\nSS = DS = DOS CS, [DTA] = 21-byte findfirst search data\nReturn: CF set on error, AX = DOS error code\nCF clear if successful"
            0x1D: "NETWORK REDIRECTOR - CLOSE ALL REMOTE FILES FOR PROCESS\nDS???, SS = DOS CS"
            0x1E: "NETWORK REDIRECTOR - DO REDIRECTION\nSS = DOS CS\nSTACK: WORD function to execute\nReturn: CF set on error, AX = error code\nSTACK unchanged"
            0x1F: "NETWORK REDIRECTOR - PRINTER SETUP\nSTACK: WORD function\nReturn: CF set on error, AX = error code\nSTACK unchanged"
            0x20: "NETWORK REDIRECTOR - FLUSH ALL DISK BUFFERS\nDS = DOS CS\nReturn: CF clear (successful)"
            0x21: "NETWORK REDIRECTOR - SEEK FROM END OF REMOTE FILE\nCX:DX = offset (in bytes) from end\nES:DI -> SFT, SFT DPB field -> DPB of drive with file\nSS = DOS CS\nReturn: CF set on error\nCF clear if successful, DX:AX = new file position"
            0x22: "NETWORK REDIRECTOR - PROCESS TERMINATION HOOK\nSS = DOS CS"
            0x23: "NETWORK REDIRECTOR - QUALIFY REMOTE FILENAME\nDS:SI -> ASCIZ filename to canonicalize\nES:DI -> 128-byte buffer for qualified name\nReturn: CF set if not resolved"
            0x24: "NETWORK REDIRECTOR - ???\nES:DI -> SFT, SS = DOS CS"
            0x25: "NETWORK REDIRECTOR - REDIRECTED PRINTER MODE\nSTACK: WORD subfunction\nReturn: CF set on error, AX = error code\nSTACK unchanged"
            0x26: "NETWORK REDIRECTOR - ???\nReturn: CF set on error, AX = error code\nSTACK unchanged"
            0x27: "DOS 4 IFSFUNC.EXE - UNUSED\nReturn: CF set, AX = 0001h"
            0x28: "DOS 4 IFSFUNC.EXE - UNUSED\nReturn: CF set, AX = 0001h"
            0x29: "DOS 4 IFSFUNC.EXE - UNUSED\nReturn: CF set, AX = 0001h"
            0x1A: "DOS 4 IFSFUNC.EXE - ???\nDS = DOS CS"
            0x2B: "DOS 4 IFSFUNC.EXE - ???\nSS = DOS CS, CX = ???, DX = ???\nSTACK: WORD low byte contains function???\nReturn: CF set on error, AX = DOS error code\nCF clear if successful"
            0x2C: "DOS 4 IFSFUNC.EXE - ???\nSS = DOS CS, SDA current SFT pointer -> SFT for file\nReturn: CF set on error"
            0x2D: "DOS 4 IFSFUNC.EXE - ???\nBL = 04h ??? Return: CF clear\n   else ??? Return: CX = ??? (00h or 02h for DOS 4.01)\nSS = DOS CS\nReturn: DS = DOS CS"
            0x2E: "DOS 4 IFSFUNC.EXE - ???\nSS = DS = DOS CS, STACK: WORD ???   low byte = ???\nReturn: CF set on error\nCF clear if successful"
            0x2F: "DOS 4 IFSFUNC.EXE - ???\nSS = DOS CS, STACK: WORD function in low byte\nReturn: CF set on error, AX = DOS error code\nCF clear if successful"
            0x30: "DOS 4 IFSFUNC.EXE - GET IFSFUNC SEGMENT\nReturn: ES = CS of resident IFSFUNC"
      }
      0x12: "Multiplex - DOS 3+ internal - " { al ?
            0x00: "INSTALLATION CHECK\nReturn: AL = FFh (for compatibility with other INT 2F functions)"
            0x01: "CLOSE CURRENT FILE\nSS = DOS CS, SDA current SFT pointer -> SFT of file to close\nReturn: BX???, CX???\nES:DI -> SFT for file"
            0x02: "GET INTERRUPT ADDRESS\nSTACK: WORD vector number\nReturn: ES:BX -> interrupt vector\nSTACK unchanged"
            0x03: "GET DOS DATA SEGMENT\nReturn: DS = segment of IBMDOS.COM/MSDOS.SYS"
            0x04: "NORMALIZE PATH SEPARATOR\nSTACK: WORD character to normalize\nReturn: AL = normalized character\nZF set if path separator\nSTACK unchanged"
            0x05: "OUTPUT CHARACTER TO STANDARD OUTPUT\nSTACK: WORD character to output\nReturn: STACK unchanged"
            0x06: "INVOKE CRITICAL ERROR\nDI = error code, BP:SI -> device driver header\nSS = DOS CS, STACK: WORD value to be passed to INT 24 in AX\nReturn: AL = 0-3 for Abort, Retry, Ignore, Fail\nSTACK unchanged"
            0x07: "MAKE DISK BUFFER MOST-RECENTLY USED\nDS:DI -> disk buffer\nReturn: buffer moved to end of buffer list"
            0x08: "DECREMENT SFT REFERENCE COUNT\nES:DI -> SFT\nReturn: AX = new value of reference count"
            0x09: "FLUSH AND FREE DISK BUFFER\nDS:DI -> disk buffer\nReturn: disk buffer marked unused, contents written to disk if buffer dirty"
            0x0A: "PERFORM CRITICAL ERROR INTERRUPT\nDS = SS = DOS CS, STACK: WORD extended error code\nReturn: AL = user response (0=ignore, 1=retry, 2=abort, 3=fail)\nCF clear if retry, set otherwise\nSTACK unchanged"
            0x0B: "SIGNAL SHARING VIOLATION TO USER\nES:DI -> system file table entry for previous open of file\nSTACK: WORD extended error code\nReturn: CF clear if operation should be retried\nCF set if operation should not be retried"
            0x0C: "SET FCB FILE'S OWNER???\nSDA current SFT pointer -> SFT for file, DS = SS = DOS CS\nReturn: ES, DI, AX destroyed"
            0x0D: "GET DATE AND TIME\nSS = DOS CS\nReturn: AX = current date in packed format\nDX = current time in packed format"
            0x0E: "MARK ALL DISK BUFFERS UNREFERENCED\nSS = DOS CS\nReturn: DS:DI -> first disk buffer"
            0x0F: "MAKE BUFFER MOST RECENTLY USED\nDS:DI -> disk buffer, SS = DOS CS\nReturn: DS:DI -> next buffer in buffer list"
            0x10: "FIND UNREFERENCED DISK BUFFER\nDS:DI -> first disk buffer to check\nReturn: ZF clear if found, DS:DI -> first unreferenced disk buffer\nZF set if not found"
            0x11: "NORMALIZE ASCIZ FILENAME\nDS:SI -> ASCIZ filename to normalize\nES:DI -> buffer for normalized filename\nReturn: destination buffer filled with uppercase\nfilename, with slashes turned to backslashes"
            0x12: "GET LENGTH OF ASCIZ STRING\nES:DI -> ASCIZ string\nReturn: CX = length of string"
            0x13: "UPPERCASE CHARACTER\nSTACK: WORD character to convert to uppercase\nReturn: AL = uppercase character\nSTACK unchanged"
            0x14: "COMPARE FAR POINTERS\nDS:SI = first pointer, ES:DI = second pointer\nReturn: ZF set if pointers are equal, ZF clear if not equal"
            0x15: "FLUSH BUFFER\nDS:DI -> disk buffer, SS = DOS CS\nSTACK: WORD drives for which to skip buffer\nReturn: STACK unchanged"
            0x16: "GET ADDRESS OF SYSTEM FILE TABLE\nBX = system file table entry number\nReturn: CF clear if successful, ES:DI -> system file table entry\nCF set if BX greater than FILES="
            0x17: "SET WORKING DRIVE\nSS = DOS CS, STACK: WORD drive (0 = A:, 1 = B:, etc)\nReturn: CF set on error, (drive > LASTDRIVE)\nCF clear if successful, DS:SI -> current directory structure for specified drive\nSTACK unchanged"
            0x18: "GET CALLER'S REGISTERS\nReturn: DS:SI -> saved caller's AX,BX,CX,DX,SI,DI,BP,DS,ES (on stack)"
            0x19: "SET DRIVE???\nSS = DOS CS, STACK: WORD drive (0 = default, 1 = A:, etc)\nReturn: ???, STACK unchanged"
            0x1A: "GET FILE'S DRIVE\nDS:SI -> filename\nReturn: AL = drive (0 = default, 1 = A:, etc, FFh = invalid)"
            0x1B: "SET YEAR/LENGTH OF FEBRUARY\nCL = year - 1980\nReturn: AL = number of days in February"
            0x1C: "CHECKSUM MEMORY\nDS:SI -> start of memory to checksum, CX = number of bytes\nDX = initial checksum, SS = DOS CS\nReturn: AX, CX destroyed\nDX = checksum\nDS:SI -> first byte after checksummed range"
            0x1D: "SUM MEMORY\nDS:SI -> memory to add up, CX = 0000h, DX = limit\nReturn: AL = byte which exceeded limit\nCX = number of bytes before limit exceeded\nDX = remainder after adding first CX bytes"
            0x1E: "COMPARE FILENAMES\nDS:SI -> first ASCIZ filename, ES:DI -> second ASCIZ filename\nReturn: ZF set if filenames equivalent, ZF clear if not"
            0x1F: "BUILD CURRENT DIRECTORY STRUCTURE\nSS = DOS CS, STACK: WORD drive letter\nReturn: ES:DI -> current directory structure\nSTACK unchanged"
            0x20: "GET JOB FILE TABLE ENTRY\nBX = file handle\nReturn: CF set on error, AL = 6\nCF clear if successful, ES:DI -> JFT entry for file handle in current process"
            0x21: "CANONICALIZE FILE NAME\nDS:SI -> file name to be fully qualified\nES:DI -> 128-byte buffer for resulting canonical file name\nSS = DOS CS\nReturn:"
            0x22: "SET EXTENDED ERROR INFO\nSS = DOS data segment, SS:SI -> 4-byte records\nSDA error code set\nReturn: SI destroyed\nSDA error class, error locus, and suggested action fields set"
            0x23: "CHECK IF CHARACTER DEVICE\n"
                  "SDA+218h = 8-char blank-padded name\n"
                  "SDA+22Bh = 8-char blank-padded name\n"
                  "Return: CF set if no character device by that name found\n"
                  "CF clear if found, BH = low byte of device attribute word"
            0x24: "DELAY\nSS = DOS CS\nReturn: after delay set by INT 21/AX=440Bh, unless in server call"
            0x25: "GET LENGTH OF ASCIZ STRING\nDS:SI -> ASCIZ string\nReturn: CX = length of string"
            0x26: "OPEN FILE\nCL = access mode, DS:DX -> ASCIZ filename\nReturn: CF set on error, AL = error code\nCF clear if successful, AX = file handle"
            0x27: "CLOSE FILE\nBX = file handle\nReturn: CF set on error, AL = 06h invalid file handle\nCF clear if successful"
            0x28: "MOVE FILE POINTER\nBP = 4200h, 4201h, 4202h\nBX = file handle, CX:DX = offset in bytes, SS = DOS CS\nReturn: as for INT 21/AH=42h"
            0x29: "READ FROM FILE\nBX = file handle, CX = number of bytes to read\nDS:DX -> buffer, SS = DOS CS\nReturn: as for INT 21/AH=3Fh"
            0x2A: "SET FASTOPEN ENTRY POINT\nBX = entry point to set (0001h or 0002h)\nDS:SI -> FASTOPEN entry point, (entry point not set if SI = FFFFh for DOS 4+)\nReturn: CF set if specified entry point already set"
            0x2B: "IOCTL\nBP = 44xxh, SS = DOS CS\nReturn: as for INT 21/AH=44h"
            0x2C: "GET DEVICE CHAIN\nReturn: BX:AX -> header of second device driver (NUL is first) in driver chain"
            0x2D: "GET EXTENDED ERROR CODE\nReturn: AX = current extended error code"
            0x2E: "GET OR SET ERROR TABLE ADDRESSES\nDL = subfunction - " { dl ?
                  0x00: "get standard DOS error table (errors 00h-12h,50h-5Bh)\nReturn: ES:DI -> error table"
                  0x01: "set standard DOS error table\nES:DI -> error table"
                  0x02: "get parameter error table (errors 00h-0Ah)\nES:DI -> error table"
                  0x03: "set parameter error table\nES:DI -> error table"
                  0x04: "get critical/SHARE error table (errors 13h-2Bh)\nES:DI -> error table"
                  0x05: "set critical/SHARE error table\nES:DI -> error table"
                  0x06: "get ??? error table\nES:DI -> error table"
                  0x07: "set ??? error table\nES:DI -> error table"
                  0x08: "get ??? error table\nReturn: ES:DI -> error table"
                  0x09: "set ??? error table\nES:DI -> error table"
            }
            0x2F: "SET ???\nDX = ???"
      }
      0x13: "SET DISK INTERRUPT HANDLER\nDS:DX -> interrupt handler disk driver calls on read/write\nES:BX = address to restore INT 13 to on system halt\nReturn: DS:DX from previous invocation\nES:BX from previous invocation of this function"
      0x14: "- Multiplex - " { al ?
            0x00: "NLSFUNC.COM - INSTALLATION CHECK\nReturn: AL = 00h not installed, OK to install\n01h not installed, not OK\nFFh installed"
            0x01: "NLSFUNC.COM - CHANGE CODE PAGE\nDS:SI -> internal code page structure\nBX = new code page, DX = country code???\nReturn: AL = status\n00h successful\nelse DOS error code"
            0x02: "NLSFUNC.COM - GET COUNTRY INFO\nBP = subfunction, BX = code page\nDX = country code, DS:SI -> internal code page structure\nES:DI -> user buffer, CX = size of user buffer\nReturn: AL = status\n00h successful\nelse DOS error code"
            0x03: "NLSFUNC.COM - SET COUNTRY INFO\nDS:SI -> internal code page structure\nBX = code page, DX = country code\nReturn: AL = status"
            0x04: "NLSFUNC.COM - GET COUNTRY INFO\nBX = code page, DX = country code, DS:SI -> internal code page structure\nES:DI -> user buffer\nReturn: AL = status"
      }
      0x15: " Multiplex - CDROM - " { al ?
            0x00: "INSTALLATION CHECK\nBX = 0000h\nReturn: BX = number of CDROM drive letters used\nCX = starting drive letter (0=A:)"
            0x01: "GET DRIVE DEVICE LIST\nES:BX -> buffer to hold drive letter list\nReturn: buffer filled, for each drive letter\nBYTE subunit number in driver\nDWORD address of device driver header"
            0x02: "GET COPYRIGHT FILE NAME\nES:BX -> 38-byte buffer for name of copyright file\nCX = drive number (0=A:)\nReturn: CF set if drive is not a CDROM drive, AX = 15 (invalid drive)\nCF clear if successful"
            0x03: "GET ABSTRACT FILE NAME\nES:BX -> 38-byte buffer for name of abstract file\nCX = drive number (0=A:)\nReturn: CF set if drive is not a CDROM drive, AX = 15 (invalid drive)\nCF clear if successful"
            0x04: "GET BIBLIOGRAPHIC DOC FILE NAME\nES:BX -> 38-byte buffer for name of bibliographic documentation file\nCX = drive number (0=A:)\nReturn: CF set if drive is not a CDROM drive, AX = 15 (invalid drive)\nCF clear if successful"
            0x05: "READ VTOC\nES:BX -> 2048-byte buffer CX = drive number (0=A:)\nDX = sector index (0=first volume descriptor,1=second,...)\nReturn: CF set on error, AX = error code\nCF clear if successful, AX = volume descriptor type"
            0x06: "TURN DEBUGGING ON\nBX = debugging function to enable"
            0x07: "TURN DEBUGGING OFF\nBX = debugging function to disable"
            0x08: "ABSOLUTE DISK READ\nES:BX -> buffer, CX = drive number (0=A:)\nSI:DI = starting sector number, DX = number of sectors to read\nReturn: CF set on error, AL = error code (15=invalid drive,21=not ready)\nCF clear if successful"
            0x09: "ABSOLUTE DISK WRITE\nES:BX -> buffer, CX = drive number (0=A:)\nSI:DI = starting sector number, DX = number of sectors to write"
            0x0A: "RESERVED"
            0x0B: "2.00 - DRIVE CHECK\nCX = drive number (0=A:)\nReturn: BX = ADADh if MSCDEX.EXE installed\nAX = 0000h if drive not supported\nnonzero if supported"
            0x0C: "2.00 - GET MSCDEX.EXE VERSION\nReturn: BH = major version\nBL = minor version"
            0x0D: "2.00 - GET CDROM DRIVE LETTERS\nES:BX -> buffer for drive letter list (1 byte per drive)\nReturn: buffer filled with drive numbers (0=A:).  Each byte corresponds\nto the drive in the same position for function 1501h"
            0x0E: "2.00 - GET/SET VOLUME DESCRIPTOR PREFERENCE\nBX = 00h get preference / 01h set preference\nCX = drive number (0=A:)\nReturn: CF set on error, AX = error code\nCF clear if successful"
            0x0F: "2.00 - GET DIRECTORY ENTRY\nCX = drive number (0=A:), ES:BX -> ASCIZ path name\nSI:DI -> 255-byte buffer for directory entry\nReturn: CF set on error, AX = error code\nCF clear if succesful, AX = disk format"
            0x10: "2.10 - SEND DEVICE DRIVER REQUEST\nCX = CD-ROM drive letter (0 = A, 1 = B, etc)\nES:BX -> CD-ROM device driver request header"
      }
      0x16: "- Multiplex - MS WINDOWS - " { al ?
            0x00: "ENHANCED WINDOWS INSTALLATION CHECK\nReturn: AL = anything else\nAL = Windows major version number >= 3\nAH = Windows minor version number"
            0x02: "386 2.x - GET API ENTRY POINT\nReturn: ES:DI -> Windows/386 2.x API procedure entry point"
            0x03: "GET INSTANCE DATA\n"
                  "Return: AX=5248h ('RH') if supported\n"
                  "DS:SI -> Windows/386 instance data"
            0x05: "ENHANCED WINDOWS & 286 DOSX INIT BROADCAST\n"
                  "ES:BX=0000h:0000h, DS:SI=0000h:0000h, CX=0000h\n"
                  "DI=version number\n"
                  "Return: CX=0 if ok for Windows to load\n"
                  "CX <> 0 if Windows should not load\n"
                  "ES:BX -> startup info structure"
            0x06: "ENHANCED WINDOWS & 286 DOSX EXIT BROADCAST\nDX = bit 0 = 0 if enhanced Windows exit\n     bit 0 = 1 if Microsoft 286 DOS extender exit\nReturn: CX = 0000h if okay for Windows to load\nCX <> 0 if Windows should not load"
            0x07: "VIRTUAL DEVICE CALL OUT API\nBX = virtual device ID - " { bx ?
                  0x0001: "VMM"
                  0x0002: "DEBUG"
                  0x0006: "V86MMGR"
                  0x0007: "PAGESWAP"
                  0x0009: "REBOOT"
                  0x000A: "VDD"
                  0x000B: "VSD"
                  0x000C: "VMD"
                  0x000D: "VKD"
                  0x0010: "BLOCKDEV"
                  0x0014: "VNETBIOS"
                  0x0015: "DOSMGR"
                  0x0017: "SHELL"
                  0x0018: "VMPOLL"
                  0x0020: "INT13"
                  0x0021: "PAGEFILE"
                  0x0026: "APM"
                  0x0027: "VXDLDR"
                  0x002A: "VWIN32"
                  0x002B: "VCOMM"
                  0x002D: "WIN32S"
                  0x0033: "CONFIGMG"
                  0x0035: "SCSIPORT"
                  0x0036: "VFBACKUP"
                  0x0040: "IFSMGR"
                  0x0044: "PELOADER"
                  0x0048: "PERF"
                  0x004B: "NTKERN"
                  0x0446: "VADLIBD"
                  0x0484: "IFSMGR"
                  0x0487: "NWSUP"
                  0x28A1: "PharLap"
                  0x7A5F: "SIWVID"
            }
            0x08: "ENHANCED WINDOWS INIT COMPLETE BROADCAST"
            0x09: "ENHANCED WINDOWS BEGIN EXIT BROADCAST"
            0x0A: "MS Windows 3.1 - IDENTIFY WINDOWS VERSION AND TYPE\n"
                  "Return: AX=0 if supported\n"
                  "BX = version (BH=major, BL=minor)\n"
                  "CX = mode (2 - standart, 3 - enhanced)"
            0x0B: "IDENTIFY TSR\n"
                  "ES:DI = 0:0\n"
                  "Return: ES:DI -> TSR information structure"
            0x0C: "DETECT ROMs"
            0x0E: "MS-DOS 7 BOOT LOGO SUPPORT - " { bl ?
                  0x00: "get logochars per screen"
                  0x01: "link in10h handlers"
                  0x02: "unlink int 10h handlers"
                  0x03: "correct EGA output mode"
                  0x04: "prepare 'stupid' output"
                  0x05: "clear flag of 'stupid' output"
            }
            0x11: "MS-DOS 7 - GET SHELL PARAMETERS\n"
                  "Return: AX=0 if Ok\n"
                  "DS:DX -> primary shell's executable name\n"
                  "DS:SI -> primary shell command line\n"
                  "BL = boot mode flags\n"
                  "BH = boot drive (if not 'C' only)"
            0x13: "MS-DOS 7 GET SYSTEM.DAT (REGISTRY FILE) PATHNAME\n"
                  "ES:DI -> buffer for full ASCIZ pathname\n"
                  "CX = buffer size in bytes\n"
                  "Return: AX=0 if supported\n"
                  "CX=number of bytes copied into buffer"
            0x14: "MS-DOS 7 SET SYSTEM.DAT (REGISTRY FILE) PATHNAME\n"
                  "ES:DI -> buffer for full ASCIZ pathname\n"
                  "Return: AX=0 if supported\n"
                  "AX=1614 if not supported\n"
                  "other: maximum length of pathname (004Eh)"
            0x15: "Windows95 - SAVE32.COM - INSTALLATION CHECK"
            0x80: "RELEASE CURRENT VIRTUAL MACHINE TIME-SLICE\nReturn: AL = 00h if the call is supported\nAL = 80h (unchanged) if the call is not supported"
            0x81: " 3+ - BEGIN CRITICAL SECTION"
            0x82: " 3+ - END CRITICAL SECTION"
            0x83: " 3+ - GET CURRENT VIRTUAL MACHINE ID\nReturn: BX = current virtual machine (VM) ID"
            0x84: "GET DEVICE API ENTRY POINT\nBX = virtual device (VxD) ID, ES:DI = 0000h:0000h\nReturn: ES:DI -> VxD API entry point, or 0:0 if the VxD does not support an API"
            0x85: "SWITCH VMs AND CALLBACK\nBX = VM ID of virtual machine to switch to\nCX = bit 0 wait until interrupts enabled\nbit 1 wait until critical section unowned\nDX:SI = priority boost\nES:DI -> FAR procedure\nReturn: CF set on error"
            0x86: "Mode Interface - DETECT MODE\nReturn: AX = 0000h if operating in protected mode under DPMI (INT 31 available)\nAX nonzero if in real/V86 mode or no DPMI (INT 31 not available)"
            0x87: "Mode Interface - INSTALLATION CHECK\nReturn: AX = 0000h if installed, BX = flags\nCL = processor type, DH = DPMI major version\nDL = DPMI minor version\nSI = number of paragraphs\nES:DI -> DPMI mode-switch entry point"
            0x88: "GET ALIAS SELECTOR TO LDT"
            0x89: "KERNEL IDLE CALL"
            0x8A: "DPMI vendor text string ds:si"
            0x8B: "SET FOCUS TO SPECIFIED VIRTUAL MACHINE\n"
                  "BX = virtual machine id (0 - for current DOS box)"
            0x8E: "Win95 - TITLE - " { dx ?
                  0x000: "SET APPLICATION TITLE\n"
                         "ES:DI -> ASCIZ application title (max 79 chars)"
                  0x001: "SET VIRTUAL MACHINE TITLE\n"
                         "ES:DI -> ASCIZ virtual machine title (max 29 chars)"
                  0x002: "GET APPLICATION TITLE\n"
                         "ES:DI -> buffer for ACSIZ application title\n"
                         "CX = size of buffer in bytes"
                  0x003: "GET VIRTUAL MACHINE TITLE\n"
                         "ES:DI -> buffer for ACSIZ application title\n"
                         "CX = size of buffer in bytes"
            }
            0x8F: "Win95 - CLOSE-AWARENESS - " { dh ?
                  0x00: "DNABLE/DISABLE CLOSE COMMAND\n"
                        "DL=0 for disabled, DL=1 for enabled"
                  0x01: "QUERY CLOSE\n"
                        "Return: AX - status"
                  0x02: "ACKNOLEDGE CLOSE\n"
                        "Return: AX - status"
                  0x03: "CANCEL CLOSE\n"
                        "Return: AX - status"
            }
      }
      0x17: "- Multiplex - MS WINDOWS \"WINOLDAP\" - " { al ?
            0x00: "IDENTIFY WinOldAp VERSION\nReturn: AX = 1700h if this version of WINOLDAP doesn't support clipboard\nAX <> 1700h"
            0x01: "OPEN CLIPBOARD\nReturn: AX <> 0  success\nAX = 0 clipboard is already open"
            0x02: "EMPTY CLIPBOARD\nReturn: AX <> 0  clipboard has been emptied\nAX = 0  failure"
            0x03: "SET CLIPBOARD DATA\nES:BX -> data\nSI:CX = size of data\nDX = clipboard format supported by WinOldAp: " { dx ?
                  0x01: "text"
                  0x02: "bitmap"
                  0x03: "metafile picture"
                  0x04: "SYLK"
                  0x05: "DIF"
                  0x06: "TIFF"
                  0x07: "OEM text"
            }
            //?*?\nReturn: AX <> 0 data copied into the Clipboard\nAX = 0 failure"
            0x04: "GET CLIPBOARD DATA SIZE\nDX = clipboard format supported by WinOldAp\nReturn:  DX:AX = size of data in bytes, including any headers\nFailure: DX:AX = 0  no data in this format in the Clipboard"
            0x05: "GET CLIPBOARD DATA\nDX = clipboard format supported by WinOldAp\nES:BX -> buffer\nReturn: AX <> 0  success\nAX = 0    error, or no data in this format in Clipboard"
            0x08: "CloseClipboard\nReturn: AX <> 0 success\nAX = 0 failure"
            0x09: "COMPACT CLIPBOARD\nSI:CX = desired size in bytes\nReturn: DX:AX = number of bytes in largest block of free memory"
            0x0A: "GET DEVICE CAPABILITIES\nDX = GDI information index - " { dx ?
                  0x00: "device driver version"
                  0x02: "device classification"
                  0x04: "width in mm"
                  0x06: "height in mm"
                  0x08: "width in pixels"
                  0x0A: "height in pixels"
                  0x0C: "bits per pixel"
                  0x0E: "number of bit planes"
                  0x10: "number of brushes supported by device"
                  0x12: "number of pens supported by device"
                  0x14: "number of markers supported by device"
                  0x16: "number of fonts supported by device"
                  0x18: "number of colors"
                  0x1A: "size required for device descriptor"
                  0x1C: "curve capabilities"
                  0x1E: "line capabilities"
                  0x20: "polygon capabilities"
                  0x22: "text capabilities"
                  0x24: "clipping capabilities"
                  0x26: "bitblt capabilities"
                  0x28: "X aspect"
                  0x2A: "Y aspect"
                  0x2C: "length of hypotenuse of aspect"
                  0x58: "logical pixels per inch of width"
                  0x5A: "logical pixels per inch of height"
            }
            //?*?\nReturn:  AX = integer value of the desired item"
      }
      0x19: "- Multiplex - DOS 4.x only SHELLB.COM - " { al ?
            0x00: "INSTALLATION CHECK\nReturn: AL = 00h  not installed, AL = FFh  installed"
            0x01: "SHELLC.EXE INTERFACE\nBL = 00h if SHELLC transient, BL = 01h if SHELLC resident\nDS:DX -> far call entry point for resident SHELLC.EXE\nReturn: ES:DI -> SHELLC.EXE workspace within SHELLB.COM"
            0x02: "COMMAND.COM INTERFACE\nES:DI -> ASCIZ full filename of current batch file, with at least the\nfinal filename element uppercased\nDS:DX -> buffer for results"
            0x03: "COMMAND.COM interface\nES:DI -> ASCIZ batch file name as for AX=1902h\nReturn: AL = FFh if quoted batch file name matches last SHELLB parameter\nAL = 00h if it does not"
            0x04: "SHELLB transient to TSR intrface\nReturn: ES:DI -> name of current shell batch file:\nWORD   number of bytes of name following\nBYTEs (8 max) uppercase name of shell batch file"
      }
      0x1A: "- Multiplex - " { al ?
            0x00: "DOS 4+ ANSI.SYS internal - INSTALLATION CHECK\nReturn: AL = FFh if installed"
            0x01: "DOS 4+ ANSI.SYS internal - GET/SET DISPLAY INFORMATION\nCL = 7Fh for GET, 5Fh for SET, DS:DX -> parm block\nReturn: CF set on error, AX = error code\nCF clear if successful, AX destroyed"
            0x02: "DOS 4+ ANSI.SYS internal - MISC REQUESTS\nDS:DX -> parameter block"
            0x21: "AVATAR.SYS - SET DRIVER STATE\nDS:SI -> command string with one or more state characters\nCX = length of command string, Return: CF set on error\nCF clear if successful"
            0x3F: "AVATAR.SYS - QUERY DRIVER STATE\nES:DI -> buffer, CX = length of buffer in bytes\nReturn: CF clear\nCX = actual size of returned info"
      }
      0x1B: "- Multiplex - DOS 4+ XMA2EMS.SYS " { al ?
            0x00: "extension internal - INSTALLATION CHEC\nReturn: AL = FFh if installed"
            0x01: "extens internal - GET HIDDEN FRAME INFO\nDI = hidden physical page number\nReturn: AX = FFFFh if failed (no such hidden page)\nAX = 0000h if OK"
            0xFF: "internal??? - ???\nDI = ???\nReturn: AH = ???, ES:DI -> ???"
      }
      0x40: "- Multiplex - OS/2 compatibility box - " { al ?
            0x00: "SWITCH DOS TO BACKGROUND"
            0x02: "SWITCH DOS TO FOREGROUND"
      }
      0x43: "- Multiplex - XMS - " { al ?
            0x00: "INSTALLATION CHECK\nReturn: AL = 80h XMS driver installed\nAL <> 80h no driver"
            0x10: "GET DRIVER ADDRESS\nReturn: ES:BX -> driver entry point"
      }
      0x46: { al ? 0x80: "- Multiplex - MS Windows 3 - INSTALLATION CHECK\nReturn: AX = 0000h MS Windows 3.0 running in real (/R) or standard (/S) mode\nnonzero  no Windows, Windows prior to 3.0, or Windows3 in enhanced\nmode"
      }
      0x54: { al ? 0x53: "INT 2F - Multiplex - TesSeRact RAM-RESIDENT PROGRAM INTERFACE\n"
                         "BX=subfunction - " { bx ?
                0x00: "installation check\n"
                      "DS:SI -> 8-char blankpadded name\n"
                      "Return: AX=FFFFh installed, CX=ID of already-installed copy\n"
                      "AX=anything else, not installed, CX=ID for TSR when installed"
                0x01: "get user parameters\nCX = TSR ID number\nReturn: AX = 0000h successful, ES:BX -> user parameter block\nAX = nonzero failed"
                0x02: "check if hotkey in use\nCL = scan code of hot key\nReturn: AX = FFFFh hot key conflicts with another TSR\notherwise safe to use the hotkey"
                0x03: "replace default critical error handler\nCX = TSR ID number, DS:SI -> new routine for INT 24h\nReturn: AX = nonzero, unable to install new handler"
                0x04: "get internal data area\nCX = TSR ID number\nReturn: AX = 0000h, ES:BX -> TSR's internal data area\nAX = nonzero, TSR not found"
                0x05: "set multiple hot keys\nCX = TSR ID number, DL = number of additional hot keys to allocate\nDS:SI -> table of hot keys\nReturn: AX = nonzero, unable to install hot keys"
                0x10: "enable TSR\nCX = TSR ID number\nReturn: AX = nonzero, unable to enable"
                0x11: "disable TSR\nCX = TSR ID number\nReturn: AX = nonzero, unable to disable"
                0x12: "unload TSR\nCX = TSR ID number\nReturn: AX = nonzero, invalid TSR number"
                0x13: "restart TSR\nCX = TSR ID number of TSR which was unloaded but is still in memory\nReturn: AX = nonzero, unable to restart TSR"
                0x14: "get status word\nCX = TSR ID number\nReturn: AX = FFFFh invalid ID number\nAX = other, successful, BX = bit flags"
                0x15: "set status word\nCX = TSR ID number, DX = new bit flags\nget INDOS state at popup\nCX = TSR ID number\nReturn: AX = nonzero, unable to set status word"
                0x20: "call user procedure\nCX = TSR ID number, ES:DI -> user-defined data\nReturn: AX = 0000h successful"
                0x21: "stuff keystrokes into keyboard buffer\n"
                      "CX=TSR ID, DL=speed, DH=scan code flag\n"
                      "SI=number of keystrokes, ES:DI->buffer\n"
                      "Return: AX=0 ok\n"
                      "AX=F0F0h aborted with ^C or ^Break"
                0x22: "(v1.10) trigger popup\nCX = TSR ID number\nReturn: AX = 0000h success, TSR will either pop up or beep to\nindicate that it is unable to pop up\nAX = nonzero invalid ID number"
                0x23: "(v1.10) invoke TSR's background function\nCX = TSR ID number\nReturn: AX = 0000h success\nAX = FFFFh not safe to call background function\nnonzero invalid ID number"
            }
      }
      0x64: "- Multiplex - SCRNSAV2.COM - INSTALLATION CHECK\nReturn: AL = 00h not installed\nAL = FFh installed"
      0x7A: "- Multiplex - Novell NetWare - " { al ?
            0x00: "LOW-LEVEL API (IPX) INSTALLATION CHECK\nReturn: AL = 00h not installed\nAL = FFh installed\nES:DI -> FAR entry point for routines accessed through INT 7Ah\nin NetWare versions through 2.0a"
            0x80: "shell 3.01d - ???"
            0x81: "shell 3.01d - ???\nCX:DX -> ??? in shell's CS (may be callback address or data structure)"
            0x85: "shell 3.01 - BROADCAST INFORM\nCX = broadcast server number\nReturn: CX = 0000h if broadcast message handled by another program\nCX unchanged if broadcast not handled"
            0xFE: "shell 3.01d - ???\nReturn: AL = FFh ???\nother ???"
            0xFF: "shell 3.01d - ???\nBX = 0001h, CX = offset of ???, DX = offset of ???\nReturn: CX unchanged if ???"
      }
      0x80: "- Multiplex - EASY-NET - INSTALLATION CHECK\nReturn: AL = 00h not installed\nAL = FFh installed"
      0x89: "- Multiplex - WHOA!.COM - " { al ?
            0x00: "INSTALLATION CHECK\nReturn: AL = 00h not installed\nAL = FFh installed"
            0x01: "UNINSTALL\nReturn: AL = FDh successful\nAL = FEh error"
            0x02: "SET DELAY COUNT\nBX = delay count (larger values slow system down more)\nReturn: AL = FDh successful\nAL = FEh error"
      }
      0x90: " - Multiplex - RAID - ???"
      0xAA: " - Multiplex - VIDCLOCK.COM - INSTALLATION CHECK\nReturn: AL = 00h not installed\nAL = FFh installed"
      0xAD: " - Multiplex - DOS " { al ?
            0x00: "3.3+ DISPLAY.SYS internal - INSTALLATION CHECK\nReturn: AL = FFh if installed\nBX = ??? (0100h in MS-DOS 3.30, PCDOS 4.01)"
            0x01: "3.3+ DISPLAY.SYS internal - SET ???\nReturn: ???, CF set on error"
            0x02: "3.3+ DISPLAY.SYS internal - GET ???\nReturn: BX = ??? (value set with AX=AD01h)"
            0x03: "3.3+ DISPLAY.SYS internal - GET ???\nES:DI -> user buffer, CX = size of buffer\nReturn: CF set if buffer too small\nCF clear if successful"
            0x04: "4+ DISPLAY.SYS internal - ???"
            0x10: "4+ DISPLAY.SYS internal - INSTALLATION CHECK???\nReturn: AX = FFFFh\nBX = ??? (0100h in PCDOS 4.01)"
            0x40: "4.0 - ???"
            0x80: "3.3+ KEYB.COM internal - INSTALLATION CHECK\nReturn: AL = FFh if installed\nBX = ??? (0100h in MSDOS 3.30 and PCDOS 4.01)\nES:DI -> internal data"
            0x81: "3.3+ KEYB.COM internal - SET KEYBOARD CODE PAGE\nBX = code page\nReturn: CF set on error, AX = 0001h (code page not available)\nCF clear if successful"
            0x82: "3.3+ KEYB.COM internal - SET KEYBOARD MAPPING\nBL = 00h US keyboard (Control-Alt-F1)\n   = FFh foreign keyboard (Control-Alt-F2)\nReturn: CF set on error (BL not 00h or FFh)\nCF clear if successful"
      }
      0xAE: "- Multiplex - DOS 3.3+ internal - " { al ?
            0x00: "INSTALLABLE COMMAND - INSTALL CHECK\nDX = FFFFh, DS:BX -> command line\nReturn: AL = FFh if this command is a TSR extension to COMMAND.COM\nAL = 00h if the command should be executed as usual"
            0x01: "INSTALLABLE COMMAND - EXECUTE\nDX = FFFFh, DS:SI -> buffer\nReturn: buffer at DS:SI filled with a length byte followed by the uppercase\ninternal command to execute (if length not 0)"
      }
      0xB0: "- Multiplex - DOS 3.3+ GRAFTABL.COM - " { al ?
            0x00: "INSTALLATION CHECK\nReturn: AL = 00h not installed, OK to install\nAL = 01h not installed, not OK to install\nAL = FFh installed"
            0x01: "GET ???\nDS:DX -> 4-byte buffer\nReturn: buffer filled\nAL = FFh"
      }
      0xB4: " - Multiplex - IBM PC3270 EMUL PROG v3 - " { al ?
            0x00: "INSTALLATION CHECK\nReturn: AL = FFh if installed"
            0x01: "GET HOST BUFFER ADDRESS\nReturn: ES -> host screen buffer (PC ASCII format)\nES unchanged if communications not started"
            0x02: "???"
            0x03: "???"
            0x04: "???"
            0x05: "???"
      }
      0xB7: "- Multiplex - " { al ?
            0x00: "APPEND - INSTALLATION CHECK\nReturn: AL = 00h not installed\nAL = FFh if installed"
            0x01: "APPEND - ???"
            0x02: "APPEND - VERSION CHECK\nReturn: AX = FFFFh if not DOS 4.0 APPEND\nAL = major version number\nAH = minor version number, otherwise"
            0x03: "DOS 3.3 APPEND - HOOK INT 21\nES:DI -> INT 21 handler APPEND should chain to\nReturn: ES:DI -> APPEND's INT 21 handler"
            0x04: "DOS 3.3+ APPEND - GET APPEND PATH\nReturn: ES:DI -> active APPEND path (128 bytes max)"
            0x06: "DOS 4.0 APPEND - GET APPEND FUNCTION STATE\nReturn: BX = APPEND state"
            0x07: "DOS 4.0 APPEND - SET APPEND FUNCTION STATE\nBX = APPEND state bits"
            0x10: "DOS 3.3+ APPEND - GET VERSION INFO\nReturn: AX = ???, BX = ??? (0000h in MSDOS 3.30), CX = ??? (0000h in MSDOS 3.30)\nDL = major version, DH = minor version"
            0x11: "DOS 4.0 APPEND - SET RETURN FOUND NAME STATE"
      }
      0xB8: "- Multiplex - Network - " { al ?
            0x00: "INSTALLATION CHECK\nReturn: AL = 00h not installed\nAL = nonzero installed, BX = installed component flags (test in this order!)\nbit 6   server, bit 2   messenger, bit 7   receiver, bit 3   redirector"
            0x03: "GET CURRENT POST HANDLER ADDRESS\nReturn: ES:BX = post address"
            0x04: "SET NEW POST HANDLER ADDRESS\nES:BX -> new FAR post handler\nReturn: AX = 0000h user post routine processed message\nAX = 0001h PC LAN will process message, but message window not displayed\nAX = FFFFh PC LAN will process message"
            0x07: "GET NetBIOS NAME NUMBER OF MACHINE NAME\nReturn: CH = NetBIOS name number of the machine name"
            0x08: "???"
            0x09: "VERSION CHECK\nReturn: AH = major version\nAL = minor version"
      }
      0xB9: "- PC Network RECEIVER.COM - " { al ?
            0x00: "INSTALLATION CHECK\nReturn: AL = 00h if not installed\nAL = FFh if installed"
            0x01: "GET RECEIVER.COM INT 2F HANDLER ADDRESS\nReturn: AL = ???\nES:BX -> RECEIVER.COM INT 2F handler"
            0x03: "GET RECEIVER.COM POST ADDRESS\nReturn: ES:BX -> POST handler"
            0x04: "SET RECEIVER.COM POST ADDRESS\nES:BX -> new POST handler"
            0x05: "GET FILENAME\nDS:BX -> 128-byte buffer for filename 1\nDS:DX -> 128-byte buffer for filename 2\nReturn: buffers filled from RECEIVER.COM internal buffers"
            0x06: "SET FILENAME\nDS:BX -> 128-byte buffer for filename 1\nDS:DX -> 128-byte buffer for filename 2\nReturn: RECEIVER.COM internal buffers filled from user buffers"
            0x08: "UNLINK KEYBOARD HANDLER\nES:BX -> INT 09 handler RECEIVER should call after it finishes INT 09"
      }
      0xBC: "- Multiplex - Windows 3.0 EGA.SYS - " { al ?
            0x00: "INSTALLATION CHECK\nReturn: AL = 00h not installed, OK to install\nAL = 01h not installed, not OK to install\nAL = FFh installed, BX = 5456h (\"TV\")"
            0x06: "???\nReturn: CX = 020Ah, DL = 12h"
      }
      0xBF: "- Multiplex - PC LAN PROGRAM REDIRIFS.EXE internal - " { al ?
            0x00: "INSTALLATION CHECK\nReturn: AL = FFh if installed"
            0x01: "???"
            0x80: "SET REDIRIFS ENTRY POINT\nES:DI -> FAR entry point to IFS handler in REDIRIFS\nReturn: AL = FFh if installed, ES:DI -> internal workspace"
      }
      0xCB: "- Multiplex - Communicating Applications Spec - " { al ?
            0x00: "INSTALLATION CHECK\nReturn: AL = 00h not installed, OK to install\nAL = 01h not installed, not OK to install\nAL = FFh installed"
            0x01: "SUBMIT A TASK\nDS:DX -> ASCIZ name of task control file\nReturn: AX >= 0: event handle\nAX < 0: error code"
            0x02: "ABORT CURRENT EVENT\nReturn: AX >= 0: event handle of aborted event (>= 0)\nAX < 0: error code"
            0x05: "FIND FIRST QUEUE ENTRY\nCX = status of events to find" { cx ?
                  0x00: "successful completion"
                  0x01: "waiting to be processed"
                  0x02: "number has been dialed"
                  0x03: "connection established, sending"
                  0x04: "connection established, receiving"
                  0x05: "even aborted"
                  //?*? 0xFFFFh: "find any event, regardless of status"
            }
            //?*?\nReturn: AX = 0000h successful, BX = event handle for found event\nAX < 0 error code"
            0x06: "FIND NEXT QUEUE ENTRY\nDL = queue to search - " { dl ?
                  0x00: "task queue"
                  0x01: "receive queue"
                  0x02: "log queue"
            }
            //?*?\nReturn: AX = 0000h successful, BX = event handle for found event\nAX < 0        error code"
            0x07: "OPEN FILE\nBX = event handle\nCX = receive file number (ignored for task queue and log queue)\nReturn: AX = 0000h successful, BX = DOS file handle for requested file\nAX < 0 error code"
            0x08: "DELETE FILE\nBX = event handle, CX = receive file number, DL = queue\nReturn: AX = 0000h successful\nAX < 0 error code"
            0x09: "DELETE ALL FILES IN Q\nDL = queue - " { dl ?
                  0x00: "delete all control files in task queue"
                  0x01: "delete all files in receive queue"
                  0x02: "delete all control files in log queue"
            }
            //?*?\nReturn: AX = 0000h successful\nAX < 0 error code"
            0x0A: "GET EVENT DATE\nBX = event handle, DL = queue - " { dl ?
                0x00: "task queue"
                0x01: "receive queue"
                0x02: "log queue"
            }
            0x0B: "SET TASK DATE\nBX = event handle (task event only), CX = year\nDH = month, DL = day\nReturn: AX = 0000h successful\nAX < 0      error code"
            0x0C: "GET EVENT TIME\nBX = event handle, DL = queue, 00h task queue\nReturn: AX = 0000h successful, CH = hour, CL = minute, DH = second, DL = 00h\nAX < 0     error code"
            0x0D: "SET TASK TIME\nBX = event handle (task events only), CH = hour\nCL = minute, DH = second, DL unused\nReturn: AX = 0000h successful\nAX < 0      error code"
            0x0E: "GET EXTERNAL DATA BLOCK\nDS:DX -> 256-byte buffer\nReturn: AX = 0000h successful, buffer filled\nAX < 0         error code"
            0x0F: "GET/SET AUTORECEIVE\n"
                  "DL: (0-get/1-set) current autoreceive state\n"
                  "DH=number of rings before answer, 0=never\n"
                  "Return: AX=0 autoreceive disabled\n"
                  "AX=N number of rings before answer\n"
                  "AX<0 error code"
            0x10: "GET EVENT STATUS\nDS:DX -> 511-byte buffer\nReturn: AX = 0000h successful, BX = event handle of current event, buffer filled\nAX < 0    error code"
            0x11: "GET QUEUE STATUS\nDL = queue to get status of - " { dl ?
                      0x00: "task queue"
                      0x01: "receive queue"
                      0x02: "log queue"
            }
            //?*?Return: AX >= 0  total number of changes made to queue, modulo 32768
            //  BX = number of control files currently in queue
            //  CX = number of received files (zero for task and log queues)
            //AX < 0 error code
            0x12: "GET HARDWARE STATUS\nDS:DX -> 128-byte status buffer\nReturn: AX = 0000h successful\nAX < 0     error code"
            0x13: { dl ?
                  0x00: "GET DIAGNOSTICS RESULTS\nReturn: AX = 0040h in progress\nAX > 0           passed\nAX < 0          failure code"
                  0x01: "START DIAGNOSTICS\nReturn: AX = 0000h successfully started\nAX < 0        error code"
            }
            0x14: "MOVE RECEIVED FILE\nBX = event handle, CX = receive file number\nDS:DX -> ASCIZ string specifying new name for file\nReturn: AX = 0000h successful\nAX < 0 error code"
            0x15: "SUBMIT FILE TO SEND\nDS:DX -> variable-length data area\nReturn: AX >= 0 event handle\nAX < 0 error code"
      }
      0xCD: " - Multiplex - " { al ?
            0x00: "Intel Image Processing Interface - INSTALLATION CHECK\nReturn: AL = 00h not installed, OK to install\nAL = 01h not installed, not OK to install\nAL = FFh installed"
            0x01: "Intel Image Processing Interface - SET DEVICE NAME\nCX:BX -> ASCIZ character device name (\"LPT\" \"COM\" \"PRN\")\nReturn: AL = 00h successful, CX:BX -> internal character device name\nAL = 80h error"
            0x02: "Intel Image Processing Interface - GET VERSION NUMBER\nReturn: AL = 00h-01h successful, BH = major version number (BCD)BL = minor version number (BCD), AL = 80h error"
            0x03: "Intel Image Processing Interface - SELECT SCAN LINE\nBX = scan line\nCX = requested density in dots per inch (300, 600, or 1200)\nReturn: AL = 00h succesful\nAL = 80h unsuccessful"
            0x04: "Intel Image Processing Interface - MOVE BITMAP TO SCANLINE\nCX:BX -> structure\nReturn: AL = 00h successful\nAL = 80h unsuccessful"
            0x05: "Intel Image Processing Interface - PRINT PAGE\nReturn: AL = 00h successful\nAL = 80h unsuccessful"
            0x06: "Intel Image Processing Interface - CLEAR PAGE\nReturn: AL = 00h successful\nAL = 80h unsuccessful"
            0x07: "Intel Image Processing Interface - reserved"
            0x08: "Intel Image Processing Interface - SCREEN IMAGE\nCX:BX -> structure\nReturn: AL = 00h successful\nAL = 80h unsuccessful"
            0x09: "Intel Image Processing Interface - LOAD SCREEN\nCX:BX -> structure\nReturn: AL = 00h successful\nAL = 80h unsuccessful"
            0x0A: "Intel Image Processing Interface - LOAD PALETTE\nCX:BX -> palette structure\nReturn: AL = 00h successful\nAL = 80h unsuccessful"
      }
      0xD2: "- Multiplex - Quarterdeck " { al ?
            0x00: "QEMM/QRAM/MFT 5.0 - INSTALLATION CHECK\nBX = 5144h (\"QD\"), CX = 4D45h (\"ME\"), DX = 4D30h (\"M0\")\nReturn: AL = FFh installed\nif BX,CX,DX registers were as specified on entry"
            0x01: "QEMM/QRAM 5.0 - GET HIRAM MEMORY CHAIN\nBX = 4849h (\"HI\"), CX = 5241h (\"RA\"), DX = 4D30h (\"M0\")\nReturn: BX = 4F4Bh (\"OK\")\nCX = segment of start of HIRAM chain\nDX = QEMM/QRAM code segment"
      }
      0xD4: "- Multiplex - " { al ?
            0x4D: "4DOS.COM v2.1+\nBH = " { bh ?
                  0x00: "installation check\nReturn: AX = 44DDh, BL = minor version number\nBH = major version number, CX = PSP segment address for current invocation\nDL = 4DOS shell number (0 for the first (root) shell"
                  0x01: "(internal) terminate current copy of 4DOS"
                  0x02: "???\nDX = ???"
                  0x03: "EXEC program\nCX:DX -> EXEC record"
                  0xFE: "deallocate shell number (passed through to root shell)"
                  0xFF: "allocate shell number (passed through to root shell)"
            }
            0x4E: "4DOS.COM v3.0+ - AWAITING USER INPUT\nBX = 0000h 4DOS is ready to display prompt\n   = 0001h 4DOS has displayed the prompt, about to accept user input\nReturn: handler must preserve SI, DI, BP, SP, DS, ES, and SS"
      }
      0xD7: { al ? 0x01: "- Multiplex - BANYAN VINES v4+ - GET BANV INTERRUPT NUMBER\nReturn: AX = 0000h installed, BX = interrupt number (60h to 66h)\nAX = nonzero not present"
      }
      0xDA: { al ? 0x55: "- Multiplex - TRAP.COM - INSTALLATION CHECK\nDL = interrupt number\nReturn: if installed, AH = interrupt number\nAL = ???, ES:BX -> ???"
      }
      0xDE: "- Multiplex - DESQview 2.26 " { al ?
            0x00: "External Dev Interface - INSTALLATION CHECK\nBX = 4445h (\"DE\"), CX = 5844h (\"XD\"), DX = 4931h (\"I1\")\nReturn: AL = FFh if installed\nif BX,CX, and DX were as specified on entry"
            0x01: "External Dev Itrface - DRIVER CUSTOM SUBFUNC\nBX = driver ID\nother registers as needed by driver"
            0x02: "External Device Interface - DV INIT COMPLETE\nBX = mapping context of DESQview\nDX = handle of DESQview system task"
            0x03: "External Device Interface - DV TERMINATION\nBX = mapping context of DESQview\nDX = handle of DESQview system task"
            0x04: "External Device Interface - ADD PROCESS\nBX = mapping context of new process\nDX = handle of process"
            0x05: "External Device Interface - REMOVE PROCESS\nBX = mapping context of process\nDX = handle of last task in process"
            0x06: "XDI - CREATE TASK\nBX = mapping context of process containing task\nDX = handle of new task"
            0x07: "XDI - TERMINATE TASK\nBX = mapping context of process containing task\nDX = handle of task"
            0x08: "XDI - SAVE STATE\nBX = mapping context of task being switched from\nDX = handle of task being switched from"
            0x09: "XDI - RESTORE STATE\nBX = mapping context of task being switched to\nDX = handle of task being switched to"
            0x0A: "XDI - CHANGE KEYBOARD FOCUS\nBX = mapping context of task receiving focus\nDX = handle of running task"
            0x0B: "XDI - DVP PROCESSING COMPLETE\n"
                  "BX=mapping context of DESQview\n"
                  "CX=number of memory paragraphs\n"
                  "DX=handle of DESQview system task\n"
                  "SI=mapping context of new process\n"
                  "ES:DI -> DVP buffer\n"
                  "Return: CX incremented"
            0x0C: "XDI - SWAP OUT PROCESS\nBX = mapping context of task being swapped out\nDX = handle of DESQview system task"
            0x0D: "XDI - SWAP IN PROCESS\nBX = mapping context of process just swapped in\nDX = handle of DESQview system task"
            0x0E: "XDI - DVP START FAILED\nBX = mapping context of DESQview system task\nDX = handle of DESQview system task\nSI = mapping context of failed process (same as for call to AX=DE0Bh)"
      }
      0xE3: "- Multiplex - ANARKEY.COM - " { ah ?
            0x00: "INSTALLATION CHECK\nReturn: AL = 00h not installed\nAL = FEh if installed but suspended (v3.0+)\nAL = FFh installed"
            0x01: "v2+ - GET ???\nReturn: DX:BX -> ???"
            0x02: "v3.0 - ???"
            0x03: "v3.0 - ANARKMD API\nBL = function - " { bl ?
                      0x01: " toggle insert mode"
                      0x02: " display contents of history buffer"
                      0x03: " write history buffer to file\nES:DX -> file name"
                      0x04: " clear history buffer"
                      0x05: " undefine all aliases"
                      0x06: " show aliases"
                      0x07: " list programs using Unix switchar"
                      0x08: " jump to bottom of history buffer"
            }
            0x04: "v2.0 - ???"
            0x05: "v3.0 - SUSPEND ANARKEY\nBL = 01h suspend / 00h enable"
      }
      0xF7: "- Multiplex - AUTOPARK.COM - " { al ?
            0x00: "INSTALLATION CHECK\nReturn: AL = 00h not installed\nAL = FFh installed"
            0x01: "SET PARKING DELAY\nBX:CX = 32 bit count of 55ms timer ticks"
      }
      0xFB: "- Multiplex - RESERVED BY BORLAND INTERNATIONAL"
      0xFF: "- Multiplex - Topware Network Operating System - " { al ?
            0x00: "INSTALLATION CHECK\nReturn: AL = 00h not installed, OK to install\nAL = 01h not installed, not OK to install\nAL = FFh installed"
            0x01: "GET VERSION\nReturn: AX = version"
      }
}
0x30: "(NOT A VECTOR!) FAR JMP instruction for CP/M-style calls"
0x31: "DPMI Services   ax=func xxxxh\n" { ah ?
      0x00: { al ?
            0x00: "ALLOCATE LDT DESCRS\nCX = number of descriptors to allocate\nReturn: CF set on error\nCF clear if successful, AX = base selector"
            0x01: "FREE LDT DESCRIPTOR\nBX = selector to free\nReturn: CF set on error\nCF clear if successful"
            0x02: "SEGMENT TO DESCRIPTOR\nBX = real mode segment\nReturn: CF set on error\nCF clear if successful, AX = selector corresponding to real mode segment (64K limit)"
            0x03: "GET NEXT SELECTOR INCREMENT VALUE\nReturn: CF set on error\nCF clear if successful, AX = selector corresponding to real mode segment (64K limit)"
            0x04: "RESERVED"
            0x05: "RESERVED"
            0x06: "GET SEGMENT BASE ADDRESS\nBX = selector\nReturn: CF set on error\nCF clear if successful, CX:DX = linear base address of segment"
            0x07: "SET SEGMENT BASE ADDRESS\nBX = selector, CX:DX = linear base address\nReturn: CF set on error\nCF clear if successful"
            0x08: "SET SEGMENT LIMIT\nBX = selector, CX:DX = segment limit\nReturn: CF set on error\nCF clear if successful"
            0x09: "SET DESCRIPTOR ACCESS RIGHTS\nBX = selector, CL = access rights/type byte\nCH = 80386 extended rights/type byte (32-bit DPMI implementations only)\nReturn: CF set on error\nCF clear if successful"
            0x0A: "CREATE CODE SEGMENT ALIAS DESCRIPTOR\nBX = code segment selector\nReturn: CF set on error\nCF clear if successful, AX = new data selector"
            0x0B: "GET DESCRIPTOR\nBX = selector, ES:DI / ES:EDI -> 8-byte buffer for copy of descriptor\nReturn: CF set on error\nCF clear if successful"
            0x0C: "SET DESCRIPTOR\nBX = selector, ES:DI / ES:EDI -> 8-byte buffer containing descriptor\nReturn: CF set on error\nCF clear if successful"
            0x0D: "ALLOCATE SPECIFIC LDT DESCRIPTOR\nBX = selector\nReturn: CF set on error\nCF clear if successful, descriptor allocated"
            0x0E: "get cx LDTs into buffer es:di"
            0x0F: "set cx LDTs from buffer es:di"
      }
      0x01: { al ?
            0x00: "ALLOCATE DOS MEMORY BLOCK\nBX = number of paragraphs to allocate\nReturn: CF set on error\nCF clear if successful"
            0x01: "FREE DOS MEMORY BLOCK\nDX = selector of block\nReturn: CF set on error\nCF set if successful"
            0x02: "RESIZE DOS MEMORY BLOCK\nBX = new block size in paragraphs, DX = selector of block\nReturn: CF set on error\nCF clear if successful"
      }
      0x02: { al ?
            0x00: "GET REAL MODE INTERRUPT VECTOR\nBL = interrupt number\nReturn: CF clear, CX:DX = segment:offset of real mode interrupt handler"
            0x01: "SET REAL MODE INTERRUPT VECTOR\nBL = interrupt number, CX:DX = segment:offset of real mode handler\nReturn: CF set on error\nCF clear if successful"
            0x02: "GET PROCESSOR EXCEPTION HANDLER VECTOR\nBL = exception number (00h-1Fh)\nReturn: CF set on error\nCF clear if successful, CX:DX / CX:EDX = selector:offset of handler"
            0x03: "SET PROCESSOR EXCEPTION HANDLER VECTOR\nBL = exception number (00h-1Fh), CX:DX / CX:EDX = selector:offset of handler\nReturn: CF set on error\nCF clear if successful"
            0x04: "GET PROTECTED MODE INTERRUPT VECTOR\nBL = interrupt number\nReturn: CF set on error\nCF clear if successful, CX:DX / CX:EDX = selector:offset of handler"
            0x05: "SET PROTECTED MODE INTERRUPT VECTOR\nBL = interrupt number, CX:DX / CX:EDX = selector:offset of handler\nReturn: CF set on error\nCF clear if successful"
            0x10: "get extd exceptn bl in cx:dx"
            0x11: "get extd exceptn bl in cx:dx"
            0x12: "set extd exceptn bl to cx:dx"
            0x13: "set extd exceptn bl to cx:dx"
      }
      0x03: { al ?
            0x00: "SIMULATE REAL MODE INTERRUPT\n"
                  "BL=interrupt number\n"
                  "CX=number of words to copy from protected mode to real mode stack\n"
                  "ES:DI / ES:EDI = selector:offset of real mode call structure\n"
                  "Return: CF set on error\n"
                  "CF clear if ok"
            0x01: "CALL REAL MODE PROC WITH FAR RET FRAME\nCX = number of words to copy from protected mode to real mode stack\nES:DI / ES:EDI = selector:offset of real mode call structure\nReturn: CF set on error\nCF clear if successful"
            0x02: "CALL REAL MODE PROC WITH IRET FRAME\nCX = number of words to copy from protected mode to real mode stack\nES:DI / ES:EDI = selector:offset of real mode call structure\nReturn: CF set on error\nCF clear if successful"
            0x03: "ALLOCATE REAL MODE CALL-BACK ADDRESS\n"
                  "DS:SI=selector:offset of procedure to call\n"
                  "ES:DI=selector:offset of real mode call structure\n"
                  "Return: CF set on error\n"
                  "CF clear if ok, CX:DX = segment:offset of real mode call address"
            0x04: "FREE REAL MODE CALL-BACK ADDRESS\nCX:DX = real mode call-back address\nReturn: CF set on error\nCF clear if successful"
            0x05: "GET STATE SAVE/RESTORE ADDRESSES\nReturn: CF set on error\nCF clear if successfule"
            0x06: "GET RAW MODE SWITCH ADDRESSES\nReturn: CF set on error\nCF clear if successful"
      }
      0x04: { al ?
            0x00: "GET DPMI VERSION\nReturn: CF clear, AH = major version, AL = minor version\nBX = flags, CL = processor type\nDH = curr value of virtual master interrupt controller base\nDL = curr value of virtual slave interrupt controller base"
            0x01: "get DPMI capabilities, es:di"
      }
      0x05: { al ?
            0x00: "GET FREE MEMORY INFORMATION\nES:DI / ES:EDI -> buffer for memory information\nReturn: CF clear"
            0x01: "ALLOCATE MEMORY BLOCK\nBX:CX = size in bytes\nReturn: CF set on error\nCF clear if successful"
            0x02: "FREE MEMORY BLOCK\nSI:DI = handle of memory block\nReturn: CF set on error\nCF clear if successful"
            0x03: "RESIZE MEMORY BLOCK\nBX:CX = new size in bytes, SI:DI = handle of memory block\nReturn: CF set on error\nCF clear if successful"
            0x04: "allocate linear mem block"
            0x05: "resize linear mem block"
            0x06: "get page fault attributes"
            0x07: "set page attributes"
            0x08: "map device in memory block"
            0x09: "map DOS mem in memory block"
            0x0A: "get mem block size & base"
            0x0B: "get mem info, ptr es:di"
      }
      0x06: { al ?
            0x00: "LOCK LINEAR REGION\nBX:CX = starting linear address\nSI:DI = size of region in bytes\nReturn: CF set on error\nCF clear if successful"
            0x01: "UNLOCK LINEAR REGION\nBX:CX = starting linear address, SI:DI = size of region in bytes\nReturn: CF set on error\nCF clear if successful"
            0x02: "MARK REAL MODE REGION AS PAGEABLE\nBX:CX = starting linear address, SI:DI = size of region in bytes\nReturn: CF set on error\nCF clear if successful"
            0x03: "RELOCK REAL MODE REGION\nBX:CX = starting linear address, SI:DI = size of region in bytes\nReturn: CF set on error\nCF clear if successful"
            0x04: "GET PAGE SIZE\nReturn: CF set on error\nCF clear if successful"
      }
      0x07: { al ?
            0x00: "RESERVED"
            0x01: "RESERVED"
            0x02: "MARK PAGE AS DEMAND PAGING CANDIDATE\nBX:CX = starting linear address\nSI:DI = number of bytes to mark as paging candidates\nReturn: CF set on error\nCF clear if successful"
            0x03: "DISCARD PAGE CONTENTS\nBX:CX = starting linear address\nSI:DI = number of bytes to mark as paging candidates\nReturn: CF set on error\nCF clear if successful"
      }
      0x08: { al ?
            0x00: "PHYSICAL ADDRESS MAPPING\nBX:CX = physical address, SI:DI = size in bytes\nReturn: CF set on error\nCF clear if successful\nBX:CX = linear address which maps the requested physical memory"
            0x01: "free physical address mapping"
      }
      0x09: { al ?
            0x00: "GET AND DISABLE VIRTUAL INTERRPT STATE\nReturn: CF clear, AH preserved\nAL = 00h if previously disabled\nAL = 01h if previously enabled"
            0x01: "GET AND ENABLE VIRTUAL INTERRUPT STATE\nReturn: CF clear, AH preserved\nAL = 00h if previously disabled\nAL = 01h if previously enabled"
            0x02: "GET VIRTUAL INTERRUPT STATE\nReturn: CF clear\nAL = 00h if disabled\nAL = 01h if enabled"
      }
      0x0A: { al ?
            0x00: "GET VENDOR SPECIFIC API ENTRY POINT\nDS:SI -> case-sensitive ASCIZ vendor name or identifier\nReturn: CF set on error, CF clear if successful\nES:DI -> FAR extended API entry point\nDS,FS,GS,EAX,EBX,ECX,EDX,ESI,EBP destroyed"
      }
      0x0B: { al ?
            0x00: "SET DEBUG WATCHPOINT\nBX:CX = linear address, DL = size (1,2,4 bytes)\nDH = type (00h execute, 01h write, 02h read/write)\nReturn: CF set on error\nCF clear if successful, BX = watchpoint handle"
            0x01: "CLEAR DEBUG WATCHPOINT\nBX = watchpoint handle\nReturn: CF set on error\nCF clear if successful"
            0x02: "GET STATE OF DEBUG WATCHPOINT\nBX = watchpoint handle\nReturn: CF set on error\nCF clear if successful, AX = status flags"
            0x03: "RESET DEBUG WATCHPOINT\nBX = watchpoint handle\nReturn: CF set on error\nCF clear if successful"
      }
      0x0C: { al ?
            0x00: "install resident callback "
            0x01: "terminate and stay resident"
      }
      0x0D: { al ?
            0x00: "allocate shared memory es:di"
            0x01: "free shared memory si:di"
            0x02: "serialize on shared mem si:di"
            0x03: "free serialized shared mem"
      }
      0x0E: { al ?
            0x00: "get co-processor status in ax"
            0x01: "set co-processor emulation bx"
      }
}
0x32: "reportedly used by \"Tiny\" Viruses"
0x33: "- MS MOUSE - " { al ?
      0x00: "RESET DRIVER AND READ STATUS\nReturn: AX = status\nBX = number of buttons"
      0x01: "SHOW MOUSE CURSOR\nSeeAlso: AX=0002h, INT 16/AX=FFFEh"
      0x02: "HIDE MOUSE CURSOR\nSeeAlso: AX=0001h, INT 16/AX=FFFFh"
      0x03: "RETURN POSITION AND BUTTON STATUS\nReturn: BX = button status, CX = column, DX = row"
      0x04: "POSITION MOUSE CURSOR\nCX = column, DX = row"
      0x05: "RETURN BUTTON PRESS DATA\nBX = button\nReturn: AX = button states\nBX = number of times specified button has been pressed\nCX = column at time specified button was last pressed\nDX = row at time specified button was last pressed"
      0x06: "RETURN BUTTON RELEASE DATA\nBX = button " { bx ?
            0x00: "left"
            0x01: "right"
            0x02: "middle"
      }
      //"\nReturn: AX = button states\nBX = number of times specified button has been released\nCX = column at time specified button was last released\nDX = row at time specified button was last released"
      0x07: "DEFINE HORIZONTAL CURSOR RANGE\nCX = minimum column, DX = maximum column"
      0x08: "DEFINE VERTICAL CURSOR RANGE\nCX = minimum row, DX = maximum row"
      0x09: "DEFINE GRAPHICS CURSOR\nBX = column of cursor hot spot in bitmap (-16 to 16)\nCX = row of cursor hot spot (-16 to 16)\nES:DX -> bitmap"
      0x0A: "DEFINE TEXT CURSOR\nBX = hardware/software text cursor\n0000h software, CX = screen mask, DX = cursor mask\n0001h hardware, CX = start scan line, DX = end scan line"
      0x0B: "READ MOTION COUNTERS\nReturn: CX = number of mickeys mouse moved horizontally since last call\nDX = number of mickeys mouse moved vertically"
      0x0C: "DEFINE INTERRUPT SUBROUTINE PARAMETERS\nCX = call mask, ES:DX -> FAR routine"
      0x0D: "LIGHT PEN EMULATION ON\nSeeAlso: AX=000Eh"
      0x0E: "LIGHT PEN EMULATION OFF\nSeeAlso: AX=000Dh"
      0x0F: "DEFINE MICKEY/PIXEL RATIO\nCX = number of mickeys per 8 pixels horizontally (default 8)\nDX = number of mickeys per 8 pixels vertically (default 16)"
      0x10: "DEFINE SCREEN REGION FOR UPDATING\nCX,DX = X,Y coordinates of upper left corner\nSI,DI = X,Y coordinates of lower right corner"
      0x12: "SET LARGE GRAPHICS CURSOR BLOCK\nBH = cursor width in words, CH = rows in cursor\nBL = horizontal hot spot (-16 to 16), CL = vertical hot spot (-16 to 16)\nES:DX -> bit map of screen and cursor maps\nReturn: AX = FFFFh if successful"
      0x13: "DEFINE DOUBLE-SPEED THRESHOLD\nDX = threshold speed in mickeys/second, 0000h = default of 64/second"
      0x14: "EXCHANGE INTERRUPT SUBROUTINES\nCX = call mask, ES:DX -> FAR routine\nReturn: CX = call mask of previous interrupt routine\nES:DX = FAR address of previous interrupt routine"
      0x15: "RETURN DRIVER STORAGE REQUIREMENTS\nReturn: BX = size of buffer needed to store driver state"
      0x16: "SAVE DRIVER STATE\nES:DX -> buffer for driver state"
      0x17: "RESTORE DRIVER STATE\nES:DX -> buffer containing saved state"
      0x18: "SET ALTERNATE MOUSE USER HANDLER\nCX = call mask, ES:DX = address of FAR routine\nReturn: AX = 0018h if successful, AX = FFFFh on error"
      0x19: "RETURN USER ALTERNATE INTERRUPT VECTOR\nCX = call mask\nReturn: BX:DX = user interrupt vector, CX = call mask (0 if not found)"
      0x1A: "SET MOUSE SENSITIVITY\nBX = horizontal speed, CX = vertical speed\nDX = double speed threshold"
      0x1B: "1BRETURN MOUSE SENSITIVITY\nReturn: BX = horizontal speed, CX = vertical speed\nDX = double speed threshold"
      0x1C: "SET INTERRUPT RATE\nBX = rate - " { bx ?
                0x00: "no interrupts allowed"
                0x01: "30 per second"
                0x02: "50 per second"
                0x03: "100 per second"
                0x04: "200 per second"
      }
      0x1D: "DEFINE DISPLAY PAGE NUMBER\nBX = display page number"
      0x1E: "RETURN DISPLAY PAGE NUMBER\nReturn: BX = display page number"
      0x1F: "DISABLE MOUSE DRIVER\nReturn: AX = 001Fh successful, AX = FFFFh unsuccessful\nES:BX = vector for INT 33h before mouse driver was first installed"
      0x20: "ENABLE MOUSE DRIVER"
      0x21: "SOFTWARE RESET\nReturn: AX = FFFFh if mouse driver installed\nAX = 0021h if mouse driver not installed\nBX = 2 if mouse driver is installed"
      0x22: "SET LANGUAGE FOR MESSAGES\nBX = language - " { bx ?
            0x00: "English"
            0x01: "French"
            0x02: "Dutch"
            0x03: "German"
            0x04: "Swedish"
            0x05: "Finnish"
            0x06: "Spanish"
            0x07: "Portugese"
            0x08: "Italian"
      }
      0x23: "GET LANGUAGE FOR MESSAGES\nReturn: BX = language"
      0x24: "GET SOFTWARE VERSION AND MOUSE TYPE\nReturn: AX = FFFFh on error\notherwise, BH = major version, BL = minor version\nCH = type (1=bus, 2=serial, 3=InPort, 4=PS/2, 5=HP)\nCL = interrupt (0=PS/2, 2=IRQ2, 3=IRQ3,...,7=IRQ7)"
      0x42: "MSMOUSE STORAGE REQUIREMENTS\nReturn: AX = FFFFh successful, BX = buffer size in bytes for functions 50h and 52h\nAX = 0000h MSMOUSE not installed\nAX = 0042h functions 42h, 50h, and 52h not supported"
      0x4D: "POINTER TO MICROSOFT COPYRIGHT\nReturn: ES:DI -> \"Copyright 1983 Microsoft ***\" "
      0x50: "MSMOUSE STATE\nBX = buffer size, ES:DX -> buffer\nReturn: AX = FFFFh if successful"
      0x52: "MSMOUSE STATE\nBX = buffer size, ES:DX -> buffer\nReturn: AX = FFFFh if successful"
}
0x34: "Borland/Microsoft languages - Floating Point emulation"
0x35: "Borland/Microsoft languages - Floating Point emulation"
0x36: "Borland/Microsoft languages - Floating Point emulation"
0x37: "Borland/Microsoft languages - Floating Point emulation"
0x38: "Borland/Microsoft languages - Floating Point emulation"
0x39: "Borland/Microsoft languages - Floating Point emulation"
0x3A: "Borland/Microsoft languages - Floating Point emulation"
0x3B: "Borland/Microsoft languages - Floating Point emulation"
0x3C: "Borland/Microsoft languages - Floating Point emulation"
0x3D: "Borland/Microsoft languages - Floating Point emulation"
0x3E: "Borland languages - Floating Point emulation \"shortcut\" call"
0x3F: "Overlay manager interrupt\n"
      "(Microsoft LINK.EXE, Borland TLINK VROOMM)"
0x40: "Hard disk - Relocated Floppy Handler (original INT 13h)"
0x41: "(NOT a vector!) FIXED DISK PARAMS (XT,AT,XT2,XT286,PS except ESDI)"
0x42: " - EGA/VGA/PS - Relocated (by EGA) Video Handler (original INT 10h)"
0x43: "EGA/VGA/PS - User font table"
0x44: "EGA/VGA/CONV/PS - EGA/PCjr fonts, characters 00h to 7Fh"
0x45: "Z100 - Master 8259 - Serial B"
0x46: "Secondary Fixed Disk Params (AT,XT286,PS except ESDI)"
0x47: { ah ?
      0x80: " - SQL Base - " { al ?
            0x00: "DATABASE ENGINE API\nDS:BX -> parameter block, first word is function number"
            0x01: "- SQL Base - GET VERSION NUMBER"
      }
}
0x48: "PCjr - Cordless Keyboard Translation"
0x49: "PCjr - Non-keyboard Scan Code Translation Table"
0x49: "Texas Instruments PC - VIDEO I/O???"
0x4A: "AT/CONV/PS - User Alarm"
0x4B: { ah ?
      0x81: "- Virtual DMA Specification (VDS) - " { al ?
            0x02: "GET VERSION\n"
                  "DX = 0\n"
                  "Return: CF clear if ok, AH=major version number, AL=minor version number\nBX = product number, CX = product revision number\n"
                  "SI:DI = maximum DMA buffer, DX=flags\n"
                  "CF set on error, AL=error code"
            0x03: "LOCK DMA REGION\nDS:SI -> DMA descriptor structure\nReturn:  CF clear if successful\nCF set on error, AL = error code"
            0x04: "UNLOCK DMA REGION\nDX = bit 0: reserved / 1: data should be copied out of buffer\nES:DI -> DMA descriptor structure with region size,\nReturn: CF clear if successful\nCF set on error, AL = error code"
            0x05: "SCATTER/GATHER LOCK REGION\nDX = flags\nES:DI -> Extended DMA descriptor structure\nReturn:  CF clear if successful\nCF set on error, AL = error code"
            0x06: "SCATTER/GATHER UNLOCK REGION\nDX = flags\nES:DI -> Extended DMA descriptor structure returned\nReturn: CF clear if successful\nCF set on error, AL = error code"
            0x07: "REQUEST DMA BUFFER\nDX = flags\nES:DI -> DMA descriptor structure with region size set\nReturn: CF clear if successful\nCF set on error, AL = error code"
            0x08: "RELEASE DMA BUFFFER\nDX = flags\nES:DI -> DMA descriptor structure with buffer ID set\nReturn: CF clear if successful\nCF set on error, AL = error code"
            0x09: "COPY INTO DMA BUFFER\nES:DI -> DMA descriptor structure with buffer ID\nBX:CX = starting offset into DMA buffer\nReturn: CF clear if successful\nCF set on error, AL = error code"
            0x0A: "COPY OUT OF DMA BUFFER\nES:DI -> DMA descriptor structure with buffer ID\nBX:CX = starting offset into DMA buffer\nReturn: CF clear if successful\nCF set on error, AL = error code"
            0x0B: "DISABLE DMA TRANSLATION\nBX = DMA channel number, DX = 0000h\nReturn: CF clear if successful\nCF set on error, AL = error code"
            0x0C: "ENABLE DMA TRANSLATION\nBX = DMA channel number, DX = 0000h\nReturn: CF clear if successful\nCF set on error, AL = error code"
      }
}
0x4C: "Z100 - Slave 8259 - S100 vectored line 4"
0x4D: "Z100 - Slave 8259 - S100 vectored line 5"
0x4E: "TI Professional PC - DISK I/O"
0x4F: "Common Access Method SCSI interface\nES:BX -> CAM Control Block (CCB)"
0x50: "through 57 - IRQ0-IRQ7 relocated by DESQview"
0x58: "IRQ8 relocated by DESQview 2.26+"
0x59: "GSS Computer Graphics Interface (GSS*CGI)\nDS:DX -> block of 5 array pointers\nReturn:   CF set on error, AX = error code\nCF clear if successful, AX = return code"
0x5A: "Cluster adapter BIOS entry address"
0x5B: "Microsoft Network Transport Layer Interface"
0x5C: "NETBIOS INTERFACE\nES:BX -> Network Control Block\nReturn: AL = status"
0x5D: "IRQ13 relocated by DESQview 2.26+"
0x5E: "IRQ14 relocated by DESQview 2.26+"
0x5F: "IRQ15 relocated by DESQview 2.26+"
0x60: { ah ?
      0x00: "SYS_PROF.EXE - PROFILER STATUS\nReturn: AX = 0000h    profiling is off\notherwise profiling is on"
      0x01: " - FTP Packet Driver - BASIC FUNC - " { al ?
            0xFF: "GET DRIVER INFO\n"
                  "BX=handle returned by function 02h\n"
                  "Return: CF set on error, DH=error code\n"
                  "CF clear if ok, BX=version\n"
                  "CH=network interface class, DX=interface type\n"
                  "CL=number, DS:SI->name, AL=driver functions"
      }
      0x02: "- FTP Packet Driver - BASIC FUNC - ACCESS TYPE\nAL = interface class, BX = interface type, DL = interface number\nDS:SI -> type, CX = length, ES:DI -> receiver\nReturn: CF set on error, DH = error code\nCF clear if successful, AX = handle"
      0x03: "- FTP Packet Driver - BASIC FUNC - RELEASE TYPE\nBX = handle\nReturn: CF set on error, DH = error code\nCF clear if successful"
      0x04: "- FTP Packet Driver - BASIC FUNC - SEND PACKET\nDS:SI -> buffer, CX = length\nReturn: CF set on error, DH = error code\nCF clear if successful"
      0x05: "- FTP Packet Driver - BASIC FUNC - TERMINATE DRIVER FOR HANDLE\nBX = handle\nReturn: CF set on error, DH = error code\nCF clear if successful"
      0x06: "- FTP Packet Driver - BASIC FUNC - GET ADDRESS\nBX = handle, ES:DI -> buffer, CX = length\nReturn: CF set on error, DH = error code\nCF clear if successful, CX = length"
      0x07: "- FTP Packet Driver - BASIC FUNC - RESET INTERFACE\nBX = handle\nReturn: CF set on error, DH = error code\nCF clear if successful"
      0x0A: "- FTP Packet Driver 1.09+ - HIGH-PERF FUNC - GET PARAMETERS\nReturn: CF set on error, DH = error code (0Bh)\nCF clear if successful, ES:DI -> parameter table"
      0x0B: "- FTP Packet Driver 1.09+ - HIGH-PERF FUNC - ASYNCHRONOUS SEND PACKET\nDS:SI -> buffer, CX = length of buffer\nES:DI -> FAR function to call when buffer becomes available\nReturn: CF set on error, DH = error code\nCF clear if successful"
      0x0C: "- Banyan VINES, 3com - GET STATION ADDRESS\nReturn: AL = status, 00h successful, ES:SI -> 6-byte station address\n02h semaphore service is unavailable"
      0x11: "- 10-NET, Banyan VINES - LOCK AND WAIT\nAL = drive number or 0, DX = number of seconds to wait\nES:SI = Ethernet address or 0, DS:BX -> 31-byte ASCIZ semaphore name\nReturn: AL = status"
      0x12: "- 10-NET, Banyan VINES - LOCK\nAL = drive number or 00h, ES:SI = Ethernet address or 0000h:0000h\nDS:BX -> 31-byte ASCIZ semaphore name\nReturn: AL = status\n01h semaphore currently locked by another PC"
      0x13: "- 10-NET, Banyan VINES - UNLOCK\nAL = drive number or 00h, ES:SI = Ethernet address or 0000h:0000h\nDS:BX -> 31-byte ASCIZ semaphore name\nReturn: AL = status, 1 semaphore not locked"
      0x14: "- FTP Packet Driver - EXTENDED FUNC - SET RECEIVE MODE\nBX = handle, CX = mode - " { cx ?
                0x01: "turn off receiver"
                0x02: "receive only packets sent to this interface"
                0x03: "mode 2 plus broadcast packets"
                0x04: "mode 3 plus limited multicast packets"
                0x05: "mode 3 plus all multicast packets"
                0x06: "all packets"
      }
      //?*? \nReturn: CF set on error, DH = error code (01h,08h)\nCF clear if successful"
      0x15: "- FTP Packet Driver - EXTENDED FUNC - GET RECEIVE MODE\nBX = handle\nReturn: CF set on error, DH = error code (01h)\nCF clear if successful, AX = mode"
      0x16: "- FTP Packet Driver - EXTENDED FUNC - SET MULTICAST LIST\nES:DI -> multicast list, CX = length of list in bytes\nReturn: CF set on error, DH = error code (06h,09h,0Eh)\nCF clear if successful"
      0x17: "- FTP Packet Driver - EXTENDED FUNC - GET MULTICAST LIST\nReturn: CF set on error, DH = error code (06h,09h)\nCF clear if successful, ES:DI -> multicast addresses\nCX = bytes of multicast addresses currently in use"
      0x18: "- FTP Packet Driver - EXTENDED FUNC - GET STATISTICS\nBX = handle\nReturn: CF set on error, DH = error code (01h)\nCF clear if successful, DS:SI -> statistics"
      0x19: "- FTP Packet Driver - EXTENDED FUNC - SET NETWORK ADDRESS\nES:DI -> address, CX = length of address\nReturn: CF set on error, DH = error code (0Dh,0Eh)\nCF clear if successful, CX = length"
}
0x61: "reserved for user interrupt"
0x62: "reserved for user interrupt"
0x63: "reserved for user interrupt"
0x64: "reserved for user interrupt"
0x65: "reserved for user interrupt"
0x66: "reserved for user interrupt"
0x67: " - LIM EMS "  { ah ?
      0x40: "- GET MANAGER STATUS\nReturn: AH = status"
      0x41: "- GET PAGE FRAME SEGMENT\nReturn: AH = 00h function successful, BX = segment of page frame\nAH = error code"
      0x42: "- GET NUMBER OF PAGES\nReturn: AH = 00h function successful, BX = number of unallocated pages\nDX = total number of pages\nAH = error code"
      0x43: "- GET HANDLE AND ALLOCATE MEMORY\nBX = number of logical pages to allocate\nReturn: AH = status"
      0x44: "- MAP MEMORY\nAL = physical page number (0-3)\nBX = logical page number, DX = handle\nReturn: AH = status"
      0x45: "- RELEASE HANDLE AND MEMORY\nDX = EMM handle\nReturn: AH = status"
      0x46: "- GET EMM VERSION\nReturn: AH = status"
      0x47: "- SAVE MAPPING CONTEXT\nDX = handle\nReturn: AH = status"
      0x48: "- RESTORE MAPPING CONTEXT\nDX = handle\nReturn: AH = status"
      0x49: "- reserved - GET I/O PORT ADDRESSES"
      0x4A: "- reserved - GET TRANSLATION ARRAY"
      0x4B: "- GET NUMBER OF EMM HANDLES\nReturn: AH = status"
      0x4C: "- GET PAGES OWNED BY HANDLE\nDX = EMM handle\nReturn: AH = status"
      0x4D: "- GET PAGES FOR ALL HANDLES\nES:DI -> array to receive information\nReturn: AH = status"
      0x4E: "- GET OR SET PAGE MAP\nDS:SI -> array holding information\nES:DI -> array to receive information\n" { al ?
            0x00: "if getting mapping registers"
            0x01: "if setting mapping registers"
            0x02: "if getting and setting mapping registers at once"
            0x03: "if getting size of page-mapping array"
      }
      //?*? Return: AH = status"
      0x4F: "4.0 - GET/SET PARTIAL PAGE MAP\nAL = " { al ?
                0x00: "get partial page map"
                0x01: "set partial page map"
                0x02: "get size of partial page map"
      }
      //?*? \nReturn: AH = status"
      0x50: "4.0 - MAP/UNMAP MULTIPLE HANDLE PAGES\nAL = 00h / 01h, DX = handle, CX = number of entries in array\nDS:SI -> mapping array\nReturn: AH = status"
      0x51: "4.0 - REALLOCATE PAGES\nDX = handle\nBX = number of pages to be allocated to handle\nReturn: BX = actual number of pages allocated to handle\nAH = status"
      0x52: "4.0 - GET/SET HANDLE ATTRIBUTES\nDX = handle, AL = " { al ?
                0x00: "get handle attributes\nReturn: AL = attribute, 00h handle is volatile, 01h handle is nonvolatile"
                0x01: "set handle attributes\nBL = new attribute"
                0x02: "get attribute capability\nReturn: AL = attribute capability\n00h only volatile handles supported\n01h both volatile and non-volatile supported"
      }
      //?*? \nReturn: AH = status"
      0x53: "4.0 - GET/SET HANDLE NAME\nAL = 00h get handle name / 01h set handle name,\nDS:SI -> 8-byte handle name, DX = handle\nReturn: AH = status"
      0x54: "4.0 - GET HANDLE DIRECTORY\nAL = " { al ?
                0x00: "get handle directory\nES:DI -> buffer for handle directory"
                0x01: "search for named handle\nDS:SI -> 8-byte name"
                0x02: "get total number of handles"
      }
      //?*? \nReturn: AL = number of entries in handle directory\nDX = value of named handle, BX = total number of handles\nAH = status"
      0x55: "4.0 - ALTER PAGE MAP AND JUMP\nDX = handle\nDS:SI -> structure containing map and jump address\nAL = " { al ?
                0x00: "physical page numbers provided by caller"
                0x01: "segment addresses provided by caller"
      }
      //?*? \nReturn: (at target address unless error)\nAH = status"
      0x56: "4.0 - ALTER PAGE MAP AND CALL\nAL = " { al ?
                0x00: "physical page numbers provided by caller"
                0x01: "segment addresses provided by caller"
                0x02: "get page map stack space required"
      }
      //?*? \nReturn: AH = status"
      0x57: "4.0 - MOVE/EXCHANGE MEMORY REGION\nAL = 00h move memory region / 01h exchange memory region\nDS:SI -> structure describing source and destination\nReturn: AH = status"
      0x58: "4.0 - GET MAPPABLE PHYSICAL ADDRESS ARRAY\nAL = " { al ?
                0x00: "get mappable physical address array\nES:DI -> buffer to be filled with array"
                0x01: "get number of entries in m.p.a. array"
      }
      //?*? \nReturn: CX = number of entries in array\nAH = status"
      0x59: "4.0 - GET EXPANDED MEMORY HARDWARE INFORMATION\nAL = " { al ?
                0x00: "get hardware configuration array\nES:DI -> buffer to be filled with array"
                0x01: "get unallocated raw page count\nReturn: BX = unallocated raw pages, DX = total raw pages"
      }
      //?*? \nReturn: AH = status"
      0x5A: "4.0 - ALLOCATE STANDARD/RAW PAGES\nAL = 00h allocate standard pages / 01h allocate raw pages\nBX = number of pages to allocate\nReturn: DX = handle, AH = status"
      0x5B: "4.0 - ALTERNATE MAP REGISTER SET\nAL = " { al ?
                0x00: "get alternate map register set\nReturn: BL = current active alternate map register set number\nES:DI -> map register context save area if BL=00h"
                0x01: "set alternate map register set\nBL = new alternate map register set number\nES:DI -> map register context save area if BL=0"
                0x02: "get alternate map save array size\nReturn: DX = array size in bytes"
                0x03: "allocate alternate map register set\nReturn: BL = number of map register set; 00h = not supported"
                0x04: "deallocate alternate map register set\nBL = number of alternate map register set"
      }
      //?*? \nReturn: AH = status"
      0x5B: "4.0 - ALTERNATE MAP REGISTER SET - DMA REGISTERS\nAL = "  { al ?
                0x05: "allocate DMA register set\nReturn: BL = DMA register set number, 00h if not supported"
                0x06: "enable DMA on alternate map register set\nBL = DMA register set number\nDL = DMA channel number"
                0x07: "disable DMA on alternate map register set\nBL = DMA register set number"
                0x08: "deallocate DMA register set\nBL = DMA register set number"
      }
      //?*? \nReturn: AH = status"
      0x5C: "4.0 - PREPARE EXPANDED MEMORY HARDWARE FOR WARM BOOT\nReturn: AH = status"
      0x5D: "4.0 - ENABLE/DISABLE OS FUNCTION SET FUNCTIONS\nBX,CX = access key returned by first invocation\nAL = " { al ?
                0x00: "enable OS Function Set"
                0x01: "disable OS Function Set"
                0x02: "return access key"
      }
      //?*? \nReturn: BX,CX = access key, returned only on first invocation of function\nAH = status"
      0x60: "GET PHYSICAL WINDOW ARRAY\nES:DI -> buffer\nReturn: AH = status, AL = number of entries, buffer at ES:DI filled"
      0x61: "GENERIC ACCELERATOR CARD SUPPORT"
      0x68: "GET ADDRESSES OF ALL PAGE FRAMES IN SYSTEM\nES:DI -> buffer\nReturn: AH = status, AL = number of entries, buffer at ES:DI filled"
      0x69: "MAP PAGE INTO FRAME\nAL = frame number, BX = page number, DX = handle\nReturn: AH = status"
      0x6A: "PAGE MAPPING\nAL = " { al ?
                0x00: "save partial page map\nCH = first page frame, CL = number of frames\nES:DI -> buffer which is to be filled"
                0x01: "restore partial page map\nCH = first page frame, CL = number of frames\nDI:SI -> previously saved page map"
                0x02: "save and restore partial page map\nCH = first page frame, CL = number of frames\nES:DI = buffer for current page map, DI:SI = new page map"
                0x03: "get size of save array\nCH = first page frame, CL = number of frames\nReturn: AL = size of array in bytes"
                0x04: "switch to standard map register setting"
                0x05: "switch to alternate map register setting"
                0x06: "deallocate pages mapped to frames in conventional memory\nCH = first page frame, CL = number of frames"
      }
      0xDE: "Program Interface - " { al ?
            0x00: "INSTALLATION CHECK\nReturn: AH = 00h    VCPI is present, BH = major version number\nBL = minor version number, AH nonzero  VCPI not present"
            0x01: "GET PROTECTED MODE INTERFACE\nES:DI -> 4K page table buffer\nDS:SI -> three descriptor table entries in GDT\nReturn: AH = 00h successful, AH = nonzero  failed"
            0x02: "GET MAX PHYSICAL MEMORY ADDRESS\nReturn: AH = 00h  successful, EDX = physical address of highest 4K memory page\nAH nonzero: failed"
            0x03: "GET NUMBER OF FREE 4K PAGES\nReturn: AH = 00h  successful, EDX = number of free 4K pages\nAH nonzero: failed"
            0x04: "ALLOCATE A 4K PAGE\nReturn: AH = 00h successful, EDX = physical address of allocated page\nAH nonzero: failed"
            0x05: "FREE 4K PAGE\nEDX = physical address of 4K page\nReturn: AH = 00h successful, EDX = physical address of allocated page\nAH nonzero: failed"
            0x06: "GET PHYS ADDR OF PAGE IN FIRST MB\nCX = page number (linear address shifted right 12 bits)\nReturn: AH = 00h successful, EDX = physical address of page\nAH nonzero: invalid page number (AH = 8Bh recommended)"
            0x07: "READ CR0\nReturn: AH = 00h, EBX = value of Control Register 0"
            0x08: "READ DEBUG REGISTERS\nES:DI -> array of 8 DWORDs\nReturn: AH = 00h\nbuffer filled with DR0 first, DR7 last, DR4 and DR5 unused"
            0x09: "SET DEBUG REGISTERS\nES:DI -> array of 8 DWORDs holding new values of debug registers\nReturn: AH = 00h"
            0x0A: "GET 8259 INTERRUPT VECTOR MAPPINGS\nReturn: AH = 00h successful, BX = first vector used by master 8259 (IRQ0)\nCX = first vector used by slave 8259 (IRQ8)\nAH nonzero: failed"
            0x0B: "SET 8259 INTERRUPT VECTOR MAPPINGS\nBX = first vector used by master 8259\nCX = first vector used by slave 8259\nReturn: AH = 00h successful, AH nonzero: failed"
            0x0C: "SWITCH TO PROTECTED MODE\nESI = linear address in first megabyte of values for system registers\nReturn: interrupts disabled\nGDTR, IDTR, LDTR, TR loaded"
      }
}
0x68: " - APPC/PC " { ah ?
        0x01: "\nDS:DX -> control block"
        0x02: "\nDS:DX -> control block"
        0x03: "\nDS:DX -> control block"
        0x04: "\nDS:DX -> control block"
        0x05: "- TRANSFER MSG DATA\nDS:DX -> control block"
        0x06: "- CHANGE NUMBER OF SESSIONS\nDS:DX -> control block"
        0x07: "- PASSTHROUGH\nDS:DX -> control block (format depends on application subsystem)"
        0xFA: "- ENABLE/DISABLE APPC\nAL bit 0 = 0 enable / 1 disable"
        0xFB: "- CONVERT\nDS:DX -> control block"
        0xFC: "- ENABLE/DISABLE MESSAGE TRACING\nAL = 00h disable tracing / 01h enable tracing\nDX = number of bytes to keep (0=all)"
        0xFD: "- ENABLE/DISABLE API VERB TRACING\nAL = 00h disable tracing / 01h enable tracing"
        0xFE: "- SET TRACE DESTINATION\nAL = trace destinations"
        0xFF: "- SET PASSTHROUGH\nDS:DX -> passthrough exit routine"
}
0x69: { ah ?
      0x01: "- DECnet DOS CTERM - "  { al ?
            0x00: "INSTALLATION CHECK\nReturn: AL = FFh if present"
            0x01: "SEND BYTE\nBL = character, DX = session handle\nReturn: AH >= 80h on error"
            0x02: "READ BYTE\nDX = session handle\nReturn: AH >= 80h on error, AH < 80h if successful\nAL = character"
            0x03: "STATUS\nDX = session handle\nReturn: AH status flags\nAL = reason code if DECnet error"
            0x04: "DECnet STATUS\nDX = session handle\nReturn: AX = reason code"
            0x05: "OPEN SESSION\nDS:BX -> ASCIZ node name\nES:DX -> buffer for session control block\nReturn: AX <= 0 on error, AX > 0 session handle"
            0x06: "CLOSE SESSION\nDX = session handle\nReturn: AH = 00h good close, other error code"
            0x0A: "GET SESSION CONTROL BLOCK SIZE\nReturn: AX = length of session control block in bytes"
            0x0B: "GET DECnet SOCKET\nDX = session handle\nReturn: AX > 0 DECnet socket for the session\nAX = 0 no match for handle"
            0x0F: "DEINSTALL CTERM\nReturn: AH = 00h succesful uninstall\nother error code"
      }
}
0x6A: "DECnet DOS LOCAL AREA TRANSPORT - " { ah ?
      0x01: "SEND BYTE\nAL = character, DH = FFh\nDL = handle\nReturn: AH >= 80h on error"
      0x02: "READ BYTE\nDH = FFh, DL = handle\nReturn: AH < 80h if successful, AL = character\nAH >= 80h on error"
      0x03: "STATUS\nDH = FFh, DL = handle\nReturn: AH = status flags"
      0xD0: "OPEN/CLOSE SESSION\nAL = FFh no password / 0Fh password at ES:DI, DH = FFh\nDS:BX -> LAT session control block\nES:DI -> 16-byte blank-padded password\nReturn: AH = 00h success, DL = handle"
      0xD1: "SEND BREAK\nDH = FFh, DL = handle\nReturn: AX = 0000h if successful\nAH bit 7 set is unable to send break"
      0xD3: "RESET LAT COUNTERS\nDH = FFh"
      0xD4: "COPY LAT COUNTERS\nDH = FFh, CX = buffer size\nES:BX -> buffer for LAT counters\nReturn: AX = 0000h counters copied into buffer\nAX = FFFFh buffer too small"
      0xD5: "GET NEXT LAT SERVICE NAME\nDH = FFh, ES:BX -> 17-byte buffer for name\nReturn: AH = 00h if successful, ES:BX buffer filled\nAX = FFFFh if end of table or no name available"
      0xD6: "LAT SERVICE TABLE RESET\nDH = FFh\nReturn: AX = number of service table entries, BX = 0000h service table has not overflowed\nAX = FFFFh service table has overflowed"
}
0x6B: "Novell NASI/NACS, Ungermann-Bass Net One SERIAL I/O - " { ah ?
      0x02: "INSTALL CHECK\nAL nonzero\nReturn: AL = 00h if present and OK"
      0x00: "BUFFERED WRITE\nCX = length, ES:BX -> buffer\nReturn: CX = number of bytes written"
      0x01: "BUFFERED READ\nCX = length of buffer, ES:BX -> buffer\nReturn: CX = number of bytes read"
      0x06: "CONTROL\nCX = " { cx ?
                0x02: "send break"
                0x04: "disconnect"
                0x06: "hold"
      }
      0x70: "GET STATUS\nReturn: CH <> 00h if connection active"
}
0x6C: "DOS 3.2 Realtime Clock update"
0x6D: "VGA - internal"
0x6E: "DECnet DOS - DECnet NETWORK PROCESS API"
0x6F:  { ah ?
       0x22: "HP ES-12 EXTENDED BIOS - READ CMOS MEMORY\nBP = 0012h, BL = address of CMOS byte to read\nReturn: AH = status, AL = byte read, BP, DS destroyed"
       0x24: "HP ES-12 EXTENDED BIOS - WRITE CMOS MEMORY\nBP = 0012h, BL = address of CMOS byte to write\nAL = new value\nReturn: AH = status, BP, DS destroyed"
       0x00: "10-NET - LOGIN\nDS:DX -> login record\nReturn: CL = security level, AX = status"
       0x01: "10-NET - LOGOFF\nDS:DX -> superstation ID or nulls (12 bytes)\nReturn: CX = number of files closed\nAX = status, FF08h superstation ID not already logged in"
       0x02: "10-NET - STATUS OF NODE\nDS:DX -> 512-byte status record\nReturn: CF set on error, AX = error code\nCF clear if successful"
       0x03: "10-NET - GET ADDRESS OF CONFIGURATION TABLE\nDS:DI -> node ID (optional)\nReturn: ES:BX -> configuration table"
       0x04: "10-NET - SEND\nDS:BX -> record, DS:DX -> data (max 1024 bytes)\nReturn: CF set on error, AX = error code\nCF clear if successful"
       0x05: "10-NET - RECEIVE\nCX = number of seconds before timeout\nDS:DX -> receive buffer\nReturn: CF set on error, AX = error code\nCF clear if successful, AH = FEh if dequeued message is a CB message"
       0x07: "10-NET - LOCK HANDLE\nBX = file handle, SI = record length\nCX:DX = starting offset in file\nReturn: CF set on error, AX = error code, 0002h file not found\nCF clear if successful"
       0x08: "10-NET - UNLOCK HANDLE\nBX = file handle\nAL = 00h unlock all / 01h unlock record at CX:DX\nReturn: CF set on error, AX = error code, 0002h file not found\nCF clear if successful"
       0x09: "10-NET - SUBMIT\nDS:BX -> submit record"
       0x0A: "10-NET - CHAT\nDS:BX -> control parameters\nDS:DX -> chat message"
       0x0B: "10-NET - LOCK SEMAPHORE, RETURN IMMEDIATELY\nAL = drive number or 0\nES:SI = Ethernet address or 0\nDS:BX -> 31-byte ASCIZ semaphore name\nReturn: AL = status"
       0x0C: "10-NET - UNLOCK SEMAPHORE\nAL = drive number or 0\nES:SI = Ethernet address or 0\nDS:BX -> 31-byte ASCIZ semaphore name\nReturn: AL = status, 01h semaphore not locked"
       0x0D: "10-NET - WHO\nAL = 01h return superstations only / 02h return non-superstations only\nCX = length of data, DS:DX -> array of records to be filled\nReturn: CL = number of records returned (responding stations)"
       0x0E: "10-NET - SPOOL/PRINT\nDS:DX -> spool/print record\nReturn: CF set on error, AX = error code\nCF clear if successful"
       0x10: "10-NET - ATTACH/DETACH PRINTER\nAL = " { al ?
                 0x00: "initiate spooling if LPT1 is mounted"
                 0x01: "terminate spooling if LPT1 is mounted"
       }
       0x11: "10-NET - LOCK FCB\nDS:DX -> FCB\nAL = " { al ?
                 0x01: "sequential"
                 0x02: "random"
                 0x03: "random block"
       }
             //?*? \nReturn: CF set on error, AX = error code\n2 file not found, CF clear if successful"
       0x12: "10-NET - UNLOCK FCB\nDS:DX -> FCB\nAL = " { al ?
             0x00: "sequential"
             0x01: "random"
             0x02: "random block"
       }
       //?*? \nReturn: CF set on error, AX = error code, 2 file not found\nCF clear if successful"
       0x13: "10-NET v3.3 - GET REMOTE CONFIGURATION TABLE ADDRESS\nDS:DX -> node ID, 12 bytes blank-padded\nReturn: CF set on error, AX = error code\nCF clear if successful, ES:BX = configuration table address on given machine"
       0x14: "10-NET v3.3 - GET REMOTE MEMORY\nBX:SI = address , CX = length, DS:DX -> node ID\nDS:DI -> area to receive remote memory image\nReturn: CF set on error, AX = error code\nCF clear if successful, CX = amount of memory copied to DS:SI"
       0x15: "10-NET v3.3 - " { al ?
             0x01: "GET SHARED DEVICE ENTRY\nBX = zero-based index, DS:SI -> node ID\nES:DI -> 85-byte buffer for shared device table entry\nReturn: CF set on error, AX = error code\nCF clear if successful, ES:DI buffer contains"
             0x02: "SET SHARED DEVICE ENTRY\nDS:SI -> node ID, 12 bytes blank-padded\nES:DI -> valid shared device table entry\nReturn: CF set on error, AX = error code\nCF clear if successful"
             0x03: "DELETE SHARED DEVICE ENTRY\nBX = zero-based index\nDS:SI -> node ID, 12 bytes blank-padded\nReturn: CF set on error, AX = error code\nCF clear if successful"
       }
       0x17: "10-NET v3.3 - MOUNT\nAL = local drive number (0=A:)\nBL = remote drive letter or '1'..'3' for LPTn or '4' or '5' for COMx\nDS:DX -> node ID, 12 bytes blank-padded\nReturn: CF set on error, AX = error code\nCF clear if successful"
       0x18: "10-NET v3.3 - UNMOUNT\nAL = local drive number (0=A:)\nBL = 00h Disk / 01h-03h LPTn / 04h,05h COMx\nReturn: CF set on error, AX = error code\nCF clear if successful"
}
0x70: "IRQ8 - AT/XT286/PS50+ - REAL-TIME CLOCK"
0x71: "IRQ9 - AT/XT286/PS50+ - LAN ADAPTER 1"
0x72: "IRQ10 - AT/XT286/PS50+ - RESERVED"
0x73: "IRQ11 - AT/XT286/PS50+ - RESERVED"
0x74: "IRQ12 - PS50+ - MOUSE INTERRUPT"
0x75: "IRQ13 - AT/XT286/PS50+ - 80287 ERROR"
0x76: "IRQ14 - AT/XT286/PS50+ - FIXED DISK"
0x77: "IRQ15 - AT/XT286/PS50+ - RESERVED"
0x78: "TARGA.DEV - " { ah ?
      0x00: "CMC International SCSI device driver - SET I/O PORT\nDX = interface board I/O port\nReturn: CF set on error, AL = error code"
      0x01: "GET I/O PORT\nReturn: DX = current interface board I/O port"
      0x02: "SET DMA CHANNEL\nAL = interface board DMA channel\nReturn: CF set on error, AL = error code"
      0x03: "GET DMA CHANNEL\nReturn: AL = current interface board DMA channel"
      0x04: "SET SCSI DEVICE NUMBER\nAL = SCSI device number\nReturn: CF set on error, AL = error code"
      0x05: "GET SCSI DEVICE NUMBER\nReturn: AL = current SCSI device number"
      0x06: "SET/CLEAR EARLY RETURN MODE\nAL = 00h clear early return mode\n     01h set early return mode"
      0x08: "INTERFACE BOARD SELF-TEST\nReturn: CF set on error, AL = error code"
      0x09: "RESET SCSI BUS\nReturn: AL = error code if carry set"
      0x10: "SEND SCSI COMMAND\nDS:SI -> command bytes\nReturn: AH = SCSI status byte, CF clear if successful, AL = SCSI message byte\nCF set on error, AL = error code"
      0x11: "SEND SCSI COMMAND, RECEIVE DATA (PROGRAMMED I/O)\nDS:SI -> command bytes, ES:BX -> data storage area\nCX = number of data bytes to transfer\nReturn: AH = SCSI status byte, CF clear if successful\nAL = SCSI message byte, CF set on error"
      0x12: "SEND SCSI COMMAND AND DATA (PROGRAMMED I/O)\nDS:SI -> command bytes, ES:BX -> data storage area\nCX = number of data bytes to transfer\nReturn: AH = SCSI status byte, CF clear if successful\nAL = SCSI message byte, CF set on error"
      0x13: "SEND SCSI COMMAND, RECEIVE DATA (DMA)\nDS:SI -> command bytes, ES:BX -> data storage area\nDX:CX = number of data bytes to transfer\nReturn: AH = SCSI status byte, CF clear if successful\nAL = SCSI message byte, CF set on error"
      0x14: "SEND SCSI COMMAND AND DATA (DMA)\nDS:SI -> command bytes, ES:BX -> data storage area\nDX:CX = number of data bytes to transfer\nReturn: AH = SCSI status byte, CF clear if successful\nAL = SCSI message byte, CF set on error"
      0x15: "FINISH DATA TRANSFER (DMA)\nReturn: AH = SCSI status byte\nCF clear if successful, AL = SCSI message byte\nCF set on error, AL = error code"
}
0x7A: "Novell NetWare to v2.0a - LOW-LEVEL API"
0x7B: "Eicon Access API (3270/5250 gateways)"
0x7C: "IBM REXX88PC command language"
0x7D: "not used"
0x7E: "not used"
0x7F: "HDILOAD.EXE - 8514/A VIDEO CONTROLLER INTERFACE\nAX = 0105h get entry points"

0x80:

{
  filetype ?
    f_MACHO:
#include "macsys.cmt"
    other:
#include "linux.cmt"
}

0x81:

// Mac OS X mach traps

{ ax ?
  // FIXME: use negative numbers
  //        Currently we cannot use them because r.value() returns 16-bit value
  0xFF9C: "iokit_user_client_trap"
  0xFFA2: "mk_timer_cancel_trap"
  0xFFA3: "mk_timer_arm_trap"
  0xFFA4: "mk_timer_destroy_trap"
  0xFFA5: "mk_timer_create_trap"
  0xFFA6: "mach_wait_until_trap"
  0xFFA7: "mach_timebase_info_trap"
  0xFFC2: "clock_sleep_trap"
  0xFFC3: "thread_switch"
  0xFFC4: "swtch"
  0xFFC5: "swtch_pri"
  0xFFCB: "macx_backing_store_recovery"
  0xFFCC: "macx_backing_store_suspend"
  0xFFCD: "macx_triggers"
  0xFFCF: "macx_swapoff"
  0xFFD0: "macx_swapon"
  0xFFD2: "pid_for_task"
  0xFFD3: "task_for_pid"
  0xFFD4: "task_name_for_pid"
  0xFFD5: "map_fd"
  0xFFD7: "init_process"
  0xFFD9: "semaphore_timedwait_signal_trap"
  0xFFDA: "semaphore_timedwait_trap"
  0xFFDB: "semaphore_wait_signal_trap"
  0xFFDC: "semaphore_wait_trap"
  0xFFDD: "semaphore_signal_thread_trap"
  0xFFDE: "semaphore_signal_all_trap"
  0xFFDF: "semaphore_signal_trap"
  0xFFE0: "mach_msg_overwrite_trap"
  0xFFE1: "mach_msg_trap"
  0xFFE3: "host_self_trap"
  0xFFE4: "task_self_trap"
  0xFFE5: "thread_self_trap"
  0xFFE6: "mach_reply_port"
}

0x86: "Relocated (by NETBIOS) INT 18"

0x87 ||
0x88 || 0x89 || 0x8A || 0x8B || 0x8C || 0x8D || 0x8E || 0x8F ||
0x90 || 0x91 || 0x92 || 0x93 || 0x94 || 0x95 || 0x96 || 0x97 ||
0x98 || 0x99 || 0x9A || 0x9B || 0x9C || 0x9D || 0x9E || 0x9F ||
0xA0 || 0xA1 || 0xA2 || 0xA3 || 0xA4 || 0xA5 || 0xA6 || 0xA7 ||
0xA8 || 0xA9 || 0xAA || 0xAB || 0xAC || 0xAD || 0xAE || 0xAF ||
0xB0 || 0xB1 || 0xB2 || 0xB3 || 0xB4 || 0xB5 || 0xB6 || 0xB7 ||
0xB8 || 0xB9 || 0xBA || 0xBB || 0xBC || 0xBD || 0xBE || 0xBF ||
0xC0 || 0xC1 || 0xC2 || 0xC3 || 0xC4 || 0xC5 || 0xC6 || 0xC7 ||
0xC8 || 0xC9 || 0xCA || 0xCB || 0xCC || 0xCD || 0xCE || 0xCF ||
0xD0 || 0xD1 || 0xD2 || 0xD3 || 0xD4 || 0xD5 || 0xD6 || 0xD7 ||
0xD8 || 0xD9 || 0xDA || 0xDB || 0xDC || 0xDD || 0xDE || 0xDF ||
0xE0 || 0xE1 || 0xE2 || 0xE3 || 0xE4 || 0xE5 || 0xE6 || 0xE7 ||
0xE8 || 0xE9 || 0xEA || 0xEB || 0xEC || 0xED || 0xEE:


        "used by BASIC while in interpreter"

0xEF: "compiled BASIC - ORIGINAL INT 09 VECTOR"
0xF0: "used by BASIC while in interpreter"
0xF1: "reserved for user interrupt"
0xF8: "10 ms INTERVAL TIMER (TANDY???)"
0xFA: "USART READY (RS-232C) (TANDY???)"
0xFB: "USART Rx READY (keyboard) (TANDY???)"
0xFE: "AT/XT286/PS50+ - destroyed by return from protected mode"
0xFF: "AT/XT286/PS50+ - destroyed by return from protected mode"

